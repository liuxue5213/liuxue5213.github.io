<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta name="author" content="johnscott" />
  
  
  
  <title>Mysql笔记 | JohnScott1989的博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="数据库,MYSQL," />
  

  <script>
    console.log('\n%c Hexo-theme-bmw v4.0 ' + '%c 🎉 https://github.com/dongyuanxin/theme-bmw 🎉\n' + '\n%c View demo online ' + '%c 🔍 https://godbmw.com/ 🔍  \n' , 'color: #fadfa3; background: #030307; padding:3px 0;', '', 'color: #fadfa3; background: #030307; padding:3px 0;', '');
  </script>

  
    <meta name="description" content="超级帽子戏法的个人博客,主要记录复制粘贴过来的笔记,还有自己的一些心得体会">
  

  

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/icon/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  
<script src="/js/util.js"></script>
<script src="/js/valine.min.js"></script>


  

  
    <link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js" async></script>
  

  
    <link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">
  
  
  <script src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js" async></script>
  
  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script>
  

<meta name="generator" content="Hexo 5.1.1"></head>

  <body>

    

    <div id="app">

      <div class="header-wrap">
  <header>
    <div class="site-brand">
      <div class="site-title">
        <a href="/">JohnScott2046</a>
      </div>
    </div>
    <nav class="site-navigation">
      <ul class="nav-menu">
      
        <li class="nav-item" data-path="/">
          
            <a 
              href="/"
              target="_self"
            >
              主页
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/archives/">
          
            <a 
              href="/archives/"
              target="_self"
            >
              归档
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/categories/">
          
            <a 
              href="/categories/"
              target="_self"
            >
              分类
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/tags/">
          
            <a 
              href="/tags/"
              target="_self"
            >
              标签
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/friends/">
          
            <a 
              href="/friends/"
              target="_self"
            >
              友链
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/about/">
          
            <a 
              href="/about/"
              target="_self"
            >
              关于
            </a>
          
        </li>
      
        <li class="nav-item" data-path="">
          
            <a href="javascript:void(0);" v-else>联系我</a>
            <ul class="nav-menu--dropdown">
              
                <li>
                  <a 
                    href="https://github.com/liuxue5213" 
                    target="_blank"
                  >
                    Github
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.zhihu.com/people/liuxue5213" 
                    target="_blank"
                  >
                    知乎
                  </a>
                </li>
              
                <li>
                  <a 
                    href="http://weibo.com/liuxue5213" 
                    target="_blank"
                  >
                    微博
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.douban.com/people/liuxue5213" 
                    target="_blank"
                  >
                    豆瓣
                  </a>
                </li>
              
                <li>
                  <a 
                    href="/linkedin.com/in/liuxue5213" 
                    target="_blank"
                  >
                    linkedin
                  </a>
                </li>
              
            </ul>
          
        </li>
      
      </ul>
    </nav>
    <i class="iconfont icon-menu"></i>
  </header>
</div>

<script>
  let links = document.querySelectorAll('.nav-item');
  for(let link of links){
    let childrenLink = link.querySelector('ul');
    link.addEventListener('mouseenter', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown active";
      }
    })
    link.addEventListener('mouseleave', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown";
      }
    })
  }
  let rootRealPath = getRealPath(window.location.pathname, true);
  for(let link of links) {
    let linkPath = link.getAttribute("data-path");
    if(linkPath && getRealPath(linkPath, true) === rootRealPath) {
      link.className = "nav-item hover";
    }
  }

  let iconMenu = document.querySelector("i.iconfont.icon-menu"),
    iconMenuClicked = false;
  let navDOM = document.querySelector("nav.site-navigation");
  iconMenu.addEventListener("click", () => {
    iconMenuClicked 
      ? navDOM.className = "site-navigation active"
      : navDOM.className = "site-navigation";
    iconMenuClicked = !iconMenuClicked;
  })
</script>

      








<div class="container post-index">

  

<div class="post">
  <h1 class="article-title">
    <span>Mysql笔记</span>
  </h1>
  <div class="article-top-meta">
    <span>
      发布 : 
      2020-08-01
    </span>
    
      <span>
        分类 : 
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">
            数据库
          </a>
      </span>
    
    
      <span>
        浏览 : <span class="article-timer" data-identity="Mysql笔记"></span>
      </span>
    
  </div>

  

  <div class="article-content">
    <div class="markdown-body">
      <p>mysql上面的问题 需要总结的内容过多 还在思考如何进行整理</p>
<hr>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节<br>对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储<br>因为：无符号相对于有符号可以多出一倍的存储空间</p>
<p>SIGNED INT -2147483648至2147483647<br>UNSIGNED INT 0至4294967295</p>
<p>VARCHAR(N)中的N代表的是字符数，而不是字节数<br>使用UTF8存储255个汉字 Varchar(255)=765个字节</p>
<h2 id="中文和数字拆分"><a href="#中文和数字拆分" class="headerlink" title="中文和数字拆分"></a>中文和数字拆分</h2><p>reverse(-(-reverse(field)))</p>
<h2 id="存储ip地址"><a href="#存储ip地址" class="headerlink" title="存储ip地址"></a>存储ip地址</h2><p>inet_aton 把ip转为无符号整型(4-8位)<br>inet_ntoa 把整型的ip转为地址<br>插入数据前，先用inet_aton把ip地址转为整型，可以节省空间。显示数据时，使用inet_ntoa把整型的ip地址转为地址显示即可</p>
<h2 id="数据库监控指标"><a href="#数据库监控指标" class="headerlink" title="数据库监控指标"></a>数据库监控指标</h2><p>查询Questions服务器状态变量值<br>SHOW GLOBAL STATUS LIKE “Questions”;</p>
<p>监控读指令的分解情况<br>SHOW GLOBAL STATUS LIKE “Com_select”;</p>
<p>监控写指令的分解情况<br>Writes = Com_insert + Com_update + Com_delete；<br>show GLOBAL status like “com_insert”;<br>SHOW GLOBAL STATUS LIKE “com_update”;<br>SHOW GLOBAL STATUS LIKE “com_delete”;</p>
<h2 id="为什么Mongodb索引用B树，而Mysql用B-树"><a href="#为什么Mongodb索引用B树，而Mysql用B-树" class="headerlink" title="为什么Mongodb索引用B树，而Mysql用B+树"></a>为什么Mongodb索引用B树，而Mysql用B+树</h2><p>B树<br>树内的每个节点都存储数据<br>叶子节点之间无指针相邻</p>
<p>B+树<br>数据只出现在叶子节点<br>所有叶子节点增加了一个链指针</p>
<p>(1)B树的树内存储数据，因此查询单条数据的时候，B树的查询效率不固定，最好的情况是O(1)。我们可以认为在做单一数据查询的时候，使用B树平均性能更好。但是，由于B树中各节点之间没有指针相邻，因此B树不适合做一些数据遍历操作。</p>
<p>(2)B+树的数据只出现在叶子节点上，因此在查询单条数据的时候，查询速度非常稳定。因此，在做单一数据的查询上，其平均性能并不如B树。但是，B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得B+树非常适合做范围查询。</p>
<p>Mongodb是做单一查询比较多，数据遍历操作比较少，所以用B树作为索引结构<br>因为Mysql是关系型数据库，而Mongodb是非关系型数据</p>
<h2 id="Mysql字符集"><a href="#Mysql字符集" class="headerlink" title="Mysql字符集"></a>Mysql字符集</h2><p>字符集是一套符号和编码的规则，不论是在oracle数据库还是在mysql数据库，都<br>存在字符集的选择问题，而且如果在数据库创建阶段没有正确选择字符集，那么可能在后期<br>需要更换字符集，而字符集的更换是代价比较高的操作，也存在一定的风险，所以，我们推<br>荐在应用开始阶段，就按照需求正确的选择合适的字符集，避免后期不必要的调整</p>
<p>查看所有mysql支持的字符集<br>show character set</p>
<p>在同一台服务器、同一个数据库、甚至同一个表的不同字段都可以指定使用不同的字符集</p>
<p>mysql的字符集包括字符集(CHARACTER)和校对规则(COLLATION)两个概念</p>
<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>mysql最好是用自增主键，<br>如果定义了主键，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则innodb 会选择第一个不包含有NULL值的唯一索引作为主键索引；<br>如果也没有这样的唯一索引，则innodb 会选择内置6字节长的ROWID作为隐含的聚集索引；</p>
<h2 id="主键自增和UUID"><a href="#主键自增和UUID" class="headerlink" title="主键自增和UUID"></a>主键自增和UUID</h2><ol>
<li>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li>
<li>如果使用非自增主键（如uuid），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到索引页的随机某个位置，此时MySQL为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成索引碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面</li>
</ol>
<h2 id="货币字段类型"><a href="#货币字段类型" class="headerlink" title="货币字段类型"></a>货币字段类型</h2><p>货币字段一般都用 Decimal类型，<br>float和double是以二进制存储的，数据大的时候，可能存在误差。</p>
<p>以下是FLOAT和DOUBLE的区别：</p>
<p>浮点数以8位精度存储在FLOAT中，并且有四个字节。</p>
<p>浮点数存储在DOUBLE中，精度为18位，有八个字节</p>
<h2 id="3NF（范式）"><a href="#3NF（范式）" class="headerlink" title="3NF（范式）"></a>3NF（范式）</h2><p>1NF 是数据库表中的任何属性都具有原子性的，不可再分解<br>2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性<br>3NF 是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余</p>
<h2 id="时间字段用什么类型"><a href="#时间字段用什么类型" class="headerlink" title="时间字段用什么类型"></a>时间字段用什么类型</h2><p>timestamp datatime int</p>
<p>timestamp，该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用timestamp类型存储的。<br>有一个优势，timestamp类型是带有时区信息的。如果系统中的时区发生改变，该字段的值会自动变更</p>
<p>datetime，占用8个字节，它存储的时间范围为1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。存储时间范围更大。它存储的是时间绝对值，不带有时区信息</p>
<p>int，自己维护一个时间戳，查询效率高，不过数据写入，显示都需要做转换。这种存储方式的具有 Timestamp 类型的所具有一些优点，并且使用它的进行日期排序以及对比等操作的效率会更高，跨系统也很方便。缺点就是无法直观看到具体时间</p>
<h2 id="字段为什么要定义为NOT-NULL"><a href="#字段为什么要定义为NOT-NULL" class="headerlink" title="字段为什么要定义为NOT NULL"></a>字段为什么要定义为NOT NULL</h2><ol>
<li><p>索引性能不好，Mysql不会优化空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。</p>
</li>
<li><p>如果某列存在null的情况，可能导致count() 等函数执行不对的情况。</p>
</li>
<li><p>sql 语句判断是否为空，又要判断是否为null等</p>
</li>
</ol>
<h2 id="数据库cpu到100-怎么处理"><a href="#数据库cpu到100-怎么处理" class="headerlink" title="数据库cpu到100%怎么处理"></a>数据库cpu到100%怎么处理</h2><ol>
<li><p>列出所有进程 show processlist 观察所有进程 多秒没有状态变化的(干掉)</p>
</li>
<li><p>查看慢查询，找出执行时间长的sql；explain分析sql是否走索引，sql优化；</p>
</li>
<li><p>检查其他子系统是否正常，是否缓存失效引起，需要查看buffer命中率；</p>
</li>
<li><p>开启慢查询日志，查看慢查询的 SQL</p>
</li>
</ol>
<h2 id="表锁和行锁的区别"><a href="#表锁和行锁的区别" class="headerlink" title="表锁和行锁的区别"></a>表锁和行锁的区别</h2><h2 id="char-和-varchar-区别"><a href="#char-和-varchar-区别" class="headerlink" title="char 和 varchar 区别"></a>char 和 varchar 区别</h2><p>长度范围，CHAR在声明时，m只能是0<del>255之间的数字；VARCHAR在声明时，m只能是0</del>4294967295范围的数字</p>
<p>varchar的速度却比char慢<br>varchar是处理非unicode数据,它处理的数据字节的长度是字符实际的长度</p>
<p>CHAR类型是定长的，MySQL总是根据定义的字符串长度分配足够的空间。当保存CHAR值时，在它们的右边填充空格以达到指定的长度，当检索到CHAR值时，尾部的空格被删除掉。</p>
<p>VARCHAR类型用于存储可变长字符串，存储时，如果字符没有达到定义的位数，也不会在后面补空格。但是，由于行是变长的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，在这种情况下InnoDB需要分裂页来使行可以放进页内，这样会增加碎片</p>
<p>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。例如，CHAR非常适合存储密码的MD5值，因为这是一个定长的值。对于经常变更的数据，CHAR也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片。对于非常短的列，CHAR比VARCHAR在存储空间上也更有效率。例如用CHAR(1)来存储只有Y和N的值，如果采用单字节字符集只需要一个字节，但是VARCHAR(1)却需要两个字节，因为还有一个记录长度的额外字节</p>
<p>使用VARCHAR的情况：字符串很长或者所要存储的字符串长短不一，差别很大；字符串列的最大长度比平均长度大得多</p>
<h2 id="如何处理死锁"><a href="#如何处理死锁" class="headerlink" title="如何处理死锁"></a>如何处理死锁</h2><p>数据库的锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性，这样才能保证在高并发的情况下，访问数据库的时候，数据不会出现问题<br>死锁是指两个或两个以上进程执行过程中，因竞争共享资源造成的相互等待现象<br>设置超时时间。超时后自动释放。<br>发起死锁检测，主动回滚其中一条事务，让其他事务继续执行</p>
<h2 id="like走索引吗"><a href="#like走索引吗" class="headerlink" title="like走索引吗"></a>like走索引吗</h2><p>Xxx% 走索引， %xxx不走索引</p>
<h2 id="什么是回表"><a href="#什么是回表" class="headerlink" title="什么是回表"></a>什么是回表</h2><p>在普通索引查到主键索引后，再去主键索引定位记录。等于说非主键索引需要多走一个索引树<br>索引覆盖被查询的字段来避免回表</p>
<h2 id="如何随机获取一条记录"><a href="#如何随机获取一条记录" class="headerlink" title="如何随机获取一条记录"></a>如何随机获取一条记录</h2><p>SELECT * FROM table_name ORDER BY rand() LIMIT 1</p>
<h2 id="查看当前表有哪些索引"><a href="#查看当前表有哪些索引" class="headerlink" title="查看当前表有哪些索引"></a>查看当前表有哪些索引</h2><p>show index from table_name;</p>
<h2 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h2><p>MVCC 全称是多版本并发控制系统，InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较</p>
<h2 id="索引不生效的情况"><a href="#索引不生效的情况" class="headerlink" title="索引不生效的情况"></a>索引不生效的情况</h2><p>使用不等于查询<br>NULL值<br>列参与了数学运算或者函数<br>在字符串like时左边是通配符.比如 %xxx<br>当mysql分析全表扫描比使用索引快的时候不使用索引.<br>当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引</p>
<h2 id="最多创建多少列索引"><a href="#最多创建多少列索引" class="headerlink" title="最多创建多少列索引"></a>最多创建多少列索引</h2><p>16</p>
<h2 id="设置引擎"><a href="#设置引擎" class="headerlink" title="设置引擎"></a>设置引擎</h2><p>通过<code>ENGINE=xxx</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table person(</span><br><span class="line">   id int primary key auto_increment,</span><br><span class="line">   username varchar(32)</span><br><span class="line">) ENGINE&#x3D;InnoDB&#96;</span><br></pre></td></tr></table></figure>


<h2 id="查找是否存在的count"><a href="#查找是否存在的count" class="headerlink" title="查找是否存在的count"></a>查找是否<code>存在</code>的count</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(*) FROM tables WHERE aa &#x3D; 1 AND bb &#x3D; 2</span><br></pre></td></tr></table></figure>

<p>优化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 FROM tables WHERE aa &#x3D; 1 AND bb &#x3D; 2 LIMIT 1</span><br></pre></td></tr></table></figure>

<h2 id="过大分页的查询性能问题"><a href="#过大分页的查询性能问题" class="headerlink" title="过大分页的查询性能问题"></a>过大分页的查询性能问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test where name&#x3D;111 limit 500000,5;</span><br></pre></td></tr></table></figure>
<p>查询到索引叶子节点数据。根据叶子节点上的主键值去聚簇索引上查询需要的全部字段值<br>像上面这样，需要查询500005次索引节点，查询500005次聚簇索引的数据，最后再将结果过滤掉前500000条，取出最后5条。MySQL耗费了大量随机I/O在查询聚簇索引的数据上，而有500000次随机I/O查询到的数据是不会出现在结果集当中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test a inner join (select id from test where name&#x3D;111 limit 500000,5) b on a.id&#x3D;b.id;</span><br></pre></td></tr></table></figure>

<p>InnoDB的buffer pool 里面存有最近访问过的数据页，包括数据页和索引页</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select index_name,count(*) from information_schema.INNODB_BUFFER_PAGE where INDEX_NAME in(&#39;name&#39;,&#39;primary&#39;) and TABLE_NAME like &#39;%test%&#39; group by index_name</span><br></pre></td></tr></table></figure>

<p>第一个sql会慢：读取大量的无用数据行（500000），最后却抛弃掉。而且这会造成一个问题：加载了很多热点不是很高的数据页到 <code>buffer pool</code>，会造成 <code>buffer pool</code> 的污染，占用 <code>buffer pool</code> 的空间</p>
<p>为了在每次重启时确保清空buffer pool，我们需要关闭 <code>innodb_buffer_pool_dump_at_shutdown</code> 和 <code>innodb_buffer_pool_load_at_startup</code>，这两个选项能够控制数据库关闭时dump出 <code>buffer pool</code> 中的数据和在数据库开启时载入在磁盘上备份 <code>buffer pool</code> 的数据</p>
<h2 id="数据拆分"><a href="#数据拆分" class="headerlink" title="数据拆分"></a>数据拆分</h2><p>关系型数据库本身比较容易成为系统瓶颈，单机存储容量、连接数、处理能力都有限。当单表的数据量达到1000W或100G以后，由于查询维度较多，即使添加从库、优化索引，做很多操作时性能仍下降严重。此时就要考虑对其进行拆分了，拆分的目的就在于减少数据库的负担，缩短查询时间</p>
<p>数据库分布式核心内容就是数据拆分（Sharding），以及拆分后对数据的定位、整合。<br>数据拆分就是将数据分散存储到多个数据库中，使得单一数据库中的数据量变小，通过扩充主机的数量缓解单一数据库的性能问题，从而达到提升数据库操作性能的目的</p>
<h3 id="一、-数据拆分类型"><a href="#一、-数据拆分类型" class="headerlink" title="一、 数据拆分类型"></a>一、 数据拆分类型</h3><p>可以分为两种方式：垂直（纵向）拆分和水平（横向）拆分</p>
<h4 id="1-垂直（纵向）拆分"><a href="#1-垂直（纵向）拆分" class="headerlink" title="1. 垂直（纵向）拆分"></a>1. 垂直（纵向）拆分</h4><p>垂直拆分常见有<code>垂直分库</code>和<code>垂直分表</code>两种</p>
<p>垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与”微服务治理”的做法相似，每个微服务使用单独的一个数据库</p>
<p>垂直分表是基于数据库中的”列”进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。在字段很多的情况下（例如一个大表有100多个字段），通过”大表拆小表”，更便于开发与维护，也能避免跨页问题，MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>解决业务系统层面的耦合，业务清晰<br>与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等<br>高并发场景下，垂直拆分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度<br>分布式事务处理复杂<br>依然存在单表数据量过大的问题（需要水平拆分）</p>
<h4 id="2、水平（横向）拆分"><a href="#2、水平（横向）拆分" class="headerlink" title="2、水平（横向）拆分"></a>2、水平（横向）拆分</h4><p>当一个应用难以再细粒度的垂直拆分，或拆分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平拆分了。</p>
<p>水平拆分分为<code>库内分表</code>和<code>分库分表</code>，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果</p>
<p><code>库内分表</code>只解决了单一表数据量过大的问题，但没有将表分布到不同机器的库上，因此对于减轻MySQL数据库的压力来说，帮助不是很大，大家还是竞争同一个物理机的CPU、内存、网络IO，最好通过分库分表来解决</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力<br>应用端改造较小，不需要拆分业务模块</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>跨分片的事务一致性难以保证<br>跨库的join关联查询性能较差<br>数据多次扩展难度和维护量极大</p>
<h4 id="水平拆分后同一张表会出现在多个数据库-表中，每个库-表的内容不同。"><a href="#水平拆分后同一张表会出现在多个数据库-表中，每个库-表的内容不同。" class="headerlink" title="水平拆分后同一张表会出现在多个数据库/表中，每个库/表的内容不同。"></a>水平拆分后同一张表会出现在多个数据库/表中，每个库/表的内容不同。</h4><ol>
<li>根据数值范围<br>按照时间区间或ID区间来拆分。例如：按日期将不同月甚至是日的数据分散到不同的库中；将userId为1<del>9999的记录分到第一个库，10000</del>20000的分到第二个库，以此类推。某种意义上，某些系统中使用的”冷热数据分离”，将一些使用较少的历史数据迁移到其他库中，业务功能上只提供热点数据的查询，也是类似的实践。</li>
</ol>
<p>优点<br>单表大小可控<br>天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移<br>使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。</p>
<p>缺点<br>热点数据成为性能瓶颈。连续分片可能存在数据热点，例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询</p>
<ol start="2">
<li>根据数值取模<br>一般采用hash取模mod的拆分方式，例如：将 Customer 表根据 cusno 字段拆分到4个库中，余数为0的放到第一个库，余数为1的放到第二个库，以此类推。这样同一个用户的数据会分散到同一个库中，如果查询条件带有cusno字段，则可明确定位到相应库去查询。</li>
</ol>
<p>优点<br>数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈</p>
<p>缺点<br>后期分片集群扩容时，需要迁移旧的数据（使用一致性hash算法能较好的避免这个问题）<br>容易面临跨分片查询的复杂问题。比如上例中，如果频繁用到的查询条件中不带cusno时，将会导致无法定位数据库，从而需要同时向4个库发起查询，再在内存中合并数据，取最小集返回给应用，分库反而成为拖累</p>
<h3 id="二、-分库分表带来的问题"><a href="#二、-分库分表带来的问题" class="headerlink" title="二、 分库分表带来的问题"></a>二、 分库分表带来的问题</h3><ol>
<li>事务一致性问题</li>
</ol>
<p>分布式事务<br>当更新内容同时分布在不同库中，不可避免会带来跨库事务问题。跨分片事务也是分布式事务，没有简单的方案，一般可使用<code>XA协议</code>和<code>两阶段提交</code>处理。</p>
<p>分布式事务能最大限度保证了数据库操作的原子性。但在提交事务时需要协调多个节点，推后了提交事务的时间点，延长了事务的执行时间。导致事务在访问共享资源时发生冲突或死锁的概率增高。随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平扩展的枷锁</p>
<p>最终一致性<br>对于那些性能要求很高，但对一致性要求不高的系统，往往不苛求系统的实时一致性，只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。与事务在执行中发生错误后立即回滚的方式不同，事务补偿是一种事后检查补救的措施，一些常见的实现方法有：对数据进行对账检查，基于日志进行对比，定期同标准数据来源进行同步等等。事务补偿还要结合业务系统来考虑</p>
<ol start="2">
<li>跨节点关联查询 join 问题<br>拆分之前，系统中很多列表和详情页所需的数据可以通过sql join来完成。而拆分之后，数据可能分布在不同的节点上，此时join带来的问题就比较麻烦了，考虑到性能，尽量避免使用join查询</li>
</ol>
<p>解决这个问题的一些方法</p>
<p>全局表<br>也可看做是”数据字典表”，就是系统中所有模块都可能依赖的一些表，为了避免跨库join查询，可以将这类表在每个数据库中都保存一份。这些数据通常很少会进行修改，所以也不担心一致性的问题。</p>
<p>字段冗余<br>一种典型的反范式设计，利用空间换时间，为了性能而避免join查询。例如：订单表保存userId时候，也将userName冗余保存一份，这样查询订单详情时就不需要再去查询”买家user表”了。但这种方法适用场景也有限，比较适用于依赖字段比较少的情况。而冗余字段的数据一致性也较难保证</p>
<p>数据组装<br>在系统层面，分两次查询，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。</p>
<p>ER分片<br>关系型数据库中，如果可以先确定表之间的关联关系，并将那些存在关联关系的表记录存放在同一个分片上，那么就能较好的避免跨分片join问题。在1:1或1:n的情况下，通常按照主表的ID主键拆分</p>
<ol start="3">
<li>跨节点分页、排序、函数问题</li>
</ol>
<p>跨节点多库进行查询时，会出现limit分页、order by排序等问题。分页需要按照指定字段进行排序，当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户</p>
<p>上图中只是取第一页的数据，对性能影响还不是很大。但是如果取得页数很大，情况则变得复杂很多，因为各分片节点中的数据可能是随机的，为了排序的准确性，需要将所有节点的前N页数据都排序好做合并，最后再进行整体的排序，这样的操作时很耗费CPU和内存资源的，所以页数越大，系统的性能也会越差。</p>
<p>在使用Max、Min、Sum、Count之类的函数进行计算的时候，也需要先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终将结果返回</p>
<ol start="4">
<li>全局主键避重问题</li>
</ol>
<p>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库自生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题。有一些常见的主键生成策略：</p>
<p>UUID<br>UUID是主键是最简单的方案，本地生成，性能高，没有网络耗时。但缺点也很明显，由于UUID非常长，会占用大量的存储空间；另外，作为主键建立索引和基于索引进行查询时都会存在性能问题，在InnoDB下，UUID的无序性会引起数据位置频繁变动，导致分页<br>UUID标准形式包含32个16进制数字，分为5段，形式为8-4-4-4-12的36个字符，例如：550e8400-e29b-41d4-a716-446655440000</p>
<p>Snowflake分布式自增ID算法<br>Twitter的snowflake算法解决了分布式系统生成全局ID的需求，生成64位的Long型数字</p>
<p>组成部分：<br>第一位未使用<br>    接下来41位是毫秒级时间，41位的长度可以表示69年的时间<br>    5位datacenterId，5位workerId。10位的长度最多支持部署1024个节点<br>    最后12位是毫秒内的计数，12位的计数顺序号支持每个节点每毫秒产生4096个ID序列</p>
<p>这样的好处是：毫秒数在高位，生成的ID整体上按时间趋势递增；不依赖第三方系统，稳定性和效率较高，理论上QPS约为<code>409.6w/s（1000*2^12）</code>，并且整个分布式系统内不会产生ID碰撞；可根据自身业务灵活分配bit位。</p>
<p>不足就在于：强依赖机器时钟，如果时钟回拨，则可能导致生成ID重复</p>
<ol start="5">
<li>数据迁移、扩容问题</li>
</ol>
<p>当业务高速发展，面临性能和存储的瓶颈时，才会考虑分片设计，此时就不可避免的需要考虑历史数据迁移的问题。一般做法是先读出历史数据，然后按指定的分片规则再将数据写入到各个分片节点中。此外还需要根据当前的数据量和QPS，以及业务发展的速度，进行容量规划，推算出大概需要多少分片（一般建议单个分片上的单表数据量不超过1000W）</p>
<p>如果采用数值范围分片，只需要添加节点就可以进行扩容了，不需要对分片数据迁移。如果采用的是数值取模分片，则考虑后期的扩容问题就相对比较麻烦</p>
<p>三. 什么时候考虑拆分<br>1、能不拆分尽量不要拆分</p>
<p>并不是所有表都需要进行拆分，主要还是看数据的增长速度。拆分后会在某种程度上提升业务的复杂度，数据库除了承载数据的存储和查询外，协助业务更好的实现需求也是其重要工作之一。</p>
<p>不到万不得已不用轻易使用分库分表这个大招，避免”过度设计”和”过早优化”。分库分表之前，不要为分而分，先尽力去做力所能及的事情，例如：升级硬件、升级网络、读写分离、索引优化等等。当数据量达到单表的瓶颈时候，再考虑分库分表</p>
<p>2、数据量过大，影响业务访问</p>
<p>1）对数据库备份，如果单表太大，备份时需要大量的磁盘IO和网络IO。例如1T的数据，网络传输占50MB时候，需要20000秒才能传输完毕，整个过程的风险都是比较高的</p>
<p>2）对一个很大的表进行DDL修改时，MySQL会锁住全表，这个时间会很长，这段时间业务不能访问此表，影响很大。如果使用pt-online-schema-change，使用过程中会创建触发器和影子表，也需要很长的时间。在此操作过程中，都算为风险时间。将数据表拆分，总量减少，有助于降低这个风险。</p>
<p>3）大表会经常访问与更新，就更有可能出现锁等待。将数据拆分，用空间换时间，变相降低访问压力</p>
<ol start="3">
<li><p>随着业务发展，需要对某些字段垂直拆分</p>
</li>
<li><p>数据量快速增长</p>
</li>
</ol>
<p>随着业务的快速发展，单表中的数据量会持续增长，当性能接近瓶颈时，就需要考虑水平拆分，做分库分表了。此时一定要选择合适的拆分规则，提前预估好数据容量</p>
<ol start="5">
<li>安全性和可用性</li>
</ol>
<p>鸡蛋不要放在一个篮子里。在业务层面上垂直拆分，将不相关的业务的数据库分隔，因为每个业务的数据量、访问量都不同，不能因为一个业务把数据库搞挂而牵连到其他业务。利用水平拆分，当一个数据库出现问题时，不会影响到100%的用户，每个库只承担业务的一部分数据，这样整体的可用性就能提高</p>
<h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><p>select_type</p>
<p>table<br>显示这一行的数据是关于哪张表的。不一定是实际存在的表名</p>
<dl><dt>&lt;unionM,N&gt;: 引用id为M和N UNION后的结果。<br>: 引用id为N的结果派生出的表。派生表可以是一个结果集，例如派生自FROM中子查询的结果。</dt><dd>引用id为N的子查询结果物化得到的表。即生成一个临时表保存子查询的结果</dd></dl><p>type<br>显示查询使用了何种类型<br>从最好到最差的连接类型依次为 system，const，eq_ref，ref，fulltext，ref_or_null，index_merge，unique_subquery，index_subquery，range，index，ALL</p>
<p>1、system<br>表中只有一行数据或者是空表，这是const类型的一个特例。且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</p>
<p>2、const<br>最多只有一行记录匹配。当联合主键或唯一索引的所有字段跟常量值比较时，join类型为const。其他数据库也叫做唯一索引扫描</p>
<p>3、eq_ref<br>多表join时，对于来自前面表的每一行，在当前表中只能找到一行。这可能是除了system和const之外最好的类型。当主键或唯一非NULL索引的所有字段都被用作join联接时会使用此类型。</p>
<p>eq_ref可用于使用’=’操作符作比较的索引列。比较的值可以是常量，也可以是使用在此表之前读取的表的列的表达式。</p>
<p>相对于下面的ref区别就是它使用的唯一索引，即主键或唯一索引，而ref使用的是非唯一索引或者普通索引。 eq_ref只能找到一行，而ref能找到多行</p>
<p>4、ref<br>对于来自前面表的每一行，在此表的索引中可以匹配到多行。若联接只用到索引的最左前缀或索引不是主键或唯一索引时，使用ref类型（也就是说，此联接能够匹配多行记录）。<br>ref可用于使用’=’或’&lt;=&gt;’操作符作比较的索引列</p>
<p>5、 fulltext<br>使用全文索引的时候是这个类型。要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p>
<p>6、ref_or_null<br>跟ref类型类似，只是增加了null值的比较。实际用的不多。</p>
<p>7、index_merge<br>表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取多个索引，性能可能大部分时间都不如range</p>
<p>8、unique_subquery<br>用于where中的in形式子查询，子查询返回不重复值唯一值，可以完全替换子查询，效率更高。 该类型替换了下面形式的IN子查询的ref： value IN (SELECT primary_key FROM single_table WHERE some_expr)</p>
<p>9、index_subquery<br>该联接类型类似于unique_subquery。适用于非唯一索引，可以返回重复值</p>
<p>10、range<br>索引范围查询，常见于使用 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN()或者like等运算符的查询中</p>
<p>11、index<br>索引全表扫描，把索引从头到尾扫一遍。这里包含两种情况： 一种是查询使用了覆盖索引，那么它只需要扫描索引就可以获得数据，这个效率要比全表扫描要快，因为索引通常比数据表小，而且还能避免二次查询。在extra中显示Using index，反之，如果在索引上进行全表扫描，没有Using index的提示</p>
<p>12、all<br>全表扫描，性能最差</p>
<p>possible_keys<br>查询可能使用到的索引都会在这里列出来</p>
<p>Key<br>key列显示MySQL实际使用的键（索引)<br>要想强制MySQL使用或忽视possible_keys列中的索引，可以使用FORCE INDEX、USE INDEX或者IGNORE INDEX。<br>select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个</p>
<p>key_len<br>表示索引中使用的字节数<br>key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。<br>不损失精确性的情况下，长度越短越好</p>
<p>ref<br>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p>rows<br>这是mysql估算的需要扫描的行数（不是精确值）</p>
<p>Extra<br>Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤。<br>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询。<br>Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”。<br>Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。<br>Impossible where：这个值强调了where语句会导致没有符合条件的行。<br>Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p>
<h2 id="mysql有关权限的表都有哪几个"><a href="#mysql有关权限的表都有哪几个" class="headerlink" title="mysql有关权限的表都有哪几个"></a>mysql有关权限的表都有哪几个</h2><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。db权限表：记录各个帐号在各个数据库上的操作权限。table_priv权限表：记录数据表级的操作权限。columns_priv权限表：记录数据列级的操作权限。host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响</p>
<h2 id="MySQL的binlog有有几种录入格式？分别有什么区别"><a href="#MySQL的binlog有有几种录入格式？分别有什么区别" class="headerlink" title="MySQL的binlog有有几种录入格式？分别有什么区别"></a>MySQL的binlog有有几种录入格式？分别有什么区别</h2><p>有三种格式，statement，row和mixed。statement模式下，每一条会修改数据的sql都会记录在binlog中。<br>不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。<br>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录</p>
<h2 id="mysql有哪些数据类型"><a href="#mysql有哪些数据类型" class="headerlink" title="mysql有哪些数据类型"></a>mysql有哪些数据类型</h2><p>、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。例子：假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。<br>2、实数类型，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。<br>3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOBVARCHAR用于存储可变长字符串，它比定长类型更节省空间。VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。VARCHAR存储的内容超出设置的长度时，内容会被截断。CHAR是定长的，根据定义的字符串长度分配足够的空间。CHAR会根据需要使用空格进行填充方便比较。CHAR适合存储很短的字符串，或者所有值都接近同一个长度。CHAR存储的内容超出设置的长度时，内容同样会被截断。<br>4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数<br>5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。如果需要存储微妙，可以使用bigint存储</p>
<h2 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h2><p>插入缓冲（insert buffer)<br>二次写(double write)<br>自适应哈希索引(ahi)<br>预读(read ahead)</p>
<h2 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h2><p>由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。<br>所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。我们想要删除百万数据的时候可以先删除索引，然后删除其中无用数据，删除完成后重新创建索引</p>
<h2 id="InnoDB存储引擎的锁的算法有哪三种"><a href="#InnoDB存储引擎的锁的算法有哪三种" class="headerlink" title="InnoDB存储引擎的锁的算法有哪三种"></a>InnoDB存储引擎的锁的算法有哪三种</h2><p>Record lock：单个行记录上的锁<br>Gap lock：间隙锁，锁定一个范围，不包括记录本身<br>Next-key lock：record+gap 锁定一个范围，包含记录本身</p>
<h2 id="数据库的乐观锁和悲观锁是什么"><a href="#数据库的乐观锁和悲观锁是什么" class="headerlink" title="数据库的乐观锁和悲观锁是什么"></a>数据库的乐观锁和悲观锁是什么</h2><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。<br>悲观说：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制<br>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现</p>
<h2 id="大表数据查询，怎么优化"><a href="#大表数据查询，怎么优化" class="headerlink" title="大表数据查询，怎么优化"></a>大表数据查询，怎么优化</h2><p>优化shema、sql语句+索引；<br>第二加缓存，memcached, redis；<br>主从复制，读写分离；<br>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统<br>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表</p>
<h2 id="UNION与UNION-ALL的区别"><a href="#UNION与UNION-ALL的区别" class="headerlink" title="UNION与UNION ALL的区别"></a>UNION与UNION ALL的区别</h2><p>如果使用UNION ALL，不会合并重复的记录行<br>效率 UNION 高于 UNION ALL</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>初始记录行的偏移量是0<br>LIMIT 接受一个或两个数字参数。<br>参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。</p>
    </div>
  </div>
  
    <div class="copy-right">
      <div class="markdown-body">
        <blockquote>
        
        
          本文作者 : JohnScott <br/>
        
        原文链接 : <a href="">https://github.com/liuxue5213/liuxue5213.github.io/2020/Mysql%E7%AC%94%E8%AE%B0/</a><br>
        版权声明 : 本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
        </blockquote>
      </div>
    </div>
  
  
  
    <div class="social-share"
  style="margin-top: -2rem"
  data-wechat-qrcode-title="<p>微信扫一扫</p>"
  data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>"
   data-sites="qzone, qq, weibo, wechat, douban, google, facebook, twitter" 
  
>
  <span style="color: #6b7487; font-size: 1.4rem;">分享到: </span>
</div>
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" async>
  

  
    <div id="reward">
  
    <p id="reward-meta">知识 & 情怀 | 二者兼得</p>
  
  <button id="reward-btn">
    
    <span>感谢您的关心</span>
  </button>
  <div id="reward-qrcode">
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/wechat.png" alt="微信扫一扫">
        <p class="qrcode-meta">微信扫一扫</p>
      </div>
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/alipay.png" alt="支付宝扫一扫">
        <p class="qrcode-meta">支付宝扫一扫</p>
      </div>
    
  </div>

</div>

<script>
  (() => {
    let button = document.querySelector('#reward-btn'),
      qrcode = document.querySelector('#reward-qrcode'),
      display = false;
    
    button.addEventListener('click', () => {
      qrcode.style.display = display ? 'none' : 'block'
      display = !display
    }, false)
  })()
</script>
  

  <div class="article-footer">
    <div class="article-meta pull-left">
      <span>
        
          <i class="iconfont icon-06tags"></i>标签: 
          
          <span class="span--tag">
            <a href="/tags/MYSQL/">
              #MYSQL
            </a>
          </span>
          
        
      </span>
    </div>
    <div class="article-meta pull-right">
    </div>
  </div>
</div>


  <aside id="sidebar">
    <p id="sidebar-header"></p>
    <ol id="sidebar-toc"></ol>
  </aside>
  <script async>setTimeout(generateToc, 10);</script>


  <nav class="post-navigation">
    
      <div class="nav-pre">
        <i class="iconfont icon-prev"></i>
        上一篇:
        <a href="/2020/Mysql%E7%B4%A2%E5%BC%95/" target="_self">Mysql索引</a>
      </div>
    
    
      <div class="nav-next">
        下一篇:
        <a href="/2020/Mysql-select/" target="_self">Mysql-select</a>
        <i class="iconfont icon-next"></i>
      </div>
    
  </nav>

  
    <a href="#comment" class="comment-anchor"></a>
<div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹 <i class="iconfont icon-footprint"></i></div>
<div id="vcomments"></div>

<script defer>
  if( true ) {
    let path = getRealPath()
    new Valine({
      el: "#vcomments",
      appId: "E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz",
      appKey: "6VNHrdDAu0JKJXxyMajHk6qD",
      notify: false,
      verify: false,
      avatar: "robohash",
      placeholder: "正确填写邮箱, 才能及时收到回复哦♪(^∇^*)",
      path
    });
  }
</script>
   

  
    <script defer>
const valineAPI = (() => {
  try {
    AV.init("E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz", "6VNHrdDAu0JKJXxyMajHk6qD");
  } catch(error) {}
  const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
      query.equalTo("identity", identity);
      query.find().then(results => {
        resolve(results.length > 0);
      }, error => reject(error));
    })
  }

  const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
      let querys = [];
      for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
      }
      query = AV.Query.or.apply(null ,querys);
    } else {
      identity = identity || getRealPath();
      query = new AV.Query("Timer");
      query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
      query.find()
      .then(results => resolve(results))
      .catch(error => reject(error))
    })
  }

  const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let Todo = AV.Object.extend('Timer');
      let todo = new Todo();
      todo.set("times", 1);
      todo.set("identity", identity);
      todo.save().then(res => resolve(true), error => reject(error));
    })
  }

  const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let query = new AV.Query('Timer');
      query.equalTo("identity", identity);
      query.find().then(todos => {
        todos.forEach(todo => {
          todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
      }).then(todos => resolve(true), error => reject(error));
    })
  }

  return {
    isExist,
    _get,
    update,
    create
  }
})()

const calcAndWriteTimes = () => {
  let isPost = true;

  let timerAllDOM = document.querySelectorAll(".article-timer");

  if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
      if(exist) {
        return valineAPI.update(identity);
      }
      return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
  }

  let timerDOMCache = {};

  for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
      timerDOMCache[identity].dom.push(timerDOM);
    }else{
      timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
      };
    }
  }

  let identities = Object.keys(timerDOMCache);
  valineAPI._get(identities).then(results => {
    for(let result of results) {
      let {identity, times} = result.attributes;
      timerDOMCache[identity].times = times;
      timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
      if(timerDOMCache[identity].times){
        continue;
      }
      timerDOMCache[identity].dom.map(item => item.innerText = 1);
      valineAPI.create(identity);
    }
  }).catch(error => console.log(error.message))
}

if(true){
  calcAndWriteTimes();
}
</script>
   

</div>


      <footer>
  <p class="site-info">
    博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span>
    <br>
    Theme - <a href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by <a target="_blank" rel="noopener" href="https://godbmw.com/">GodBMW</a>
    <br>
    
  </p>
</footer>



<script>
const timeToNowDOM = document.querySelector("#time-to-now");
const startTimestamp = new Date(2015, 0, 1).getTime();

const updateTimeStr = () => {
  let offset = parseInt(
      (new Date().getTime() - startTimestamp) / 1000,
      10
    ),
    day = Math.floor(offset / 86400),
    hour = Math.floor((offset % 86400) / 3600),
    minute = Math.floor(((offset % 86400) % 3600) / 60),
    second = Math.floor(((offset % 86400) % 3600) % 60);
  timeToNowDOM.innerHTML =
    day + "天" + hour + "小时" + minute + "分钟" + second + "秒";
  setTimeout(updateTimeStr, 500);
}

setTimeout(updateTimeStr, 500);
</script>


      <div class="back-to-top hidden">
  <span>
    <i class="iconfont icon-60"></i><span></span>%
  </span>
</div>

<script>
const updateIconToTop = percent => {
  let dom = document.querySelector(".back-to-top span span");
  dom.innerText = percent;
  if(percent < 1) {
    document.querySelector(".back-to-top").className = "back-to-top hidden";
  } else {
    document.querySelector(".back-to-top").className = "back-to-top";
  }
}

const handleScoll = () => {
  let isRunning = false;
  return () => {
    if (isRunning) return;
    isRunning = true;
    window.requestAnimationFrame(timestamp => {
      let scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop,
        scrollHeight =
          document.documentElement.scrollHeight ||
          document.body.scrollHeight,
        clientHeight =
          document.documentElement.clientHeight ||
          document.body.clientHeight;
      isRunning = false;
      if (scrollTop <= 1) {
        updateIconToTop(0);
        return;
      }
      if (scrollTop + clientHeight >= scrollHeight) {
        updateIconToTop(100);
      } else {
        updateIconToTop(parseInt(
          100 * scrollTop / (scrollHeight - clientHeight),
          10
        ));
      }
    });
  };
}

const backToTop = () => {
  let scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop,
    delay = 10,
    time = 200;
  if (scrollTop <= 20) {
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    return;
  }
  let step = Math.ceil(scrollTop * delay / time);
  let timer = setInterval(() => {
    scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop;
    if (scrollTop - step <= 0) {
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      clearInterval(timer);
    } else {
      document.documentElement.scrollTop = scrollTop - step;
      document.body.scrollTop = scrollTop - step;
    }
  }, delay);
}

document.addEventListener("scroll", handleScoll(), false);

document.querySelector(".back-to-top").addEventListener("click", backToTop, false);

</script>

    </div>

    
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  (() => {
    const mathjaxConfig = {
      showProcessingMessages: false, //关闭js加载过程信息
      messageStyle: "none", //不显示信息
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
        displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], //可选字体
        showMathMenu: false //关闭右击菜单显示
      }
    }

    let mathjaxInterval = setInterval(() => {
      if(!window.MathJax){
        return;
      }
      window.MathJax.Hub.Config(mathjaxConfig)
      window.MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('app')])

      clearInterval(mathjaxInterval)
    }, 10)    
  })()
</script>
    

    <script src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script>
<script async>
  let fancyTimer = setInterval(function(){
    if(!window.$){
      return;
    }
    $(document).ready(function() {
      $(".post img").each(function () {
        if($(this).parent().get(0).tagName.toLowerCase() === "a") {
          return;
        }
        // $(this).attr("data-fancybox", "gallery"); // if you add 'data-fancybox', img will display after showed
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "gallery");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      });
      
      clearInterval(fancyTimer);
    });
  }, 10);
</script>

    
  </body>

</html>
