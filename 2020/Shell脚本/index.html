<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta name="author" content="johnscott" />
  
  
  
  <title>Shell脚本 | JohnScott2046的博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="LINUX,命令," />
  

  <script>
    console.log('\n%c Hexo-theme-bmw v4.0 ' + '%c 🎉 https://github.com/dongyuanxin/theme-bmw 🎉\n' + '\n%c View demo online ' + '%c 🔍 https://godbmw.com/ 🔍  \n' , 'color: #fadfa3; background: #030307; padding:3px 0;', '', 'color: #fadfa3; background: #030307; padding:3px 0;', '');
  </script>

  
    <meta name="description" content="超级帽子戏法的个人博客,主要记录复制粘贴过来的笔记,还有自己的一些心得体会">
  

  

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/icon/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  
<script src="/js/util.js"></script>
<script src="/js/valine.min.js"></script>


  

  
    <link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js" async></script>
  

  
    <link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">
  
  
  <script src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js" async></script>
  
  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script>
  

<meta name="generator" content="Hexo 5.1.1"></head>

  <body>
    <meta name="baidu-site-verification" content="code-gxYIK5UWjA" />
    

    <div id="app">

      <div class="header-wrap">
  <header>
    <div class="site-brand">
      <div class="site-title">
        <a href="/">JohnScott2046</a>
      </div>
    </div>
    <nav class="site-navigation">
      <ul class="nav-menu">
      
        <li class="nav-item" data-path="/">
          
            <a 
              href="/"
              target="_self"
            >
              主页
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/archives/">
          
            <a 
              href="/archives/"
              target="_self"
            >
              归档
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/categories/">
          
            <a 
              href="/categories/"
              target="_self"
            >
              分类
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/tags/">
          
            <a 
              href="/tags/"
              target="_self"
            >
              标签
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/friends/">
          
            <a 
              href="/friends/"
              target="_self"
            >
              友链
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/about/">
          
            <a 
              href="/about/"
              target="_self"
            >
              关于
            </a>
          
        </li>
      
        <li class="nav-item" data-path="">
          
            <a href="javascript:void(0);" v-else>联系我</a>
            <ul class="nav-menu--dropdown">
              
                <li>
                  <a 
                    href="https://github.com/liuxue5213" 
                    target="_blank"
                  >
                    Github
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.zhihu.com/people/liuxue5213" 
                    target="_blank"
                  >
                    知乎
                  </a>
                </li>
              
                <li>
                  <a 
                    href="http://weibo.com/liuxue5213" 
                    target="_blank"
                  >
                    微博
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.douban.com/people/liuxue5213" 
                    target="_blank"
                  >
                    豆瓣
                  </a>
                </li>
              
                <li>
                  <a 
                    href="/linkedin.com/in/liuxue5213" 
                    target="_blank"
                  >
                    linkedin
                  </a>
                </li>
              
            </ul>
          
        </li>
      
      </ul>
    </nav>
    <i class="iconfont icon-menu"></i>
  </header>
</div>

<script>
  let links = document.querySelectorAll('.nav-item');
  for(let link of links){
    let childrenLink = link.querySelector('ul');
    link.addEventListener('mouseenter', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown active";
      }
    })
    link.addEventListener('mouseleave', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown";
      }
    })
  }
  let rootRealPath = getRealPath(window.location.pathname, true);
  for(let link of links) {
    let linkPath = link.getAttribute("data-path");
    if(linkPath && getRealPath(linkPath, true) === rootRealPath) {
      link.className = "nav-item hover";
    }
  }

  let iconMenu = document.querySelector("i.iconfont.icon-menu"),
    iconMenuClicked = false;
  let navDOM = document.querySelector("nav.site-navigation");
  iconMenu.addEventListener("click", () => {
    iconMenuClicked 
      ? navDOM.className = "site-navigation active"
      : navDOM.className = "site-navigation";
    iconMenuClicked = !iconMenuClicked;
  })
</script>

      








<div class="container post-index">

  

<div class="post">
  <h1 class="article-title">
    <span>Shell脚本</span>
  </h1>
  <div class="article-top-meta">
    <span>
      发布 : 
      2020-07-20
    </span>
    
      <span>
        分类 : 
          <a href="/categories/LINUX/">
            LINUX
          </a>
      </span>
    
    
      <span>
        浏览 : <span class="article-timer" data-identity="Shell脚本"></span>
      </span>
    
  </div>

  

  <div class="article-content">
    <div class="markdown-body">
      <h3 id="Shell是什么"><a href="#Shell是什么" class="headerlink" title="Shell是什么"></a>Shell是什么</h3><p>&emsp;&emsp;现在我们使用的操作系统（Windows、Mac OS、Android、iOS 等）都是带图形界面的，简单直观，容易上手，对专业用户（程序员、网管等）和普通用户（家庭主妇、老年人等）都非常适用。</p>
<p>&emsp;&emsp;计算机的普及离不开图形界面，然而在计算机的早期并没有图形界面，我们只能通过一个一个地命令来控制计算机，这些命令有成百上千之多，且不说记住这些命令非常困难，每天面对没有任何色彩的”黑屏”本身就是一件枯燥的事情；这个时候的计算机还远远谈不上炫酷和普及，只有专业人员才能使用。</p>
<p>&emsp;&emsp;对于图形界面，用户点击某个图标就能启动某个程序；对于命令行，用户输入某个程序的名字（可以看做一个命令）就能启动某个程序。这两者的基本过程都是类似的，都需要查找程序在硬盘上的安装位置，然后将它们加载到内存运行。</p>
<p>&emsp;&emsp;由于安全、复杂、繁琐等原因，用户不能直接接触内核，需要另外再开发一个程序，让用户直接使用这个程序；该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核，这样用户就能间接地使用操作系统内核了。通过在用户和内核之间增加一层”代理”，既能简化用户的操作，又能保障内核的安全。</p>
<p>&emsp;&emsp;用户界面和命令行就是这个另外开发的程序，就是这层”代理”。在 Linux 下，这个命令行程序叫做 <code>Shell</code>。Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质；Shell 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序。</p>
<h3 id="Shell-是如何连接用户和内核的"><a href="#Shell-是如何连接用户和内核的" class="headerlink" title="Shell 是如何连接用户和内核的"></a>Shell 是如何连接用户和内核的</h3><p>&emsp;&emsp;Shell 能够接收用户输入的命令，并对命令进行处理，处理完毕后再将结果反馈给用户，比如输出到显示器、写入到文件等；其实这些操作都得依赖内核，我们运行一个命令，大部分情况下 Shell 都会去调用内核暴露出来的接口，这就是在使用内核，只是这个过程被 Shell 隐藏了起来，它自己在背后默默进行，我们看不到而已。</p>
<p>&emsp;&emsp;接口其实就是一个一个的函数，使用内核就是调用这些函数。比如，我们都知道在 Shell 中输入 <code>cat log.txt</code> 命令就可以查看 <code>log.txt</code> 文件中的内容，然而，<code>log.txt</code> 放在磁盘的哪个位置？分成了几个数据块？在哪里开始？在哪里终止？如何操作探头读取它？这些底层细节 Shell 统统不知道的，它只能去调用内核提供的 <code>open()</code> 和 <code>read()</code> 函数，告诉内核我要读取 <code>log.txt</code> 文件，请帮助我，然后内核就乖乖地按照 Shell 的吩咐去读取文件了，并将读取到的文件内容交给 Shell，最后再由 Shell 呈现给用户（其实呈现到显示器上还得依赖内核）。整个过程中 Shell 就是一个”中间商”，它在用户和内核之间”倒卖”数据，只是用户不知道罢了。</p>
<h3 id="第一个脚本"><a href="#第一个脚本" class="headerlink" title="第一个脚本"></a>第一个脚本</h3><p>test.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;Hello World !&quot;</span><br></pre></td></tr></table></figure>

<p><code>#!</code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell；<br><code>/bin/bash</code>就是指明了解释器的具体位置<br><code>echo</code> 命令用于向标准输出文件</p>
<p>test2.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;What is your name?&quot;</span><br><span class="line">read PERSON</span><br><span class="line">echo &quot;Hello, $PERSON&quot;</span><br></pre></td></tr></table></figure>

<p><code>read</code> 从终端读取用户输入的数据，并赋值给 <code>PERSON</code> 变量</p>
<h3 id="执行Shell脚本"><a href="#执行Shell脚本" class="headerlink" title="执行Shell脚本"></a>执行Shell脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x .&#x2F;test.sh #给脚本添加执行权限</span><br><span class="line">.&#x2F;test.sh          #执行脚本文件</span><br></pre></td></tr></table></figure>

<p>这种方式运行脚本，不需要在脚本文件的第一行指定解释器信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash test.sh  #使用Bash的绝对路径</span><br></pre></td></tr></table></figure>

<p>Linux 中的每一个进程都有一个唯一的 <code>ID</code>，称为 <code>PID</code>，使用 <code>$$</code> 变量就可以获取当前进程的 <code>PID</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo $$</span><br></pre></td></tr></table></figure>

<h3 id="source-命令"><a href="#source-命令" class="headerlink" title="source 命令"></a>source 命令</h3><p><code>source</code> 是Shell内置命令的一种，它会读取脚本文件中的代码，并依次执行所有语句。<br><code>source</code> 命令会强制执行脚本文件中的全部命令，而忽略脚本文件的权限</p>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>变量名由数字、字母、下划线组成<br>必须以字母或者下划线开头<br>不能使用 Shell 里的关键字（通过 <code>help</code> 命令可以查看保留关键字）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable&#x3D;value</span><br><span class="line">variable&#x3D;&#39;value&#39;</span><br><span class="line">variable&#x3D;&quot;value&quot;</span><br></pre></td></tr></table></figure>
<p>注意，赋值号 <code>=</code> 的周围不能有空格</p>
<p>使用一个定义过的变量，只要在变量名前面加美元符号 <code>$</code> 即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo $variable</span><br><span class="line">echo $&#123;variable&#125;</span><br><span class="line"></span><br><span class="line">str&#x3D;&quot;home&quot;</span><br><span class="line">echo &quot;I am good at $&#123;str&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>如果不给 <code>str</code> 变量加花括号，解释器就会当成一个变量（其值为空）</p>
<h3 id="单引号和双引号的区别"><a href="#单引号和双引号的区别" class="headerlink" title="单引号和双引号的区别"></a>单引号和双引号的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;www.test.com&quot;</span><br><span class="line">website1&#x3D;&#39;首页：$&#123;url&#125;&#39;</span><br><span class="line">website2&#x3D;&quot;主页：$&#123;url&#125;&quot;</span><br><span class="line">echo $website1</span><br><span class="line">echo $website2</span><br></pre></td></tr></table></figure>

<p>首页：${url}<br>主页：<a target="_blank" rel="noopener" href="http://www.test.com/">http://www.test.com</a></p>
<p>以单引号 <code>&#39; &#39;</code> 包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出，这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。</p>
<p>以双引号 <code>&quot; &quot;</code> 包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出，这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</p>
<h3 id="readonly-只读变量"><a href="#readonly-只读变量" class="headerlink" title="readonly 只读变量"></a>readonly 只读变量</h3><p>使用 <code>readonly</code> 命令可以将变量定义为只读变量，只读变量的值不能被改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">name&#x3D;&quot;shell&quot;</span><br><span class="line">readonly name</span><br><span class="line">name&#x3D;&quot;111222333&quot;</span><br></pre></td></tr></table></figure>

<p>bash: myUrl: This variable is read only.</p>
<h3 id="unset-删除变量"><a href="#unset-删除变量" class="headerlink" title="unset 删除变量"></a>unset 删除变量</h3><p>使用 <code>unset</code> 命令可以删除变量，变量被删除后不能再次使用；<code>unset</code> 命令不能删除只读变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">name&#x3D;&quot;shell&quot;</span><br><span class="line">unset name</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure>
<p>脚本没有任何输出</p>
<h3 id="命令替换：将命令的输出结果赋值给变量"><a href="#命令替换：将命令的输出结果赋值给变量" class="headerlink" title="命令替换：将命令的输出结果赋值给变量"></a>命令替换：将命令的输出结果赋值给变量</h3><p>Shell 命令替换是指将命令的输出结果赋值给某个变量。比如，在某个目录中输入 <code>ls</code> 命令可查看当前目录中所有的文件，将输出内容存入某个变量中</p>
<p>Shell 中有两种方式可以完成命令替换，一种是反引号 <code> </code>，一种是 <code>$()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable&#x3D;&#96;commands&#96;</span><br><span class="line">variable&#x3D;$(commands)</span><br></pre></td></tr></table></figure>

<p><code>variable</code> 是变量名，<br><code>commands</code> 是要执行的命令，可以只有一个命令，也可以有多个命令，多个命令之间以分号 <code>;</code> 分隔</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">begin_time&#x3D;&#96;date&#96;    #开始时间，使用&#96;&#96;替换</span><br><span class="line">sleep 20s            #休眠20秒</span><br><span class="line">finish_time&#x3D;$(date)  #结束时间，使用$()替换</span><br><span class="line">echo &quot;Begin time: $begin_time&quot;</span><br><span class="line">echo &quot;Finish time: $finish_time&quot;</span><br></pre></td></tr></table></figure>

<p>注意，如果被替换的命令的输出内容包括多行（也即有换行符），或者含有多个连续的空白符，那么在输出变量时应该将变量用双引号包围，否则系统会使用默认的空白符来填充，这会导致换行无效，以及连续的空白符被压缩成一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">LSL&#x3D;&#96;ls -l&#96;</span><br><span class="line">echo $LSL  #不使用双引号包围</span><br><span class="line">echo &quot;--------------------------&quot;  #输出分隔符</span><br><span class="line">echo &quot;$LSL&quot;  #使用引号包围</span><br></pre></td></tr></table></figure>

<h3 id="位置参数（命令行参数）"><a href="#位置参数（命令行参数）" class="headerlink" title="位置参数（命令行参数）"></a>位置参数（命令行参数）</h3><p>运行 Shell 脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用 <code>$n</code> 的形式来接收 <code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数。</p>
<p>同样，在调用函数时也可以传递参数。Shell 函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目。换句话说，定义 Shell 函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用 <code>$n</code> 的形式接收，这种通过$n的形式来接收的参数，在 Shell 中称为位置参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;name: $1&quot;</span><br><span class="line">echo &quot;age: $2&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bash.sh scott 20</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">function func()&#123;</span><br><span class="line">    echo &quot;name: $1&quot;</span><br><span class="line">    echo &quot;age: $2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func scott 20</span><br></pre></td></tr></table></figure>

<p>如果参数个数太多，达到或者超过了10个，那么就得用 <code>$&#123;n&#125;</code> 的形式来接收了;<br><code>&#123; &#125;</code> 的作用是为了帮助解释器识别参数的边界，这跟使用变量时加 <code>&#123; &#125;</code> 是一样的效果<br>例如 <code>$&#123;10&#125;</code>、 <code>$&#123;23&#125;</code></p>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td>$n（n≥1）</td>
<td>传递给脚本或函数的参数，n 是一个数字，表示第几个参数</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有参数。当被双引号” “包含时，$@ 与 $* 稍有不同</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值</td>
</tr>
<tr>
<td>$$</td>
<td>当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;Process ID: $$&quot;</span><br><span class="line">echo &quot;File Name: $0&quot;</span><br><span class="line">echo &quot;First Parameter : $1&quot;</span><br><span class="line">echo &quot;Second Parameter : $2&quot;</span><br><span class="line">echo &quot;All parameters 1: $@&quot;</span><br><span class="line">echo &quot;All parameters 2: $*&quot;</span><br><span class="line">echo &quot;Total: $#&quot;</span><br></pre></td></tr></table></figure>

<p><code>$?</code> 是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值</p>
<p>所谓退出状态，就是上一个命令执行后的返回结果。退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1，这和C语言的 <code>main()</code> 函数是类似的</p>
<h3 id="获取上一个命令的退出状态"><a href="#获取上一个命令的退出状态" class="headerlink" title="获取上一个命令的退出状态"></a>获取上一个命令的退出状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">if [ &quot;$1&quot; &#x3D;&#x3D; 100 ]</span><br><span class="line">then</span><br><span class="line">   exit 0  #参数正确，退出状态为0</span><br><span class="line">else</span><br><span class="line">   exit 1  #参数错误，退出状态1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;test.sh 100    echo $? 0</span><br><span class="line">.&#x2F;test.sh 1000   echo $? 1</span><br></pre></td></tr></table></figure>

<p><code>exit</code>表示退出当前 Shell 进程，我们必须在新进程中运行 <code>test.sh</code>，否则当前 Shell 会话（终端窗口）关闭，我们就无法取得它的退出状态了</p>
<h3 id="获取函数的返回值"><a href="#获取函数的返回值" class="headerlink" title="获取函数的返回值"></a>获取函数的返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">function add()&#123;</span><br><span class="line">    return expr $1 + $2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add 10 20</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>

<p>严格来说，Shell 函数中的 <code>return</code> 关键字用来表示函数的退出状态，而不是函数的返回值；<br>Shell 不像其它编程语言，没有专门处理返回值的关键字</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串string就是一系列字符的组合，可以由单引号包围，也可以由双引号包围，也可以不用引号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1&#x3D;c.biancheng.net</span><br><span class="line">str2&#x3D;&quot;shell script&quot;</span><br><span class="line">str3&#x3D;&#39;111222aaabbbccc&#39;</span><br></pre></td></tr></table></figure>

<p>三种形式的区别</p>
<ol>
<li><p>由单引号包围的字符串<br>任何字符都会原样输出，在其中使用变量是无效的<br>字符串中不能出现单引号，即使对单引号进行转义也不行</p>
</li>
<li><p>由双引号包围的字符串<br>如果其中包含了某个变量，那么该变量会被解析（得到该变量的值），而不是原样输出<br>字符串中可以出现双引号，只要它被转义了就行</p>
</li>
<li><p>不被引号包围的字符串<br>不被引号包围的字符串中出现变量时也会被解析，这一点和双引号” “包围的字符串一样<br>字符串中不能出现空格，否则空格后边的字符串会作为其他变量或者命令解析</p>
</li>
</ol>
<p>在 Shell 中获取字符串长度很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#string_name&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">str&#x3D;&quot;hello world&quot;</span><br><span class="line">echo $&#123;#str&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>在脚本语言中，字符串的拼接（也称字符串连接或者字符串合并）往往都非常简单<br>然而，在 Shell 中你不需要使用任何运算符，将两个字符串并排放在一起就能实现拼接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1&#x3D;$name$age  #中间不能有空格</span><br><span class="line">str2&#x3D;&quot;$name $age&quot;  #如果被双引号包围，那么中间可以有空格</span><br><span class="line">str3&#x3D;$name&quot;: &quot;$age  #中间可以出现别的字符串</span><br><span class="line">str4&#x3D;&quot;$name: $age&quot;  #这样写也可以</span><br><span class="line">str5&#x3D;&quot;$&#123;name&#125;aaaaaa: $&#123;age&#125;bbbbbbb&quot;  #这个时候需要给变量名加上大括号</span><br></pre></td></tr></table></figure>

<h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>Shell 截取字符串通常有两种方式：从指定位置开始截取和从指定字符（子字符串）开始截取</p>
<h4 id="从指定位置开始截取"><a href="#从指定位置开始截取" class="headerlink" title="从指定位置开始截取"></a>从指定位置开始截取</h4><ol>
<li>从左边开始计数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;string: start :length&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>string</code> 是要截取的字符串，<code>start</code> 是起始位置（从左边开始，从 0 开始计数），<code>length</code> 是要截取的长度（省略的话表示直到字符串的末尾）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url&#x3D;&quot;www.test.com&quot;</span><br><span class="line">echo $&#123;url: 4: 4&#125;</span><br><span class="line"></span><br><span class="line">echo $&#123;url: 4&#125;  #省略 length，截取到字符串末尾</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从右边开始计数 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;string: 0-start :length&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>从左边开始计数时，起始数字是 0（这符合程序员思维）<br>从右边开始计数时，起始数字是 1（这符合常人思维）<br>计数方向不同，起始数字也不同;<br>不管从哪边开始计数，截取方向都是从左到右</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url&#x3D;&quot;www.test.com&quot;</span><br><span class="line">echo $&#123;url: 0-5: 7&#125;</span><br><span class="line"></span><br><span class="line">echo $&#123;url: 5&#125;  #省略 length，截取到字符串末尾</span><br></pre></td></tr></table></figure>

<h4 id="从指定字符（子字符串）开始截取"><a href="#从指定字符（子字符串）开始截取" class="headerlink" title="从指定字符（子字符串）开始截取"></a>从指定字符（子字符串）开始截取</h4><p>这种截取方式无法指定字符串长度，只能从指定字符（子字符串）截取到字符串末尾<br>Shell 可以截取指定字符（子字符串）右边的所有字符，也可以截取左边的所有字符</p>
<ol>
<li>使用 # 号截取右边字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;string#*chars&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>string</code> 表示要截取的字符，<code>chars</code> 是指定的字符（或者子字符串），<code>*</code> 是通配符的一种，表示任意长度的字符串</p>
<p><code>*chars</code> 连起来使用的意思是：忽略左边的所有字符，直到遇见 <code>chars</code>（chars 不会被截取）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;www.test.com&#x2F;index.html&quot;</span><br><span class="line">echo $&#123;url#*:&#125;</span><br><span class="line">echo $&#123;url#*p:&#125;</span><br><span class="line">echo $&#123;url#*ttp:&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;www.test.com&#x2F;index.html</span><br></pre></td></tr></table></figure>

<p>如果不需要忽略 chars 左边的字符，那么也可以不写*</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;www.test.com&#x2F;index.html&quot;</span><br><span class="line">echo $&#123;url#http:&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">www.test.com&#x2F;index.html</span><br></pre></td></tr></table></figure>

<p>默认都是遇到第一个匹配的字符（子字符串）就结束了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;string##*chars&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望直到最后一个指定字符（子字符串）再匹配结束，那么可以使用##</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;www.test.com&#x2F;index.html&quot;</span><br><span class="line">echo $&#123;url#*&#x2F;&#125;    #结果为 &#x2F;www.test.com&#x2F;index.html</span><br><span class="line">echo $&#123;url##*&#x2F;&#125;   #结果为 index.html</span><br><span class="line"></span><br><span class="line">str&#x3D;&quot;---aa+++aabbbbb&quot;</span><br><span class="line">echo $&#123;str#*aa&#125;        #结果为 +++aabbbbb</span><br><span class="line">echo $&#123;str##*aabbbbb&#125;  #结果为 bbbbb</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 % 截取左边字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;string%chars*&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>请注意 <code>*</code> 的位置，因为要截取 <code>chars</code> 左边的字符，而忽略 <code>chars</code> 右边的字符，所以 <code>*</code> 应该位于 <code>chars</code> 的右侧。其他方面 <code>%</code> 和 <code>#</code> 的用法相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url&#x3D;&quot;http:&#x2F;&#x2F;www.test.com&#x2F;index.html&quot;</span><br><span class="line">echo $&#123;url%&#x2F;*&#125;     #结果为 http:&#x2F;&#x2F;www.test.com</span><br><span class="line">echo $&#123;url%%&#x2F;*&#125;    #结果为 http:</span><br><span class="line"></span><br><span class="line">str&#x3D;&quot;---aa+++aabbbbb&quot;</span><br><span class="line">echo $&#123;str%aa*&#125;    #结果为 ---aa+++</span><br><span class="line">echo $&#123;str%%aa*&#125;   #结果为 ---</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>${string: start :length}</td>
<td>从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符</td>
</tr>
<tr>
<td>${string: start}</td>
<td>从 string 字符串的左边第 start 个字符开始截取，直到最后</td>
</tr>
<tr>
<td>${string: 0-start :length}</td>
<td>从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符</td>
</tr>
<tr>
<td>${string: 0-start}</td>
<td>从 string 字符串的右边第 start 个字符开始截取，直到最后</td>
</tr>
<tr>
<td>${string#*chars}</td>
<td>从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符</td>
</tr>
<tr>
<td>${string##*chars}</td>
<td>从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符</td>
</tr>
<tr>
<td>${string%*chars}</td>
<td>从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符</td>
</tr>
<tr>
<td>${string%%*chars}</td>
<td>从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符</td>
</tr>
</tbody></table>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是若干数据的集合，其中的每一份数据都称为元素</p>
<p>Shell 并且没有限制数组的大小，理论上可以存放无限量的数据，下标也是从 <code>0</code> 开始计数</p>
<p>获取数组中的元素要使用下标<code>[ ]</code>，下标可以是一个整数，也可以是一个结果为整数的表达式；必须大于等于 <code>0</code></p>
<p>常用的 <code>Bash Shell</code> 只支持一维数组，不支持多维数组</p>
<ol>
<li>定义 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name&#x3D;(ele1  ele2  ele3 ... elen)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>用括号<code>( )</code>来表示数组，数组元素之间用空格来分隔<br>Shell 是弱类型的，它并不要求所有数组元素的类型必须相同<br>Shell 数组的长度不是固定的，定义之后还可以增加元素<br>注意，赋值号 <code>=</code> 两边不能有空格，必须紧挨着数组名和数组元素</p>
<p>输出所有元素 使用 <code>@</code> 或 <code>*</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;nums[*]&#125; </span><br><span class="line">$&#123;nums[@]&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr&#x3D;(10 20 30 40 &#39;john&#39;)</span><br><span class="line"></span><br><span class="line">arr[5]&#x3D;50                 #指定元素</span><br><span class="line"></span><br><span class="line">arr&#x3D;([6]&#x3D;80 [7]&#x3D;&#39;scott&#39;)  #多个定义</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数组元素</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;array_name[index]&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>数组长度</li>
</ol>
<p>利用 <code>@</code> 或 <code>*</code>，可以将数组扩展成列表，然后使用 <code>#</code> 来获取数组元素的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#array_name[@]&#125;</span><br><span class="line">$&#123;#array_name[*]&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>拼接、合并</li>
</ol>
<p>数组拼接、合并，就是将两个数组连接成一个数组</p>
<p>拼接数组的思路是：先利用 <code>@</code> 或 <code>*</code>，将数组扩展成列表，然后再合并到一起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array_new&#x3D;($&#123;array1[@]&#125;  $&#123;array2[@]&#125;)</span><br><span class="line">array_new&#x3D;($&#123;array1[*]&#125;  $&#123;array2[*]&#125;)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>删除数组元素<br>使用 <code>unset</code> 关键字来删除数组元素，不写下标是删除整个数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset array_name[index]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="alias：给命令创建别名"><a href="#alias：给命令创建别名" class="headerlink" title="alias：给命令创建别名"></a>alias：给命令创建别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias new_name&#x3D;&#39;command&#39;</span><br></pre></td></tr></table></figure>

<p>在代码中使用 <code>alias</code> 命令定义的别名只能在当前 Shell 进程中使用，在子进程和其它进程中都不能使用，当前 Shell 进程结束后，别名也随之消失；要想让别名对所有的 Shell 进程都有效，就得把别名写入 Shell 配置文件。Shell 进程每次启动时都会执行配置文件中的代码做一些初始化工作，将别名放在配置文件中，那么每次启动进程都会定义这个别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">alias timestamp&#x3D;&#39;date +%s&#39;</span><br><span class="line">begin&#x3D; timestamp</span><br><span class="line">sleep 5s</span><br><span class="line">end&#x3D;$(timestamp)</span><br><span class="line">diff&#x3D;$((end - begin))</span><br><span class="line">echo &quot;run time: $&#123;diff&#125;s&quot;</span><br></pre></td></tr></table></figure>

<h3 id="unalias-命令删除别名"><a href="#unalias-命令删除别名" class="headerlink" title="unalias 命令删除别名"></a>unalias 命令删除别名</h3><p>第一种用法是在命令后跟上某个命令的别名，用于删除指定的别名<br>第二种用法是在命令后接-a参数，删除当前 Shell 进程中所有的别名<br>两种方法都是当前进程中生效的，永久删除，只能进入该文件手动操作</p>
<h3 id="echo-字符串输出"><a href="#echo-字符串输出" class="headerlink" title="echo 字符串输出"></a>echo 字符串输出</h3><p><code>echo</code> 命令输出结束后默认会换行，如果不希望换行，可以加上 <code>-n</code> 参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name&#x3D;john</span><br><span class="line">act&#x3D;&#39;hello world&#39;</span><br><span class="line"></span><br><span class="line">echo -n $name</span><br><span class="line">echo $act</span><br></pre></td></tr></table></figure>

<h3 id="输出转义字符"><a href="#输出转义字符" class="headerlink" title="输出转义字符"></a>输出转义字符</h3><p>默认情况下，<code>echo</code> 不会解析以反斜杠 <code>\</code> 开头的转义字符，使用 <code>-e</code> 参数来解析转义字符<br>比如，<code>\n</code> 表示换行，<code>echo</code> 默认会将它作为普通字符对待</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello \nworld&quot;</span><br><span class="line"></span><br><span class="line">echo -e &quot;hello \nworld&quot;</span><br></pre></td></tr></table></figure>

<h3 id="read-读取键盘输入"><a href="#read-读取键盘输入" class="headerlink" title="read 读取键盘输入"></a>read 读取键盘输入</h3><p><code>read</code> 是 Shell 内置命令，用来从标准输入中读取数据并赋值给变量；<br>如果没有进行重定向，默认就是从键盘读取用户输入的数据；<br>如果进行了重定向，那么可以从文件中读取数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read [-options] [variables]</span><br></pre></td></tr></table></figure>

<p><code>options</code> 表示选项，如下表所示；<br><code>variables</code> 表示用来存储数据的变量，可以有一个，也可以有多个;<br><code>options</code> 和 <code>variables</code> 都是可选的，如果没有提供变量名，那么读取的数据将存放到环境变量 <code>REPLY</code> 中;</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-a array</td>
<td>把读取的数据赋值给数组 array，从下标 0 开始</td>
</tr>
<tr>
<td>-d delimiter</td>
<td>用字符串 delimiter 指定读取结束的位置，而不是一个换行符（读取到的数据不包括 delimiter）</td>
</tr>
<tr>
<td>-e</td>
<td>在获取用户输入的时候，对功能键进行编码转换，不会直接显式功能键对应的字符</td>
</tr>
<tr>
<td>-n num</td>
<td>读取 num 个字符，而不是整行字符</td>
</tr>
<tr>
<td>-p prompt</td>
<td>显示提示信息，提示内容为 prompt</td>
</tr>
<tr>
<td>-r</td>
<td>原样读取（Raw mode），不把反斜杠字符解释为转义字符</td>
</tr>
<tr>
<td>-s</td>
<td>静默模式（Silent mode），不会在屏幕上显示输入的字符；当输入密码和其它确认信息的时候，这是很有必要的</td>
</tr>
<tr>
<td>-t seconds</td>
<td>设置超时时间，单位为秒。如果用户没有在指定时间内输入完成，那么 read 将会返回一个非 0 的退出状态，表示读取失败</td>
</tr>
<tr>
<td>-u fd</td>
<td>使用文件描述符 fd 作为输入源，而不是标准输入，类似于重定向</td>
</tr>
</tbody></table>
<ol>
<li>使用 read 命令给多个变量赋值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;输入名字 年龄 &gt; &quot;  name age</span><br><span class="line">echo $name</span><br><span class="line">echo $age</span><br></pre></td></tr></table></figure>

<p><code>-p</code> 选项，该选项会用一段文本来提示用户输入</p>
<p>注意，必须在一行内输入所有的值，不能换行，否则只能给第一个变量赋值，后续变量都会赋值失败</p>
<ol start="2">
<li>只读取一个字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read -n 1 -p &quot;enter a char  &gt; &quot; char</span><br><span class="line">printf &quot;\n&quot; </span><br><span class="line">echo $char</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>printf &quot;\n&quot;</code> 换行，否则 <code>echo</code> 的输出结果会和用户输入的内容位于同一行，不容易区分</p>
<p><code>-n 1</code> 表示只读取一个字符，当用户输入一个字符后，会立即读取结束，不用等待用户按下回车键</p>
<ol start="3">
<li>在指定时间内输入密码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if</span><br><span class="line">    read -t 20 -sp &quot;first 20s inout &gt; &quot; pass1 &amp;&amp; printf &quot;\n&quot; &amp;&amp; #first input </span><br><span class="line">    read -t 20 -sp &quot;second 20s inout &gt; &quot; pass2 &amp;&amp; printf &quot;\n&quot; &amp;&amp; #second input</span><br><span class="line">    [ $pass1 &#x3D;&#x3D; $pass2 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;equal&quot;</span><br><span class="line">else </span><br><span class="line">    echo &quot;not equal&quot;</span><br><span class="line">fi        </span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>使用 <code>&amp;&amp;</code> 组合了多个命令，这些命令会依次执行，并且从整体上作为 <code>if</code> 语句的判断条件，只要其中一个命令执行失败（退出状态为非 0 值），整个判断条件就失败了，后续的命令也就不会执行了</p>
<h3 id="exit-退出当前进程"><a href="#exit-退出当前进程" class="headerlink" title="exit 退出当前进程"></a>exit 退出当前进程</h3><p><code>exit</code> 是一个 Shell 内置命令，用来退出当前 Shell 进程，并返回一个退出状态；使用$?可以接收这个退出状态</p>
<p><code>exit</code> 命令可以接受一个整数值作为参数，代表退出状态；如果不指定，默认状态值是 <code>0</code></p>
<p>一般情况下，退出状态为 <code>0</code> 表示成功，退出状态为 <code>非0</code> 表示执行失败（出错）了</p>
<p><code>exit</code> 退出状态只能是一个介于 <code>0-255</code> 之间的整数，其中只有 <code>0</code> 表示成功，其它值都表示失败，可以根据退出状态来判断具体出现了什么错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;befor exit&quot;</span><br><span class="line">exit 8</span><br><span class="line">echo &quot;after exit&quot;</span><br></pre></td></tr></table></figure>

<p><code>exit</code>之后 不会被执行，使用<code>echo $?</code>获取退出状态 </p>
<h3 id="declare-typeset-设置变量属性"><a href="#declare-typeset-设置变量属性" class="headerlink" title="declare typeset 设置变量属性"></a>declare typeset 设置变量属性</h3><p><code>declare</code> 和 <code>typeset</code> 都是 Shell 内建命令，它们的用法相同，都用来设置变量的属性，不过 <code>typeset</code> 已经被弃用了，建议使用 <code>declare</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare [+&#x2F;-] [aAfFgilprtux] [变量名&#x3D;变量值]</span><br></pre></td></tr></table></figure>

<p><code>-</code>表示设置属性，<code>+</code>表示取消属性，<code>aAfFgilprtux</code>都是具体的选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-f [name]</td>
<td>列出之前由用户在脚本中定义的函数名称和函数体</td>
</tr>
<tr>
<td>-F [name]</td>
<td>仅列出自定义函数名称</td>
</tr>
<tr>
<td>-g name</td>
<td>在 Shell 函数内部创建全局变量</td>
</tr>
<tr>
<td>-p [name]</td>
<td>显示指定变量的属性和值</td>
</tr>
<tr>
<td>-a name</td>
<td>声明变量为普通数组</td>
</tr>
<tr>
<td>-A name</td>
<td>声明变量为关联数组（支持索引下标为字符串）</td>
</tr>
<tr>
<td>-i name</td>
<td>将变量定义为整数型</td>
</tr>
<tr>
<td>-r name[=value]</td>
<td>将变量定义为只读（不可修改和删除），等价于 readonly name</td>
</tr>
<tr>
<td>-x name[=value]</td>
<td>将变量设置为环境变量，等价于 export name[=value]</td>
</tr>
</tbody></table>
<ol>
<li>将变量声明为整数并进行计算</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declare -i a b   #将多个变量声明为整数</span><br><span class="line">a&#x3D;10</span><br><span class="line">b&#x3D;20</span><br><span class="line">c&#x3D;$a+$b</span><br><span class="line">echo $c</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将变量定义为只读变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare -r name &#x3D; john</span><br><span class="line"></span><br><span class="line">declare -p name #显示变量的属性和值</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h3><table>
<thead>
<tr>
<th>算术运算符</th>
<th>说明/含义</th>
</tr>
</thead>
<tbody><tr>
<td>+、-</td>
<td>加法（或正号）、减法（或负号）</td>
</tr>
<tr>
<td>*、/、%</td>
<td>乘法、除法、取余（取模）</td>
</tr>
<tr>
<td>**</td>
<td>幂运算</td>
</tr>
<tr>
<td>++、–</td>
<td>自增和自减，可以放在变量的前面也可以放在变量的后面</td>
</tr>
<tr>
<td>!、&amp;&amp;、&#124;&#124;</td>
<td>逻辑非（取反）、逻辑与（and）、逻辑或（or）</td>
</tr>
<tr>
<td>&lt;、&lt;=、&gt;、&gt;=</td>
<td>比较符号（小于、小于等于、大于、大于等于）</td>
</tr>
<tr>
<td>==、!=、=</td>
<td>比较符号（相等、不相等；对于字符串，= 也可以表示相当于）</td>
</tr>
<tr>
<td>&lt;&lt;、&gt;&gt;</td>
<td>向左移位、向右移位</td>
</tr>
<tr>
<td>~、&#124;、 &amp;、^</td>
<td>按位取反、按位或、按位与、按位异或</td>
</tr>
<tr>
<td>=、+=、-=、*=、/=、%=</td>
<td>赋值运算符</td>
</tr>
</tbody></table>
<p>默认情况下，Shell不会直接进行算术运算，必须使用数学计算命令，把+两边的数据（数值或者变量）当做字符串；</p>
<p>这是因为，在 Bash Shell 中，如果不特别指明，每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储</p>
<p>换句话说，Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串，这一点和大部分的编程语言不同</p>
<h3 id="数学计算命令"><a href="#数学计算命令" class="headerlink" title="数学计算命令"></a>数学计算命令</h3><p>要想让数学计算发挥作用，必须使用数学计算命令</p>
<table>
<thead>
<tr>
<th>运算操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>(( ))</td>
<td>用于整数运算，推荐使用</td>
</tr>
<tr>
<td>let</td>
<td>用于整数运算，和 (()) 类似</td>
</tr>
<tr>
<td>$[]</td>
<td>用于整数运算，不如 (()) 灵活</td>
</tr>
<tr>
<td>expr</td>
<td>可用于整数运算，也可以处理字符串。需要注意各种细节，不推荐使用</td>
</tr>
<tr>
<td>bc</td>
<td>Linux下的一个计算器程序，可以处理整数和小数。Shell 本身只支持整数运算，想计算小数就得使用 bc 这个外部的计算器</td>
</tr>
<tr>
<td>declare -i</td>
<td>将变量定义为整数，然后再进行数学运算时就不会被当做字符串了。功能有限，仅支持最基本的数学运算（加减乘除和取余），不支持逻辑运算、自增自减等，所以在实际开发中很少使用</td>
</tr>
</tbody></table>
<h3 id="对整数进行数学运算"><a href="#对整数进行数学运算" class="headerlink" title="(()) 对整数进行数学运算"></a>(()) 对整数进行数学运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((表达式))</span><br></pre></td></tr></table></figure>

<p>表达式可以只有一个，也可以有多个，多个表达式之间以逗号,分隔。对于多个表达式的情况，以最后一个表达式的值作为整个 <code>(( ))</code> 命令的执行结果</p>
<p><code>(( ))</code> 只能进行整数运算，不能对小数（浮点数）或者字符串进行运算</p>
<p>可以使用 <code>$</code> 获取 <code>(( ))</code> 命令的结果，这和使用 <code>$</code> 获得变量值是类似的</p>
<table>
<thead>
<tr>
<th>运算操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>((a=10+66) ((c=a+b))</td>
<td>这种写法可以在计算完成后给变量赋值</td>
</tr>
<tr>
<td>a=$((10+66) c=$((a+b))</td>
<td>可以在 (( )) 前面加上$符号获取 (( )) 命令的执行结果，也即获取整个表达式的值</td>
</tr>
<tr>
<td>((a&gt;7 &amp;&amp; b==c))</td>
<td>(( )) 也可以进行逻辑运算</td>
</tr>
<tr>
<td>echo $((a+10))</td>
<td>需要立即输出表达式的运算结果时，可以在 (( )) 前面加$符号</td>
</tr>
<tr>
<td>((a=3+5, b=a+10))</td>
<td>对多个表达式同时进行计算</td>
</tr>
</tbody></table>
<p>注意，使用变量时不用加$前缀，<code>(( ))</code> 会自动解析变量名<br>在 <code>(( ))</code> 中使用变量无需加上$前缀，<code>(( ))</code> 会自动解析变量名<br>类似 <code>c=((a+b))</code> 这样的写法是错误的，不加 <code>$</code> 就不能取得表达式的结果</p>
<h3 id="let-对整数进行数学运算"><a href="#let-对整数进行数学运算" class="headerlink" title="let 对整数进行数学运算"></a>let 对整数进行数学运算</h3><p>let 命令和 <code>(( ))</code> 的用法是类似的，它们都是用来对整数进行运算</p>
<p>注意：和 <code>(( ))</code> 一样，<code>let</code> 命令也只能进行整数运算，不能对小数（浮点数）或者字符串进行运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let 表达式</span><br><span class="line">let &quot;表达式&quot;</span><br><span class="line">let &#39;表达式&#39;</span><br></pre></td></tr></table></figure>

<p>当表达式中含有 Shell 特殊字符（例如 <code>|</code>）时，需要用双引号 <code>&quot; &quot;</code> 或者单引号 <code>&#39; &#39;</code> 将表达式包围起来</p>
<p>和 <code>(( ))</code> 类似，<code>let</code> 命令也支持一次性计算多个表达式，并且以最后一个表达式的值作为整个 <code>let</code> 命令的执行结果</p>
<p>但是，对于多个表达式之间的分隔符，<code>let</code> 和 <code>(( ))</code> 是有区别的：<br><code>let</code> 命令以空格来分隔多个表达式；<br><code>(( ))</code> 以逗号,来分隔多个表达式。</p>
<p>另外还要注意，对于类似 <code>let x+y</code> 这样的写法，Shell 虽然计算了 <code>x+y</code> 的值，但却将结果丢弃；<br>若不想这样，可以使用 <code>let sum=x+y</code> 将 <code>x+y</code> 的结果保存在变量 <code>sum</code> 中</p>
<h3 id="if-else-控制语句"><a href="#if-else-控制语句" class="headerlink" title="if else 控制语句"></a>if else 控制语句</h3><p>Shell 也支持选择结构，并且有两种形式，分别是 <code>if else</code> 语句和 <code>case in</code> 语句</p>
<ol>
<li>if</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if  condition</span><br><span class="line">then</span><br><span class="line">    statement(s)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><code>condition</code> 是判断条件，如果 <code>condition</code> 成立（返回“真”），那么 <code>then</code> 后边的语句将会被执行；如果 <code>condition</code> 不成立（返回“假”），那么不会执行任何语句</p>
<p>注意，最后必须以 <code>fi</code> 来闭合，<code>fi</code> 就是 <code>if</code> 倒过来拼写。<br>也正是有了 <code>fi</code> 来结尾，所以即使有多条语句也不需要用 <code>&#123; &#125;</code> 包围起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if  condition;  then</span><br><span class="line">    statement(s)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>可以将 <code>then</code> 和 <code>if</code> 写在一行;<br>请注意 <code>condition</code> 后边的分号;<br>当 <code>if</code> 和 <code>then</code> 位于同一行的时候，这个分号是必须的，否则会有语法错误</p>
<ol start="2">
<li>if elif else</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if  condition1</span><br><span class="line">then</span><br><span class="line">    statement1</span><br><span class="line">elif condition2</span><br><span class="line">    statement2</span><br><span class="line">else</span><br><span class="line">    statementn</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;10</span><br><span class="line">b&#x3D;20</span><br><span class="line"></span><br><span class="line">if ((a&gt;b))</span><br><span class="line">then</span><br><span class="line">    echo 111</span><br><span class="line">else</span><br><span class="line">    echo 222</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>注意，<code>if</code> 和 <code>elif</code> 后边都得跟着 <code>then</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">printf &#39;input number: &#39;</span><br><span class="line">read num</span><br><span class="line"></span><br><span class="line">if ((num&#x3D;&#x3D;1))</span><br><span class="line">then    </span><br><span class="line">    echo 1</span><br><span class="line">elif ((num&#x3D;&#x3D;2))</span><br><span class="line">then    </span><br><span class="line">    echo 2</span><br><span class="line">else</span><br><span class="line">    echo other</span><br><span class="line">fi    </span><br></pre></td></tr></table></figure>

<p>在判断条件中也可以使用逻辑运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printf &#39;input number: &#39;</span><br><span class="line">read num</span><br><span class="line"></span><br><span class="line">if ((num&#x3D;&#x3D;1 || num&#x3D;&#x3D;5))</span><br><span class="line">then </span><br><span class="line">    echo 1 or 5</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="exit-退出状态"><a href="#exit-退出状态" class="headerlink" title="exit 退出状态"></a>exit 退出状态</h3><p>每一条 Shell 命令，不管是 <code>Bash</code> 内置命令（例如 cd、echo），还是外部的 Linux 命令（例如 ls、awk），还是自定义的 Shell 函数，当它退出（运行结束）时，都会返回一个比较小的整数值给调用（使用）它的程序，这就是命令的退出状态（exit statu）</p>
<p>很多 Linux 命令其实就是一个C语言程序，熟悉C语言的读者都知道，<code>main()</code> 函数的最后都有一个 <code>return 0</code>，如果程序想在中间退出，还可以使用 <code>exit 0</code>，这其实就是C语言程序的退出状态。当有其它程序调用这个程序时，就可以捕获这个退出状态</p>
<p><code>if</code> 语句的判断条件，从本质上讲，判断的就是命令的退出状态<br>按照惯例来说，退出状态为 <code>0</code> 表示”成功”，程序执行完成并且没有遇到任何问题；<br>除 <code>0</code> 以外的其它任何退出状态都为”失败”</p>
<p>之所以说这是”惯例”而非”规定”，是因为也会有例外，比如 <code>diff</code> 命令用来比较两个文件的不同，对于”没有差别”的文件返回 0，对于”找到差别”的文件返回 1，对无效文件名返回 2</p>
<p>注意： Shell 的这个部分与你所熟悉的其它编程语言正好相反：在C语言、C++、Java、Python 中，0 表示”假”，其它值表示”真”</p>
<h3 id="test-对文件或者字符串检测"><a href="#test-对文件或者字符串检测" class="headerlink" title="test 对文件或者字符串检测"></a>test 对文件或者字符串检测</h3><p><code>test</code> 是 Shell 内置命令，可以对文件或者字符串进行检测，<br><code>test</code> 命令有很多选项，可以进行数值、字符串和文件三个方面的检测<br>当 <code>test</code> 判断 <code>expression</code> 成立时，退出状态为 <code>0</code>，否则为 <code>非0</code> 值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test expression</span><br><span class="line">[ expression ]</span><br></pre></td></tr></table></figure>

<p>注意 <code>[]</code> 和 <code>expression</code>之间的空格，这两个空格是必须的，否则会导致语法错误</p>
<p><code>[]</code> 的写法更加简洁，比 <code>test</code> 使用频率高</p>
<p>将用户输入的 <code>URL</code> 写入到文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">read fname</span><br><span class="line">read cont</span><br><span class="line"></span><br><span class="line">if test -w $fname &amp;&amp; test -n $cont</span><br><span class="line">then</span><br><span class="line">    echo $fname &gt; $cont</span><br><span class="line">    echo success</span><br><span class="line">else</span><br><span class="line">    echo false</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>其中，<code>-w</code> 选项用来检测文件是否存在并且可写，<code>-n</code> 选项用来检测字符串是否非空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">read age</span><br><span class="line"></span><br><span class="line">if test $age -le 17</span><br><span class="line">then </span><br><span class="line">    echo &#39;少年&#39;;</span><br><span class="line">elif [ $age -ge 18 ] &amp;&amp; test $age -le 40;</span><br><span class="line">then </span><br><span class="line">    echo &#39;青年&#39;;</span><br><span class="line">elif [ $age -ge 41 ] &amp;&amp; [ test $age -le 65 ];</span><br><span class="line">then </span><br><span class="line">    echo &#39;中年&#39;;</span><br><span class="line">else</span><br><span class="line">    echo &#39;老年&#39;;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<ol>
<li>与文件检测相关的 test 选项</li>
</ol>
<p>文件类型判断</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-b filename</td>
<td>判断文件是否存在，并且是否为块设备文件</td>
</tr>
<tr>
<td>-c filename</td>
<td>判断文件是否存在，并且是否为字符设备文件</td>
</tr>
<tr>
<td>-d filename</td>
<td>判断文件是否存在，并且是否为目录文件</td>
</tr>
<tr>
<td>-e filename</td>
<td>判断文件是否存在</td>
</tr>
<tr>
<td>-f filename</td>
<td>判断文件是否存在，井且是否为普通文件</td>
</tr>
<tr>
<td>-L filename</td>
<td>判断文件是否存在，并且是否为符号链接文件</td>
</tr>
<tr>
<td>-p filename</td>
<td>判断文件是否存在，并且是否为管道文件</td>
</tr>
<tr>
<td>-s filename</td>
<td>判断文件是否存在，并且是否为非空</td>
</tr>
<tr>
<td>-S filename</td>
<td>判断该文件是否存在，并且是否为套接字文件</td>
</tr>
</tbody></table>
<p>文件权限判断</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-r filename</td>
<td>判断文件是否存在，并且是否拥有读权限</td>
</tr>
<tr>
<td>-w filename</td>
<td>判断文件是否存在，并且是否拥有写权限</td>
</tr>
<tr>
<td>-x filename</td>
<td>判断文件是否存在，并且是否拥有执行权限</td>
</tr>
<tr>
<td>-u filename</td>
<td>判断文件是否存在，并且是否拥有 SUID 权限</td>
</tr>
<tr>
<td>-g filename</td>
<td>判断文件是否存在，并且是否拥有 SGID 权限</td>
</tr>
<tr>
<td>-k filename</td>
<td>判断该文件是否存在，并且是否拥有 SBIT 权限</td>
</tr>
</tbody></table>
<p>文件比较</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>filename1 -nt filename2</td>
<td>判断 filename1 的修改时间是否比 filename2 的新</td>
</tr>
<tr>
<td>filename -ot filename2</td>
<td>判断 filename1 的修改时间是否比 filename2 的旧</td>
</tr>
<tr>
<td>filename1 -ef filename2</td>
<td>判断 filename1 是否和 filename2 的 inode 号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</td>
</tr>
</tbody></table>
<ol start="2">
<li>与数值比较相关的 test 选​项</li>
</ol>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>num1 -eq num2</td>
<td>相等</td>
</tr>
<tr>
<td>num1 -ne num2</td>
<td>不相等</td>
</tr>
<tr>
<td>num1 -gt num2</td>
<td>大于</td>
</tr>
<tr>
<td>num1 -lt num2</td>
<td>小于</td>
</tr>
<tr>
<td>num1 -ge num2</td>
<td>大于等于</td>
</tr>
<tr>
<td>num1 -le num2</td>
<td>小于等于</td>
</tr>
</tbody></table>
<p>注意，<code>test</code> 只能用来比较整数，小数相关的比较还得依赖 <code>bc</code> 命令</p>
<ol start="3">
<li>与字符串判断相关的 test 选项</li>
</ol>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-z str</td>
<td>判断字符串 str 是否为空</td>
</tr>
<tr>
<td>-n str</td>
<td>判断宇符串 str 是否为非空</td>
</tr>
<tr>
<td>str1 = str2; str1 == str2</td>
<td>=和==是等价的，都用来判断 str1 是否和 str2 相等</td>
</tr>
<tr>
<td>str1 != str2</td>
<td>是否不相等</td>
</tr>
<tr>
<td>str1 &gt; str2</td>
<td>str1 是否大于 str2</td>
</tr>
<tr>
<td>str1 &lt; str2</td>
<td>str1 是否小于 str2</td>
</tr>
</tbody></table>
<p><code>\&gt;</code> 是 <code>&gt;</code> 的转义字符，这样写是为了防止 <code>&gt;</code> 被误认为成重定向运算符</p>
<p><code>==</code> <code>&gt;</code> <code>&lt;</code> 在大部分编程语言中都用来比较数字，而在 Shell 中，它们只能用来比较字符串，不能比较数字;</p>
<p>其次，不管是比较数字还是字符串，Shell 都不支持 <code>&gt;=</code> 和 <code>&lt;=</code> 运算符</p>
<p>检测字符串是否为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ -z &quot;$str1&quot; ] || [ -z &quot;$str2&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;字符串不能为空&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>比较字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ $str1 &#x3D; $str2 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;两个字符串相等&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;两个字符串不相等&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>与逻辑运算相关的 test 选项</li>
</ol>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>expression1 -a expression</td>
<td>逻辑与，表达式 expression1 和 expression2 都成立，最终的结果才是成立的</td>
</tr>
<tr>
<td>expression1 -o expression2</td>
<td>逻辑或，表达式 expression1 和 expression2 有一个成立，最终的结果就成立</td>
</tr>
<tr>
<td>!expression</td>
<td>逻辑非，对 expression 进行取反</td>
</tr>
</tbody></table>
<p>检测字符串是否为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ -z &quot;$str1&quot; -o -z &quot;$str2&quot; ]  #使用 -o 选项取代之前的 ||</span><br><span class="line">then</span><br><span class="line">    echo &quot;字符串不能为空&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>比较字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ $str1 &#x3D; $str2 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;两个字符串相等&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;两个字符串不相等&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>


<p>在 <code>test</code> 中使用变量建议用双引号包围起来</p>
<p><code>test</code> 和 <code>[]</code> 都是命令，一个命令本质上对应一个程序或者一个函数。即使是一个程序，它也有入口函数，例如C语言程序的入口函数是 <code>main()</code>，运行C语言程序就从 <code>main()</code> 函数开始，所以也可以将一个程序等效为一个函数，这样我们就不用再区分函数和程序了，直接将一个命令和一个函数对应起来即可</p>
<p>有了以上认知，就很容易看透命令的本质了：使用一个命令其实就是调用一个函数，命令后面附带的选项和参数最终都会作为实参传递给函数</p>
<p>假设 <code>test</code> 命令对应的函数是 <code>func()</code>，使用 <code>test -z $str1</code> 命令时，会先将变量 <code>$str1</code> 替换成字符串：<br>如果 <code>$str1</code> 是一个正常的字符串，比如 <code>abc123</code>，那么替换后的效果就是 <code>test -z abc123</code>，调用 func() 函数的形式就是 <code>func(&quot;-z abc123&quot;)</code>。<code>test</code> 命令后面附带的所有选项和参数会被看成一个整体，并作为实参传递进函数。<br>如果 $str1 是一个空字符串，那么替换后的效果就是 <code>test -z</code>，调用 <code>func()</code> 函数的形式就是 <code>func(&quot;-z &quot;)</code>，这就比较奇怪了，因为 <code>-z</code> 选项没有和参数成对出现，<code>func()</code> 在分析时就会出错。</p>
<p>如果我们给 <code>$str1</code> 变量加上双引号，当 <code>$str1</code> 是空字符串时，<code>test -z &quot;$str1&quot;</code> 就会被替换为 <code>test -z &quot;&quot;</code>，调用 <code>func()</code> 函数的形式就是 <code>func(&quot;-z \&quot;\&quot;&quot;)</code>，很显然，<code>-z</code> 选项后面跟的是一个空字符串（&quot;表示转义字符），这样 <code>func()</code> 在分析时就不会出错了。</p>
<p>所以，当你在 test 命令中使用变量时，我强烈建议将变量用双引号 <code>&quot;&quot;</code> 包围起来，这样能避免变量为空值时导致的很多奇葩问题</p>
<p>总结</p>
<p><code>&gt;</code>、<code>&lt;</code>、<code>==</code> 只能用来比较字符串，不能用来比较数字，比较数字需要使用 <code>-eq</code>、<code>-gt</code> 等选项；<br>不管是比较字符串还是数字，<code>test</code> 都不支持 <code>&gt;=</code> 和 <code>&lt;=</code>;<br>对于整型数字的比较，我建议大家使用 <code>(())</code>，支持各种运算符，写法也符合数学规则，用起来更加方便;</p>
<h3 id="检测某个条件是否成立"><a href="#检测某个条件是否成立" class="headerlink" title="[[]] 检测某个条件是否成立"></a>[[]] 检测某个条件是否成立</h3><p><code>[[ ]]</code> 是 Shell 内置关键字，它和 test 命令类似，也用来检测某个条件是否成立，可以认为是 test 的升级版，对细节进行了优化，并且扩展了一些功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure>
<p>当 <code>[[ ]]</code> 判断 <code>expression</code> 成立时，退出状态为 <code>0</code>，否则为 <code>非0</code> 值</p>
<p>注意 <code>[[ ]]</code> 和 <code>expression</code> 之间的空格，这两个空格是必须的，否则会导致语法错误</p>
<p>不需要把变量名用双引号 <code>&quot;&quot;</code> 包围起来，即使变量是空值，也不会出错<br>不需要、也不能对 <code>&gt;</code>、 <code>&lt;</code> 进行转义，转义后会出错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [[ -z $str1 ]] || [[ -z $str2 ]]  #不需要对变量名加双引号</span><br><span class="line">then</span><br><span class="line">    echo &quot;字符串不能为空&quot;</span><br><span class="line">elif [[ $str1 &lt; $str2 ]]  #不需要也不能对 &lt; 进行转义</span><br><span class="line">then</span><br><span class="line">    echo &quot;str1 &lt; str2&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;str1 &gt;&#x3D; str2&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>支持逻辑运算符</p>
<p>对多个表达式进行逻辑运算时，可以使用逻辑运算符将多个 <code>test</code> 命令连接起来;<br>也可以借助选项把多个表达式写在一个 <code>test</code> 命令中;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ -z &quot;$str1&quot; ] || [ -z &quot;$str2&quot; ]</span><br><span class="line">[ -z &quot;$str1&quot; -o -z &quot;$str2&quot; ]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ -z &quot;$str1&quot; ] || [ -z &quot;$str2&quot; ]     √</span><br><span class="line">[ -z &quot;$str1&quot; -o -z &quot;$str2&quot; ]         √</span><br><span class="line">[ -z $str1 || -z $str2 ]             ×</span><br><span class="line"></span><br><span class="line">[[ -z $str1 ]] || [[ -z $str2 ]]     √  </span><br><span class="line">[[ -z $str1 -o -z $str2 ]]           ×</span><br><span class="line">[[ -z $str1 || -z $str2 ]]           √</span><br></pre></td></tr></table></figure>

<p>支持正则表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ str &#x3D;~ regex ]]</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>=~</code> 来检测字符串是否符合某个正则表达式，str 表示字符串，regex 表示正则表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read tel</span><br><span class="line"></span><br><span class="line">if [[ $tel &#x3D;~ ^1[0-9]&#123;10&#125;$ ]]</span><br><span class="line">then</span><br><span class="line">    echo &#39;phone number&#39;</span><br><span class="line">else</span><br><span class="line">    echo &#39;not phone number&#39;</span><br></pre></td></tr></table></figure>

<p>总结，<code>[[ ]]</code> 对数字的比较仍然不友好，建议使用 <code>if</code> 判断条件时，用 <code>(())</code> 来处理整型数字，用 <code>[[ ]]</code> 来处理字符串或者文件</p>
<h3 id="case-in-分支结构"><a href="#case-in-分支结构" class="headerlink" title="case in 分支结构"></a>case in 分支结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case expression in</span><br><span class="line">    pattern1)</span><br><span class="line">        statement1</span><br><span class="line">        ;;</span><br><span class="line">    ……</span><br><span class="line">    *)</span><br><span class="line">        statementn</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p><code>expression</code> 既可以是一个变量、一个数字、一个字符串，还可以是一个数学计算表达式，或者是命令的执行结果<br>pattern 可以是一个数字、一个字符串，甚至是一个简单的正则表达式<br>这里的 <code>;;</code> 和 <code>*)</code> 就相当于其它编程语言中的 <code>break</code> 和 <code>default</code><br>没有 <code>*)</code> 部分，如果 <code>expression</code> 没有匹配到任何一个模式，那么就不执行任何操作<br>除最后一个分支外（这个分支可以是普通分支，也可以是 <code>*)</code> 分支），其它的每个分支都必须以 <code>;;</code> 结尾， <code>;;</code> 代表一个分支的结束，不写的话会有语法错误。最后一个分支可以写 <code>;;</code> ，也可以不写，执行到 <code>esac</code> 都会结束整个 <code>case in</code> 语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;Input integer number: &quot;</span><br><span class="line">read num</span><br><span class="line"></span><br><span class="line">case $num in</span><br><span class="line">    1)</span><br><span class="line">        echo first</span><br><span class="line">        ;;</span><br><span class="line">    1)</span><br><span class="line">        echo second</span><br><span class="line">        ;;    </span><br><span class="line">    *)</span><br><span class="line">        echo other</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p><code>case in</code> 的正则表达式</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>表示任意字符串</td>
</tr>
<tr>
<td>[abc]</td>
<td>表示 a、b、c 三个字符中的任意一个</td>
</tr>
<tr>
<td>[m-n]</td>
<td>表示从 m 到 n 的任意一个字符</td>
</tr>
<tr>
<td>&#124;</td>
<td>表示多重选择，类似逻辑运算中的或运算</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">read -n 1 char</span><br><span class="line"></span><br><span class="line">case $char in</span><br><span class="line">    [a-zA-Z])</span><br><span class="line">        echo &#39;a-z&#39;</span><br><span class="line">        ;;</span><br><span class="line">    [0-9])</span><br><span class="line">        echo &#39;0-9&#39;</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo other</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>当条件满足时，<code>while</code> 重复地执行一组语句，当条件不满足时，就退出 <code>while</code> 循环</p>
<p><code>while</code> 循环的执行流程为：</p>
<ol>
<li><p>先对 <code>condition</code> 进行判断，如果该条件成立，就进入循环，执行 <code>while</code> 循环体中的语句，也就是 <code>do</code> 和 <code>done</code> 之间的语句。这样就完成了一次循环。</p>
</li>
<li><p>每一次执行到 <code>done</code> 的时候都会重新判断 <code>condition</code> 是否成立，如果成立，就进入下一次循环，继续执行 <code>do</code> 和 <code>done</code> 之间的语句，如果不成立，就结束整个 <code>while</code> 循环，执行 <code>done</code> 后面的其它 Shell 代码。</p>
</li>
<li><p>如果一开始 <code>condition</code> 就不成立，那么程序就不会进入循环体，<code>do</code> 和 <code>done</code> 之间的语句就没有执行的机会</p>
</li>
</ol>
<p>注意，在 <code>while</code> 循环体中必须有相应的语句使得 <code>condition</code> 越来越趋近于”不成立”，只有这样才能最终退出循环，否则 <code>while</code> 就成了死循环，会一直执行下去，永无休止</p>
<p>计算从 1 加到 100 的和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i&#x3D;1</span><br><span class="line">sum&#x3D;0</span><br><span class="line"></span><br><span class="line">while ((i &lt;&#x3D; 100))</span><br><span class="line">do</span><br><span class="line">    ((sum +&#x3D; i))</span><br><span class="line">    ((i++))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>计算从 m 加到 n 的值<br>输入一个数字n并计算1到这个数的总和<br>要求：如果这个数小于等于1，要求重新输入，直到输入大于1的数字为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">num&#x3D;0</span><br><span class="line">while ((num &lt;&#x3D; 1))</span><br><span class="line">    ((i++))</span><br><span class="line"></span><br><span class="line">do</span><br><span class="line">    printf &quot;input number&quot; </span><br><span class="line">    read num</span><br><span class="line">done    </span><br><span class="line">printf &quot;input number is : $num&quot; </span><br><span class="line"></span><br><span class="line">i&#x3D;0     </span><br><span class="line">total&#x3D;0</span><br><span class="line">while ((i &lt;&#x3D; num))</span><br><span class="line">do</span><br><span class="line">    ((total +&#x3D; i))</span><br><span class="line">    ((i++))</span><br><span class="line">done</span><br><span class="line">echo &quot;total is : $total&quot;</span><br></pre></td></tr></table></figure>

<h3 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h3><p><code>unti</code> 循环和 <code>while</code> 循环恰好相反，当判断条件不成立时才进行循环，一旦判断条件成立，就终止循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><code>condition</code> 表示判断条件，<code>statements</code> 表示要执行的语句（可以只有一条，也可以有多条）</p>
<p><code>until</code> 循环的执行流程为：</p>
<ol>
<li><p>先对 <code>condition</code> 进行判断，如果该条件不成立，就进入循环，执行 <code>until</code> 循环体中的语句（do 和 done 之间的语句），这样就完成了一次循环。</p>
</li>
<li><p>每一次执行到 <code>done</code> 的时候都会重新判断 <code>condition</code> 是否成立，如果不成立，就进入下一次循环，继续执行循环体中的语句，如果成立，就结束整个 <code>until</code> 循环，执行 <code>done</code> 后面的其它 Shell 代码。</p>
</li>
<li><p>如果一开始 <code>condition</code> 就成立，那么程序就不会进入循环体，<code>do</code> 和 <code>done</code> 之间的语句就没有执行的机会</p>
</li>
</ol>
<p>注意，在 <code>until</code> 循环体中必须有相应的语句使得 <code>condition</code> 越来越趋近于”成立”，只有这样才能最终退出循环，否则 <code>until</code> 就成了死循环，会一直执行下去，永无休止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i&#x3D;1</span><br><span class="line">sum&#x3D;0</span><br><span class="line">until ((i &gt; 100))</span><br><span class="line">do</span><br><span class="line">    ((sum +&#x3D; i))</span><br><span class="line">    ((i++))</span><br><span class="line">done</span><br><span class="line">echo &quot;The sum is: $sum&quot;</span><br></pre></td></tr></table></figure>

<h3 id="for循环-和-for-int循环"><a href="#for循环-和-for-int循环" class="headerlink" title="for循环 和 for int循环"></a>for循环 和 for int循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for((exp1; exp2; exp3))</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><code>exp1</code>、<code>exp2</code>、<code>exp3</code> 是三个表达式，其中 <code>exp2</code> 是判断条件，<code>for</code> 循环根据 <code>exp2</code> 的结果来决定是否继续下一次循环；<br><code>statements</code> 是循环体语句，可以有一条，也可以有多条；<br><code>do</code> 和 <code>done</code> 是 Shell 中的关键字</p>
<p>执行流程为:</p>
<ol>
<li>先执行 <code>exp1</code></li>
<li>再执行 <code>exp2</code>，如果它的判断结果是成立的，则执行循环体中的语句，否则结束整个 <code>for</code> 循环</li>
<li>执行完循环体后再执行 <code>exp3</code></li>
<li>重复执行步骤2 和 3，直到 <code>exp2</code> 的判断结果不成立，就结束循环</li>
</ol>
<p>步骤2 和 3 合并在一起算作一次循环，会重复执行，<br><code>for</code> 语句的主要作用就是不断执行步骤 2 和 3</p>
<h3 id="select-in循环"><a href="#select-in循环" class="headerlink" title="select in循环"></a>select in循环</h3><p>select in 循环用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能</p>
<p><code>select in</code> 是 Shell 独有的一种循环，非常适合终端（Terminal）这样的交互场景</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select variable in value_list</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><code>variable</code> 表示变量，<code>value_list</code> 表示取值列表，<code>in</code> 是 Shell 中的关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">What is your favourite OS?</span><br><span class="line">1) Linux</span><br><span class="line">2) Windows</span><br><span class="line">3) Mac OS</span><br><span class="line">4) UNIX</span><br><span class="line">5) Android</span><br><span class="line">#? 4↙</span><br><span class="line">You have selected UNIX</span><br><span class="line">#? 1↙</span><br><span class="line">You have selected Linux</span><br><span class="line">#? 9↙</span><br><span class="line">You have selected</span><br><span class="line">#? 2↙</span><br><span class="line">You have selected Windows</span><br><span class="line">#?^D</span><br></pre></td></tr></table></figure>

<p><code>#?</code> 用来提示用户输入菜单编号；<br><code>^D</code> 表示按下 <code>Ctrl+D</code> 组合键，它的作用是结束 <code>select in</code> 循环</p>
<p>运行到 <code>select</code> 语句后，取值列表 <code>value_list</code> 中的内容会以菜单的形式显示出来，用户输入菜单编号，就表示选中了某个值，这个值就会赋给变量 <code>variable</code>，然后再执行循环体中的 <code>statements</code>（do 和 done 之间的部分）</p>
<p>每次循环时 <code>select</code> 都会要求用户输入菜单编号，并使用环境变量 <code>PS3</code> 的值作为提示符，<code>PS3</code> 的默认值为 <code>#?</code>，修改 <code>PS3</code> 的值就可以修改提示符</p>
<p>如果用户输入的菜单编号不在范围之内，例如上面我们输入的 9，那么就会给 <code>variable</code> 赋一个空值；</p>
<p>如果用户输入一个空值（什么也不输入，直接回车），会重新显示一遍菜单</p>
<p>注意，<code>select</code> 是无限循环，输入空值，或者输入的值无效，都不会结束循环，只有遇到 <code>break</code> 语句，或者按下 <code>Ctrl+D</code> 组合键才能结束循环</p>
<p>和 <code>case in</code> 一起使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;What is your favourite OS?&quot;</span><br><span class="line">select name in &quot;Linux&quot; &quot;Windows&quot; &quot;Mac OS&quot; &quot;UNIX&quot; &quot;Android&quot;</span><br><span class="line">do</span><br><span class="line">    case $name in</span><br><span class="line">        &quot;Linux&quot;)</span><br><span class="line">            echo Linux</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        &quot;Windows&quot;)</span><br><span class="line">            echo Windows</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        &quot;Mac OS&quot;)</span><br><span class="line">            echo &quot;Mac OS&quot;</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        &quot;UNIX&quot;)</span><br><span class="line">            echo UNIX</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        &quot;Android&quot;)</span><br><span class="line">            echo Android</span><br><span class="line">            break</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            echo other</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="break-和-continue-跳出循环"><a href="#break-和-continue-跳出循环" class="headerlink" title="break 和 continue 跳出循环"></a>break 和 continue 跳出循环</h3><p>Shell 中的 <code>break</code> 和 <code>continue</code> 能够跳出多层循环，也就是说，内层循环中的 <code>break</code> 和 <code>continue</code> 能够跳出外层循环</p>
<p>在实际开发中，<code>break</code> 和 <code>continue</code> 一般只用来跳出当前层次的循环，很少有需要跳出多层循环的情况</p>
<p><code>break</code> 关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break n</span><br></pre></td></tr></table></figure>
<p>n 表示跳出循环的层数，如果省略 n，则表示跳出当前的整个循环</p>
<p><code>continue</code> 关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">continue n</span><br></pre></td></tr></table></figure>

<p>如果省略 n，则表示 <code>continue</code> 只对当前层次的循环语句有效，遇到 <code>continue</code> 会跳过本次循环，忽略本次循环的剩余代码，直接进入下一次循环</p>
<p>如果带上 n，比如 n 的值为 2，那么 <code>continue</code> 对内层和外层循环语句都有效，不但内层会跳过本次循环，外层也会跳过本次循环，其效果相当于内层循环和外层循环同时执行了不带 n 的 <code>continue</code></p>
<p><code>break</code> 和 <code>continue</code> 的区别<br><code>break</code> 用来结束所有循环，循环语句不再有执行的机会；<br><code>continue</code> 用来结束本次循环，直接跳到下一次循环，如果循环条件成立，还会继续循环</p>
<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function name() &#123;</span><br><span class="line">    statements</span><br><span class="line">    [return value]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name() &#123;</span><br><span class="line">    statements</span><br><span class="line">    [return value]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function name &#123;</span><br><span class="line">    statements</span><br><span class="line">    [return value]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>function</code> 是 Shell 中的关键字，专门用来定义函数；<br><code>name</code> 是函数名；<br><code>statements</code>是函数要执行的代码，也就是一组语句；<br><code>return value</code>表示函数的返回值，其中 <code>return</code> 是 Shell 关键字，专门用在函数中返回一个值；这一部分可以写也可以不写<br>由 <code>&#123; &#125;</code> 包围的部分称为函数体，调用一个函数，实际上就是执行函数体中的代码</p>
<p>定义一个函数，计算所有参数的和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getsum()&#123;</span><br><span class="line">    local sum&#x3D;0</span><br><span class="line">    for n in $@</span><br><span class="line">    do</span><br><span class="line">        ((sum+&#x3D;n))</span><br><span class="line">    done</span><br><span class="line">    return $sum</span><br><span class="line">&#125;</span><br><span class="line">getsum 10 20 55 15 </span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>

<p>函数参数是 Shell 位置参数的一种，在函数内部可以使用 <code>$n</code> 来接收<br><code>$#</code> 可以获取传递的参数的个数<br><code>$@</code> <code>$*</code> 表示函数的所有参数<br><code>$?</code> 表示函数的退出状态（返回值）</p>
<h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><ol>
<li>重定向分为两种，一种输入重定向，一种是输出重定向</li>
</ol>
<p>一般情况下，我们都是从键盘读取用户输入的数据，然后再把数据拿到程序（C语言程序、Shell 脚本程序等）中使用；这就是标准的输入方向，也就是从键盘到程序</p>
<p>程序中也会产生数据，这些数据一般都是直接呈现到显示器上，这就是标准的输出方向，也就是从程序到显示器</p>
<p>输入方向就是数据从哪里流向程序。数据默认从键盘流向程序，如果改变了它的方向，数据就从其它地方流入，这就是输入重定向。</p>
<p>输出方向就是数据从程序流向哪里。数据默认从程序流向显示器，如果改变了它的方向，数据就流向其它地方，这就是输出重定向</p>
<ol start="2">
<li>硬件设备和文件描述符</li>
</ol>
<p>Linux 中一切皆文件，包括标准输入设备（键盘）和标准输出设备（显示器）在内的所有计算机硬件都是文件</p>
<p>为了表示和区分已经打开的文件，Linux 会给每个文件分配一个 <code>ID</code>，这个 <code>ID</code> 就是一个整数，被称为文件描述符（File Descriptor）</p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>文件名</th>
<th>类型</th>
<th>硬件</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>stdin</td>
<td>标准输入文件</td>
<td>键盘</td>
</tr>
<tr>
<td>1</td>
<td>stdout</td>
<td>标准输出文件</td>
<td>显示器</td>
</tr>
<tr>
<td>2</td>
<td>stderr</td>
<td>标准错误输出文件</td>
<td>显示器</td>
</tr>
</tbody></table>
<p>Linux 程序在执行任何形式的 <code>I/O</code> 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接</p>
<p><code>stdin</code>、<code>stdout</code>、<code>stderr</code> 默认都是打开的，在重定向的过程中，0、1、2 这三个文件描述符可以直接使用</p>
<ol start="3">
<li>输出重定向</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>标准输出重定向</td>
<td>command &gt;file</td>
<td>以覆盖的方式，把 command 的正确输出结果输出到 file 文件中</td>
</tr>
<tr>
<td>标准输出重定向</td>
<td>command &gt;&gt;file</td>
<td>以追加的方式，把 command 的正确输出结果输出到 file 文件中</td>
</tr>
<tr>
<td>标准错误输出重定向</td>
<td>command 2 &gt;file</td>
<td>以覆盖的方式，把 command 的错误信息输出到 file 文件中</td>
</tr>
<tr>
<td>标准错误输出重定向</td>
<td>command 2 &gt;&gt;file</td>
<td>以追加的方式，把 command 的错误信息输出到 file 文件中</td>
</tr>
<tr>
<td>正确输出和错误信息同时保存</td>
<td>command &gt;file 2&gt;&amp;1</td>
<td>以覆盖的方式，把正确输出和错误信息同时保存到同一个文件（file）中</td>
</tr>
<tr>
<td>正确输出和错误信息同时保存</td>
<td>command &gt;&gt;file 2&gt;&amp;1</td>
<td>以追加的方式，把正确输出和错误信息同时保存到同一个文件（file）中</td>
</tr>
<tr>
<td>正确输出和错误信息同时保存</td>
<td>command &gt;file1 2&gt;file2</td>
<td>以覆盖的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中</td>
</tr>
<tr>
<td>正确输出和错误信息同时保存</td>
<td>command &gt;&gt;file1  2&gt;&gt;file2</td>
<td>以追加的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中</td>
</tr>
</tbody></table>
<p>在输出重定向中，<code>&gt;</code>代表的是覆盖，<code>&gt;&gt;</code>代表的是追加</p>
<p>将输入结果以追加的方式重定向到文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for str in &quot;hello&quot; &quot;http:&#x2F;&#x2F;test.com&quot; &quot;john&quot;</span><br><span class="line">do</span><br><span class="line">    echo $str &gt;&gt;test.txt</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>输出重定向的完整写法其实是 <code>fd&gt;file</code> 或者 <code>fd&gt;&gt;file</code>，其中 fd 表示文件描述符，如果不写，默认为 1，也就是标准输出文件</p>
<p>当文件描述符为 1 时，一般都省略不写</p>
<p>当文件描述符为大于 1 的值时，比如 2，就必须写上</p>
<p>需要重点说明的是，<code>fd</code> 和 <code>&gt;</code> 之间不能有空格，否则 Shell 会解析失败；<br><code>&gt;</code> 和 <code>file</code> 之间的空格可有可无。为了保持一致，我习惯在&gt;两边都不加空格</p>
<p>正确结果和错误信息分开保存到不同的文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &gt;&gt;out.log 2&gt;&gt;err.log</span><br></pre></td></tr></table></figure>

<p><code>/dev/null</code> 文件</p>
<p>如果你既不想把命令的输出结果保存到文件，也不想把命令的输出结果显示到屏幕上，干扰命令的执行，那么可以把命令的所有结果重定向到 <code>/dev/null</code> 文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &amp;&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>输入重定向</li>
</ol>
<p>输入重定向就是改变输入的方向，不再使用键盘作为命令输入的来源，而是使用文件作为命令的输入</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>command &lt;file</td>
<td>将 file 文件中的内容作为 command 的输入</td>
</tr>
<tr>
<td>command &lt;&lt;END</td>
<td>从标准输入（键盘）中读取数据，直到遇见分界符 END 才停止（分界符可以是任意的字符串，用户自己定义）</td>
</tr>
<tr>
<td>command <file1 >file2</td>
<td>将 file1 作为 command 的输入，并将 command 的处理结果输出到 file2</td>
</tr>
</tbody></table>
<p>和输出重定向类似，输入重定向的完整写法是 <code>fd&lt;file</code>，其中 <code>fd</code> 表示文件描述符，如果不写，默认为 0，也就是标准输入文件</p>
<p>统计文档中有多少行文字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc  [选项]  [文件名]</span><br></pre></td></tr></table></figure>

<p>Linux wc 命令可以用来对文本进行统计，包括单词个数、行数、字节数<br><code>-c</code> 选项统计字节数，<code>-w</code> 选项统计单词数，<code>-l</code> 选项统计行数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -l &lt;test.txt</span><br></pre></td></tr></table></figure>

<p>读取文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while read str;</span><br><span class="line">do</span><br><span class="line">    echo $str</span><br><span class="line">done &lt;readme.txt</span><br></pre></td></tr></table></figure>
<p>这种写法叫做代码块重定向，也就是把一组命令同时重定向到一个文件</p>
    </div>
  </div>
  
    <div class="copy-right">
      <div class="markdown-body">
        <blockquote>
        
        
          本文作者 : JohnScott <br/>
        
        原文链接 : <a href="">https://github.com/liuxue5213/liuxue5213.github.io/2020/Shell%E8%84%9A%E6%9C%AC/</a><br>
        版权声明 : 本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
        </blockquote>
      </div>
    </div>
  
  
  
    <div class="social-share"
  style="margin-top: -2rem"
  data-wechat-qrcode-title="<p>微信扫一扫</p>"
  data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>"
   data-sites="qzone, qq, weibo, wechat, douban, google, facebook, twitter" 
  
>
  <span style="color: #6b7487; font-size: 1.4rem;">分享到: </span>
</div>
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" async>
  

  
    <div id="reward">
  
    <p id="reward-meta">知识 & 情怀 | 二者兼得</p>
  
  <button id="reward-btn">
    
    <span>感谢您的关心</span>
  </button>
  <div id="reward-qrcode">
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/wechat.png" alt="微信扫一扫">
        <p class="qrcode-meta">微信扫一扫</p>
      </div>
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/alipay.png" alt="支付宝扫一扫">
        <p class="qrcode-meta">支付宝扫一扫</p>
      </div>
    
  </div>

</div>

<script>
  (() => {
    let button = document.querySelector('#reward-btn'),
      qrcode = document.querySelector('#reward-qrcode'),
      display = false;
    
    button.addEventListener('click', () => {
      qrcode.style.display = display ? 'none' : 'block'
      display = !display
    }, false)
  })()
</script>
  

  <div class="article-footer">
    <div class="article-meta pull-left">
      <span>
        
          <i class="iconfont icon-06tags"></i>标签: 
          
          <span class="span--tag">
            <a href="/tags/%E5%91%BD%E4%BB%A4/">
              #命令
            </a>
          </span>
          
        
      </span>
    </div>
    <div class="article-meta pull-right">
    </div>
  </div>
</div>


  <aside id="sidebar">
    <p id="sidebar-header"></p>
    <ol id="sidebar-toc"></ol>
  </aside>
  <script async>setTimeout(generateToc, 10);</script>


  <nav class="post-navigation">
    
      <div class="nav-pre">
        <i class="iconfont icon-prev"></i>
        上一篇:
        <a href="/2020/Iptables%E9%98%B2%E7%81%AB%E5%A2%99/" target="_self">Linux-iptables介绍</a>
      </div>
    
    
      <div class="nav-next">
        下一篇:
        <a href="/2020/Mysql%E7%B4%A2%E5%BC%95/" target="_self">Mysql索引</a>
        <i class="iconfont icon-next"></i>
      </div>
    
  </nav>

  
    <a href="#comment" class="comment-anchor"></a>
<div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹 <i class="iconfont icon-footprint"></i></div>
<div id="vcomments"></div>

<script defer>
  if( true ) {
    let path = getRealPath()
    new Valine({
      el: "#vcomments",
      appId: "E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz",
      appKey: "6VNHrdDAu0JKJXxyMajHk6qD",
      notify: false,
      verify: false,
      avatar: "robohash",
      placeholder: "正确填写邮箱, 才能及时收到回复哦♪(^∇^*)",
      path
    });
  }
</script>
   

  
    <script defer>
const valineAPI = (() => {
  try {
    AV.init("E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz", "6VNHrdDAu0JKJXxyMajHk6qD");
  } catch(error) {}
  const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
      query.equalTo("identity", identity);
      query.find().then(results => {
        resolve(results.length > 0);
      }, error => reject(error));
    })
  }

  const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
      let querys = [];
      for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
      }
      query = AV.Query.or.apply(null ,querys);
    } else {
      identity = identity || getRealPath();
      query = new AV.Query("Timer");
      query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
      query.find()
      .then(results => resolve(results))
      .catch(error => reject(error))
    })
  }

  const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let Todo = AV.Object.extend('Timer');
      let todo = new Todo();
      todo.set("times", 1);
      todo.set("identity", identity);
      todo.save().then(res => resolve(true), error => reject(error));
    })
  }

  const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let query = new AV.Query('Timer');
      query.equalTo("identity", identity);
      query.find().then(todos => {
        todos.forEach(todo => {
          todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
      }).then(todos => resolve(true), error => reject(error));
    })
  }

  return {
    isExist,
    _get,
    update,
    create
  }
})()

const calcAndWriteTimes = () => {
  let isPost = true;

  let timerAllDOM = document.querySelectorAll(".article-timer");

  if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
      if(exist) {
        return valineAPI.update(identity);
      }
      return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
  }

  let timerDOMCache = {};

  for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
      timerDOMCache[identity].dom.push(timerDOM);
    }else{
      timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
      };
    }
  }

  let identities = Object.keys(timerDOMCache);
  valineAPI._get(identities).then(results => {
    for(let result of results) {
      let {identity, times} = result.attributes;
      timerDOMCache[identity].times = times;
      timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
      if(timerDOMCache[identity].times){
        continue;
      }
      timerDOMCache[identity].dom.map(item => item.innerText = 1);
      valineAPI.create(identity);
    }
  }).catch(error => console.log(error.message))
}

if(true){
  calcAndWriteTimes();
}
</script>
   

</div>


      <footer>
  <p class="site-info">
    博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span>
    <br>
    Theme - <a href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by <a target="_blank" rel="noopener" href="https://godbmw.com/">GodBMW</a>
    <br>
    
  </p>
</footer>



<script>
const timeToNowDOM = document.querySelector("#time-to-now");
const startTimestamp = new Date(2015, 0, 1).getTime();

const updateTimeStr = () => {
  let offset = parseInt(
      (new Date().getTime() - startTimestamp) / 1000,
      10
    ),
    day = Math.floor(offset / 86400),
    hour = Math.floor((offset % 86400) / 3600),
    minute = Math.floor(((offset % 86400) % 3600) / 60),
    second = Math.floor(((offset % 86400) % 3600) % 60);
  timeToNowDOM.innerHTML =
    day + "天" + hour + "小时" + minute + "分钟" + second + "秒";
  setTimeout(updateTimeStr, 500);
}

setTimeout(updateTimeStr, 500);
</script>


      <div class="back-to-top hidden">
  <span>
    <i class="iconfont icon-60"></i><span></span>%
  </span>
</div>

<script>
const updateIconToTop = percent => {
  let dom = document.querySelector(".back-to-top span span");
  dom.innerText = percent;
  if(percent < 1) {
    document.querySelector(".back-to-top").className = "back-to-top hidden";
  } else {
    document.querySelector(".back-to-top").className = "back-to-top";
  }
}

const handleScoll = () => {
  let isRunning = false;
  return () => {
    if (isRunning) return;
    isRunning = true;
    window.requestAnimationFrame(timestamp => {
      let scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop,
        scrollHeight =
          document.documentElement.scrollHeight ||
          document.body.scrollHeight,
        clientHeight =
          document.documentElement.clientHeight ||
          document.body.clientHeight;
      isRunning = false;
      if (scrollTop <= 1) {
        updateIconToTop(0);
        return;
      }
      if (scrollTop + clientHeight >= scrollHeight) {
        updateIconToTop(100);
      } else {
        updateIconToTop(parseInt(
          100 * scrollTop / (scrollHeight - clientHeight),
          10
        ));
      }
    });
  };
}

const backToTop = () => {
  let scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop,
    delay = 10,
    time = 200;
  if (scrollTop <= 20) {
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    return;
  }
  let step = Math.ceil(scrollTop * delay / time);
  let timer = setInterval(() => {
    scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop;
    if (scrollTop - step <= 0) {
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      clearInterval(timer);
    } else {
      document.documentElement.scrollTop = scrollTop - step;
      document.body.scrollTop = scrollTop - step;
    }
  }, delay);
}

document.addEventListener("scroll", handleScoll(), false);

document.querySelector(".back-to-top").addEventListener("click", backToTop, false);

</script>

    </div>

    
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  (() => {
    const mathjaxConfig = {
      showProcessingMessages: false, //关闭js加载过程信息
      messageStyle: "none", //不显示信息
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
        displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], //可选字体
        showMathMenu: false //关闭右击菜单显示
      }
    }

    let mathjaxInterval = setInterval(() => {
      if(!window.MathJax){
        return;
      }
      window.MathJax.Hub.Config(mathjaxConfig)
      window.MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('app')])

      clearInterval(mathjaxInterval)
    }, 10)    
  })()
</script>
    

    <script src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script>
<script async>
  let fancyTimer = setInterval(function(){
    if(!window.$){
      return;
    }
    $(document).ready(function() {
      $(".post img").each(function () {
        if($(this).parent().get(0).tagName.toLowerCase() === "a") {
          return;
        }
        // $(this).attr("data-fancybox", "gallery"); // if you add 'data-fancybox', img will display after showed
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "gallery");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      });
      
      clearInterval(fancyTimer);
    });
  }, 10);
</script>

    
  </body>

</html>
