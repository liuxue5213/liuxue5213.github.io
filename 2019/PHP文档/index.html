<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta name="author" content="johnscott" />
  
  
  
  <title>PHP文档 | JohnScott2046的博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="PHP,PHP," />
  

  <script>
    console.log('\n%c Hexo-theme-bmw v4.0 ' + '%c 🎉 https://github.com/dongyuanxin/theme-bmw 🎉\n' + '\n%c View demo online ' + '%c 🔍 https://godbmw.com/ 🔍  \n' , 'color: #fadfa3; background: #030307; padding:3px 0;', '', 'color: #fadfa3; background: #030307; padding:3px 0;', '');
  </script>

  
    <meta name="description" content="超级帽子戏法的个人博客,主要记录复制粘贴过来的笔记,还有自己的一些心得体会">
  

  

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/icon/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  
<script src="/js/util.js"></script>
<script src="/js/valine.min.js"></script>


  

  
    <link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js" async></script>
  

  
    <link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">
  
  
  <script src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js" async></script>
  
  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script>
  

<meta name="generator" content="Hexo 5.1.1"></head>

  <body>
    <meta name="baidu-site-verification" content="code-gxYIK5UWjA" />
    

    <div id="app">

      <div class="header-wrap">
  <header>
    <div class="site-brand">
      <div class="site-title">
        <a href="/">JohnScott2046</a>
      </div>
    </div>
    <nav class="site-navigation">
      <ul class="nav-menu">
      
        <li class="nav-item" data-path="/">
          
            <a 
              href="/"
              target="_self"
            >
              主页
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/archives/">
          
            <a 
              href="/archives/"
              target="_self"
            >
              归档
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/categories/">
          
            <a 
              href="/categories/"
              target="_self"
            >
              分类
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/tags/">
          
            <a 
              href="/tags/"
              target="_self"
            >
              标签
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/friends/">
          
            <a 
              href="/friends/"
              target="_self"
            >
              友链
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/about/">
          
            <a 
              href="/about/"
              target="_self"
            >
              关于
            </a>
          
        </li>
      
        <li class="nav-item" data-path="">
          
            <a href="javascript:void(0);" v-else>联系我</a>
            <ul class="nav-menu--dropdown">
              
                <li>
                  <a 
                    href="https://github.com/liuxue5213" 
                    target="_blank"
                  >
                    Github
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.zhihu.com/people/liuxue5213" 
                    target="_blank"
                  >
                    知乎
                  </a>
                </li>
              
                <li>
                  <a 
                    href="http://weibo.com/liuxue5213" 
                    target="_blank"
                  >
                    微博
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.douban.com/people/liuxue5213" 
                    target="_blank"
                  >
                    豆瓣
                  </a>
                </li>
              
                <li>
                  <a 
                    href="/linkedin.com/in/liuxue5213" 
                    target="_blank"
                  >
                    linkedin
                  </a>
                </li>
              
            </ul>
          
        </li>
      
      </ul>
    </nav>
    <i class="iconfont icon-menu"></i>
  </header>
</div>

<script>
  let links = document.querySelectorAll('.nav-item');
  for(let link of links){
    let childrenLink = link.querySelector('ul');
    link.addEventListener('mouseenter', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown active";
      }
    })
    link.addEventListener('mouseleave', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown";
      }
    })
  }
  let rootRealPath = getRealPath(window.location.pathname, true);
  for(let link of links) {
    let linkPath = link.getAttribute("data-path");
    if(linkPath && getRealPath(linkPath, true) === rootRealPath) {
      link.className = "nav-item hover";
    }
  }

  let iconMenu = document.querySelector("i.iconfont.icon-menu"),
    iconMenuClicked = false;
  let navDOM = document.querySelector("nav.site-navigation");
  iconMenu.addEventListener("click", () => {
    iconMenuClicked 
      ? navDOM.className = "site-navigation active"
      : navDOM.className = "site-navigation";
    iconMenuClicked = !iconMenuClicked;
  })
</script>

      








<div class="container post-index">

  

<div class="post">
  <h1 class="article-title">
    <span>PHP文档</span>
  </h1>
  <div class="article-top-meta">
    <span>
      发布 : 
      2019-03-16
    </span>
    
      <span>
        分类 : 
          <a href="/categories/PHP/">
            PHP
          </a>
      </span>
    
    
      <span>
        浏览 : <span class="article-timer" data-identity="PHP文档"></span>
      </span>
    
  </div>

  

  <div class="article-content">
    <div class="markdown-body">
      <h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>0 0.0 “0” “” null array()   false<br>所有其它值都被认为是 TRUE（包括任何资源,-1 和其它非零值（不论正负）一样) </p>
<h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>要使用二进制表达，数字前必须加上 0b<br>要使用八进制表达，数字前必须加上 0（零）<br>要使用十六进制表达，数字前必须加上 0x</p>
<p>binary 0b[01]+<br>octal 0[0-7]+<br>decimal [1-9][0-9]*|0<br>hexadecimal 0[xX][0-9a-fA-F]+<br>integer 所有</p>
<p>如果一个数超出了integer的范围，将会转为float。<br>同样如果执行的运算结果超出了integer范围，也会返回 float。<br>不同的系统 溢出数不同</p>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p>decbin(int number)  10-&gt;2<br>decoct(int number)  10-&gt;8<br>dechex(int number)  10-&gt;16</p>
<p>bindec()  2-&gt;10<br>octdec()  8&gt;10<br>hexdec()  16-&gt;10</p>
<p>//任意转换  16-&gt;2<br>base_convert($hexadecimal,16,2);</p>
<p>chr()  ascii -&gt; str<br>ord()  str -&gt; ascii</p>
<h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>小数点后5位 相差忽略不计，该值也被称为机器极小值（epsilon）或最小单元取整数，是计算中所能接受的最小的差别值</p>
<h4 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h4><p>把百分号（%）符号替换成一个作为参数进行传递的变量<br>%d 数字    %f 浮点数  %s 字符串<br>%b 二进制  %o 八进制  %x 十六进制(小写)  %c acsii  </p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>{} 把变量和后边的字符串区分开<br>单引号 ‘’不会被转义  双引号 “”<br>\n换行 \r回车 \f换页 \反斜线 &quot;双引号</p>
<h4 id="Heredoc结构-变量会解析"><a href="#Heredoc结构-变量会解析" class="headerlink" title="Heredoc结构  变量会解析"></a>Heredoc结构  变量会解析</h4><p>$BAR = &lt;&lt;&lt;结构<br>Constant example<br>结构;</p>
<h4 id="Nowdoc结构-变量不会被解析"><a href="#Nowdoc结构-变量不会被解析" class="headerlink" title="Nowdoc结构  变量不会被解析"></a>Nowdoc结构  变量不会被解析</h4><p>$str = &lt;&lt;&lt;’EOD’<br>Example of string<br>EOD;</p>
<p>nowdoc结构可以用在任意的静态数据环境中，最典型的示例是用来初始化类的属性或常量</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>有序映射,映射是一种把 values 关联到 keys 的类型,<br>列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性(树形结构,多维数组)</p>
<p>$array = array(1, 2, 3, 4, 5);<br>$array = array(<br>    “foo” =&gt; “bar”,<br>    “bar” =&gt; “foo”,<br>);</p>
<p>// 自 PHP 5.4 起<br>$array = [<br>    “foo” =&gt; “bar”,<br>    “bar” =&gt; “foo”,<br>];</p>
<p>error_reporting(E_ALL);<br>ini_set(‘display_errors’, true);<br>ini_set(‘html_errors’, false);</p>
<p>删除元素 unset() </p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>创建一个新的对象 object，使用 new 语句实例化一个类<br>class foo{<br>  function do_foo(){<br>        echo “Doing foo.”;<br>    }<br>}<br>$bar = new foo;<br>$bar-&gt;do_foo();</p>
<p>$obj = (object)’ciao’;<br>echo $obj-&gt;scalar;</p>
<p>如果将一个对象转换成对象，它将不会有任何变化。<br>如果其它任何类型的值被转换成对象，将会创建一个内置类 stdClass 的实例。<br>如果该值为 NULL，则新的实例为空</p>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>特殊变量，保存了到外部资源的一个引用<br>get_resource_type()  返回数据类型</p>
<h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p>被赋值为null 尚未被赋值 被unset()<br>is_null()</p>
<h3 id="Callback回调类型"><a href="#Callback回调类型" class="headerlink" title="Callback回调类型"></a>Callback回调类型</h3><p>call_user_func用户自定义的回调函数作为参数</p>
<p>function my_callback_function() {<br>    echo ‘aaaaaa’;<br>}</p>
<p>class MyClass {<br>    static function myCallbackMethod() {<br>        echo ‘bbbbbb’;<br>    }<br>}</p>
<p>普通<br>call_user_func(‘my_callback_function’);<br>静态<br>call_user_func(array(‘MyClass’, ‘myCallbackMethod’));<br>call_user_func(‘MyClass::myCallbackMethod’);<br>对象<br>$obj = new MyClass();<br>call_user_func(array($obj, ‘myCallbackMethod’));</p>
<h3 id="常量-变量"><a href="#常量-变量" class="headerlink" title="常量 变量"></a>常量 变量</h3><p>$foo = ‘Bob’;              // 将 ‘Bob’ 赋给 $foo<br>$bar = &amp;$foo;              // 通过 $bar 引用 $foo<br>$bar = “My name is $bar”;  // 修改 $bar 变量</p>
<p>静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失</p>
<p>$a = ‘hello’;<br>一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置</p>
<p>$$a = ‘world’;<br>可变变量名,一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置<br>echo “$a ${$a}”;<br>一个可变变量获取了一个普通变量的值作为这个可变变量的变量名</p>
<p>define(“CONSTANT”, “Hello world.”);<br>define() 可以使用 const 关键字在类定义之外定义常量。<br>一个常量一旦被定义，就不能再改变或者取消定义。<br>通过其名字来取得常量的值，与变量不同，不应该在常量前面加上 $ 符号。</p>
<p>const CONSTANT = ‘Hello World’;<br>如果常量名是动态的，也可以用函数 constant() 来获取常量的值。用 get_defined_constants() 可以获得所有已定义的常量列表。 </p>
<p>如果你要检查一个变量是否存在，请使用isset()。<br>defined() 函数仅对 constants 有效。<br>如果你要检测一个函数是否存在，使用 function_exists()。 </p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>-取反  +加  -减  *乘  /除  %取余</p>
<h4 id="执行shell"><a href="#执行shell" class="headerlink" title="执行shell"></a>执行shell</h4><p>$output = shell_exec(‘ls -lart’);<br>echo “<pre>$output</pre>“;</p>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>&amp;按位与  |按位或  ! 按位异或  `按位取反</p>
<h4 id="逻辑运算符-amp-amp"><a href="#逻辑运算符-amp-amp" class="headerlink" title="逻辑运算符  &amp;&amp; || `"></a>逻辑运算符  &amp;&amp; || `</h4><p>&amp; and逻辑与  | or逻辑或  Xor逻辑异或  !逻辑非 </p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>include 没有指定目录 会按照include_path目录查找<br>如果没有找到，会发出一条警告E_WARNING级别<br>require 产生一个E_COMPILE_ERROR级别错误 脚本停止运行</p>
<p>include_once脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题</p>
<p>require_once 唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。 </p>
<h3 id="类-对象"><a href="#类-对象" class="headerlink" title="类 对象"></a>类 对象</h3><p>extends 继承另一个类的方法和属性<br>php不支持多重继承 一个类只能继承一个基类<br>被继承的方法和属性可以通过用同样的的名字重新声明被覆盖<br>如果父类定义的方法使用了final，可以通过parent::来访问被覆盖的方法或属性<br>new要创建一个类的实例，必须使用 new 关键字。当创建新对象时该对象总是被赋值，除非该对象定义了构造函数并且在出错时抛出了一个异常</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>public公有  protected保护  private私有</p>
<p>构造函数 调用某个对象时先被执行的方法<br>析构函数 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行</p>
<p>继承：继承将会影响到类与类，对象与对象之间的关系<br>当扩展一个类，子类就会继承父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能。<br>除非使用了自动加载，否则一个类必须在使用之前被定义。如果一个类扩展了另一个，则父类必须在子类之前被声明。此规则适用于类继承其它类与接口。<br>当一个子类覆盖其父类中的方法时，PHP 不会调用父类中已被覆盖的方法。是否调用父类的方法取决于子类。这种机制也作用于构造函数和析构函数，重载以及魔术方法。 </p>
<h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p>声明类属性或方法为静态，就可以不实例化类而直接访问<br>静态属性不能通过一个类已实例化的对象来访问（静态方法可以）<br>属性和方法默认为公有<br>静态方法不需要通过对象访问，$this在静态方法中不可用</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类不能被实例化，任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的<br>继承一个抽象类的时候，子类必须定义父类中的所有抽象方法</p>
<h3 id="对象接口"><a href="#对象接口" class="headerlink" title="对象接口"></a>对象接口</h3><p>使用接口，可以指定某个类必须实现的哪些方法，但不需要定义这些方法的具体内容<br>接口是通过interface定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的<br>接口中定义的所有方法都必须是公有</p>
<h4 id="implements"><a href="#implements" class="headerlink" title="implements"></a>implements</h4><p>要实现一个接口，使用implements操作符<br>类中必须实现接口中定义的所有方法，否则会报一个致命的错误<br>实现多个接口时，接口中的方法不能有重名<br>接口也可以继承，通过extends<br>类要实现接口，必须使用和接口中所定义的方法完全一致的方式</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>接口中也可以定义常量，接口常量和类常量使用相同，但是不能被子类或子接口所覆盖</p>
<p>this是指向当前对象的指针<br>self是指向当前类的指针<br>parent是指向父类的指针</p>
<h4 id="traits-代码复用"><a href="#traits-代码复用" class="headerlink" title="traits 代码复用"></a>traits 代码复用</h4><p>Traits是一种为类似PHP的单继承语言而准备的代码复用机制<br>Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用方法集。<br>从基类继承的成员被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。<br>通过逗号分隔，在 use 声明列出多个 trait，可以都插入到一个类中。 </p>
<p>如果两个 trait 都插入了一个同名的方法，如果没有明确解决冲突将会产生一个致命错误。<br>为了解决多个 trait 在同一个类中的命名冲突，需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个。<br>以上方式仅允许排除掉其它方法，as 操作符可以将其中一个冲突的方法以另一个名称来引入。 </p>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>动态的创建类属性和方法<br>当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用</p>
<p>在对象中调用一个不可访问方法时，__call() 会被调用。<br>用静态方式中调用一个不可访问方法时，__callStatic() 会被调用。 </p>
<h4 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h4><p>__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()， __invoke()， __set_state()， __clone() 和 __debugInfo() 等方法在 PHP 中被称为”魔术方法”（Magic methods</p>
<h4 id="对象复制"><a href="#对象复制" class="headerlink" title="对象复制"></a>对象复制</h4><p>__clone() 当对象被复制后，php会对对象的所有属性执行一个浅复制</p>
<p>get_called_class()   <strong>CLASS</strong> 后期静态绑定的功能，用于在继承范围内引用静态调用的类<br>后期静态绑定本想通过引入一个新的关键字表示运行时最初调用的类来绕过限制。简单地说，这个关键字能够让你在上述例子中调用 test() 时引用的类是 B 而不是 A。最终决定不引入新的关键字，而是使用已经预留的 static 关键字。 </p>
<h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><p>所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。<br>unserialize()函数能够重新把字符串变回php原来的值。<br>序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 </p>
<p>为了能够unserialize()一个对象，这个对象的类必须已经定义过。如果序列化类A的一个对象，将会返回一个跟类A相关，而且包含了对象所有变量值的字符串。 如果要想在另外一个文件中解序列化一个对象，这个对象的类必须在解序列化之前定义，可以通过包含一个定义该类的文件或使用函数spl_autoload_register()来实现。 </p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>同一个命名空间可以定义在多个文件中，即允许将同一个命名空间的内容分割存放在不同的文件中。<br>也可以在同一个文件中定义多个命名空间。在同一个文件中定义多个命名空间有两种语法形式。<br>namespace MyProject1；<br>namespace MyProject2；</p>
<p>namespace MyProject1{<br>}<br>namespace MyProject2{<br>}</p>
<h3 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h3><p>$GLOBALS 全部变量<br>$_SERVER 服务器和执行环境信息<br>$_GET,$_POST,$_REQUEST<br>$_FILES  文件信息<br>$_ENV<br>$_COOKIE<br>$HTTP_RAW_POST_DATA 包含POST提交的原始数据<br>$php_errormsg  变量包含由 PHP 生成的最新错误信息。这个变量只在错误发生的作用域内可用，并且要求 track_errors 配置项是开启的（默认是关闭的）<br>$http_response_header HTTP响应头<br>$argc 传递给脚本的参数数目<br>$argv 传递给脚本的参数数组</p>
<p>‘PHP_SELF’当前执行脚本的文件名，与document root有关<br>在地址为 <a target="_blank" rel="noopener" href="http://example.com/test.php/foo.bar">http://example.com/test.php/foo.bar</a> 的脚本中使用 $<em>SERVER[‘PHP_SELF’] 将得到 /test.php/foo.bar<br>__FILE_</em> 常量包含当前(例如包含)文件的完整路径和文件名<br>‘argv’传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。<br>‘argc’包含命令行模式下传递给该脚本的参数的数目。<br>‘GATEWAY_INTERFACE’服务器使用的 CGI 规范的版本；例如，”CGI/1.1”。<br>‘SERVER_ADDR’当前运行脚本所在的服务器的 IP 地址<br>‘SERVER_NAME’当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定<br>‘SERVER_SOFTWARE’服务器标识字符串，在响应请求时的头信息中给出<br>‘SERVER_PROTOCOL’请求页面时通信协议的名称和版本。例如，”HTTP/1.0”<br>‘REQUEST_METHOD’访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”<br>如果请求方法为 HEAD，PHP 脚本将在发送 Header 头信息之后终止(这意味着在产生任何输出后，不再有输出缓冲)<br>‘REQUEST_TIME’请求开始时的时间戳<br>‘REQUEST_TIME_FLOAT’请求开始时的时间戳，微秒级别的精准度<br>‘QUERY_STRING’query string（查询字符串），如果有的话，通过它进行页面访问<br>‘DOCUMENT_ROOT’当前运行脚本所在的文档根目录。在服务器配置文件中定义<br>‘HTTP_ACCEPT’当前请求头中 Accept: 项的内容，如果存在的话<br>‘HTTP_ACCEPT_CHARSET’当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。<br>‘HTTP_ACCEPT_ENCODING’当前请求头中 Accept-Encoding: 项的内容，如果存在的话。例如：”gzip”。<br>‘HTTP_ACCEPT_LANGUAGE’当前请求头中 Accept-Language: 项的内容，如果存在的话。例如：”en”。<br>‘HTTP_CONNECTION’当前请求头中 Connection: 项的内容，如果存在的话。例如：”Keep-Alive”。<br>‘HTTP_HOST’当前请求头中 Host: 项的内容，如果存在的话。<br>‘HTTP_REFERER’引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。<br>‘HTTP_USER_AGENT’当前请求头中 User-Agent: 项的内容，如果存在的话。该字符串表明了访问该页面的用户代理的信息。一个典型的例子是：Mozilla/4.5 [en] (X11; U; Linux 2.2.9 i586)。除此之外，你可以通过 get_browser() 来使用该值，从而定制页面输出以便适应用户代理的性能。<br>‘HTTPS’如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。<br>Note: 注意当使用 IIS 上的 ISAPI 方式时，如果不是通过 HTTPS 协议被访问，这个值将为 off。<br>‘REMOTE_ADDR’浏览当前页面的用户的 IP 地址。<br>‘REMOTE_HOST’浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。<br>Note: 你的服务器必须被配置以便产生这个变量。例如在 Apache 中，你需要在 httpd.conf 中设置 HostnameLookups On 来产生它。参见 gethostbyaddr()。<br>‘REMOTE_PORT’用户机器上连接到 Web 服务器所使用的端口号。<br>‘REMOTE_USER’经验证的用户<br>‘REDIRECT_REMOTE_USER’验证的用户，如果请求已在内部重定向。<br>‘SCRIPT_FILENAME’当前执行脚本的绝对路径。<br>如果在命令行界面（Command Line Interface, CLI）使用相对路径执行脚本，例如 file.php 或 ../file.php，那么 $_SERVER[‘SCRIPT_FILENAME’] 将包含用户指定的相对路径。<br>‘SERVER_ADMIN’该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。<br>‘SERVER_PORT’Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。<br>‘SERVER_SIGNATURE’包含了服务器版本和虚拟主机名的字符串。<br>‘PATH_TRANSLATED’当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果<br>Note: PATH_TRANSLATED 在 Apache 2 SAPI 模式下不再和 Apache 1 一样隐含赋值，而是若 Apache 不生成此值，PHP 便自己生成并将其值放入 SCRIPT_FILENAME 服务器常量中。这个修改遵守了 CGI 规范，PATH_TRANSLATED 仅在 PATH_INFO 被定义的条件下才存在。 Apache 2 用户可以在 httpd.conf 中设置 AcceptPathInfo = On 来定义 PATH_INFO<br>‘SCRIPT_NAME’包含当前脚本的路径。这在页面需要指向自己时非常有用。<strong>FILE</strong> 常量包含当前脚本(例如包含文件)的完整路径和文件名<br>‘REQUEST_URI’URI 用来指定要访问的页面。例如 “/index.html”<br>‘PHP_AUTH_DIGEST’当作为 Apache 模块运行时，进行 HTTP Digest 认证的过程中，此变量被设置成客户端发送的”Authorization” HTTP 头内容（以便作进一步的认证操作）。<br>‘PHP_AUTH_USER’当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名<br>‘PHP_AUTH_PW’当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码<br>‘AUTH_TYPE’当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型<br>‘PATH_INFO’包含由客户端提供的、跟在真实脚本名称之后并且在查询语句（query string）之前的路径信息，如果存在的话。例如，如果当前脚本是通过 URL <a target="_blank" rel="noopener" href="http://www.example.com/php/path_info.php/some/stuff?foo=bar">http://www.example.com/php/path_info.php/some/stuff?foo=bar</a> 被访问，那么 $_SERVER[‘PATH_INFO’] 将包含 /some/stuff<br>‘ORIG_PATH_INFO’在被 PHP 处理之前，”PATH_INFO” 的原始版本 </p>
<p>Exception::__construct 异常构造函数<br>Exception::getMessage 获取异常消息内容<br>Exception::getPrevious 返回异常链中的前一个异常<br>Exception::getCode 获取异常代码<br>Exception::getFile 获取发生异常的程序文件名称<br>Exception::getLine 获取发生异常的代码在文件中的行号<br>Exception::getTrace 获取异常追踪信息<br>Exception::getTraceAsString 获取字符串类型的异常追踪信息<br>Exception::__toString 将异常对象转换为字符串<br>Exception::__clone 异常克隆</p>
<p>ErrorException::__construct — 异常构造函数<br>ErrorException::getSeverity — 获取异常的严重程度</p>
<p>public ErrorException::<strong>construct ([ string $message = “” [, int $code = 0 [, int $severity = 1 [, string $filename = __FILE</strong> [, int $lineno = <strong>LINE</strong> [, Exception $previous = NULL ]]]]]] )</p>
<p>message抛出的异常消息内容。<br>code异常代码。<br>severity异常的严重级别。<br>filename抛出异常所在的文件名。<br>lineno抛出异常所在的行号。<br>previous异常链中的前一个异常。 </p>
<p>try {<br>    throw new ErrorException(“Exception message”, 0, 75);<br>} catch(ErrorException $e) {<br>    echo “This exception severity is: “ . $e-&gt;getSeverity();<br>}</p>
<h4 id="HTTP-context选项"><a href="#HTTP-context选项" class="headerlink" title="HTTP context选项"></a>HTTP context选项</h4><p>提供给 http:// 和 https:// 传输协议的 context 选项</p>
<p>$url = “<a target="_blank" rel="noopener" href="http://www.shucunwang.com/RunCode/php5.6&quot;">http://www.shucunwang.com/RunCode/php5.6&quot;</a>;<br>$opts = array(‘http’ =&gt;<br>    array(<br>        ‘method’ =&gt; ‘GET’,<br>        ‘max_redirects’ =&gt; ‘0’,<br>        ‘ignore_errors’ =&gt; ‘1’<br>    )<br>);<br>$context = stream_context_create($opts);<br>$stream = fopen($url, ‘r’, false, $context)<br>print_r(stream_get_meta_data($stream));<br>print_r(stream_get_contents($stream));<br>fclose($stream);</p>
<p>ssl:// 和 tls:// 传输协议上下文选项清单<br>$postdata = http_build_query(<br>    array(<br>        ‘var1’ =&gt; ‘some content’,<br>        ‘var2’ =&gt; ‘doh’<br>    )<br>);<br>$opts = array(‘http’ =&gt;<br>    array(<br>        ‘method’  =&gt; ‘POST’,<br>        ‘header’  =&gt; ‘Content-type: application/x-www-form-urlencoded’,<br>        ‘content’ =&gt; $postdata<br>    )<br>);<br>$context = stream_context_create($opts);<br>$result = file_get_contents(‘<a target="_blank" rel="noopener" href="http://example.com/submit.php&#39;">http://example.com/submit.php&#39;</a>, false, $context);</p>
<h4 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h4><p>是一种在远程浏览器端储存数据并以此来跟踪和识别用户的机制<br>设置setcookie(‘name’,’value’,time()+$int)<br>移除  unset($_COOKIE[‘name’]);<br>setcookie(“yourcookie”,”yourvalue”,time()-1);<br>获取$_COOKIE[‘name’]</p>
<h4 id="文件上传处理"><a href="#文件上传处理" class="headerlink" title="文件上传处理"></a>文件上传处理</h4><p>表单属性 enctype=”multipart/form-data”<br><input type="hidden" name="MAX_FILE_SIZE" value="30000" /><br>MAX_FILE_SIZE 隐藏字段（单位为字节）必须放在文件输入字段之前，其值为接收文件的最大尺寸（辅助性质）<br>file_uploads     upload_max_filesize<br>max_input_time   upload_tmp_dirpost_max_size</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="引用计数基本知识"><a href="#引用计数基本知识" class="headerlink" title="引用计数基本知识"></a>引用计数基本知识</h4><p>每个php变量存在一个叫”zval”的变量容器中。<br>一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。<br>第一个是”is_ref”，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&amp;来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。<br>第二个额外字节是”refcount”，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。 </p>
<p>当一个变量被赋常量值时，就会生成一个zval变量容器<br>$a = “new string”;<br>显示zval信息<br>xdebug_debug_zval(‘a’);<br>a: (refcount=1, is_ref=0)=’new string’</p>
<p>unset($a)  减少引用次数</p>
<p>php.ini  zend.enable_gc回收机制默认打开<br>gc_enable()  打开垃圾回收机制<br>gc_disable() 关闭垃圾回收机制<br>gc_collect_cycles 强制收集所有现存的垃圾循环周期</p>
<h4 id="性能方面考虑因素"><a href="#性能方面考虑因素" class="headerlink" title="性能方面考虑因素"></a>性能方面考虑因素</h4><p>第一个是内存占用空间的节省，另一个是垃圾回收机制执行内存清理时的执行时间增加(run-time delay)。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>推荐的 php.ini 设置<br>opcache.memory_consumption=128<br>opcache.interned_strings_buffer=8<br>opcache.max_accelerated_files=4000<br>opcache.revalidate_freq=60<br>opcache.fast_shutdown=1<br>opcache.enable_cli=1</p>
<p>###加密</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><h4 id="hash-algos-返回已注册的哈希算法列表"><a href="#hash-algos-返回已注册的哈希算法列表" class="headerlink" title="hash_algos()  返回已注册的哈希算法列表"></a>hash_algos()  返回已注册的哈希算法列表</h4><h4 id="hash-1"><a href="#hash-1" class="headerlink" title="hash()"></a>hash()</h4><h4 id="hash-file-algo-filename-raw-output-false-使用给定文件的内容生成哈希值"><a href="#hash-file-algo-filename-raw-output-false-使用给定文件的内容生成哈希值" class="headerlink" title="hash_file($algo,$filename,[$raw_output=false])  使用给定文件的内容生成哈希值"></a>hash_file($algo,$filename,[$raw_output=false])  使用给定文件的内容生成哈希值</h4><p>哈希算法名称,文件路径,输出格式为原始的二进制数据（设置为 FALSE，输出小写的16进制字符串)  </p>
<h4 id="hash-init-algo-option-key-初始化增量哈希运算上下文"><a href="#hash-init-algo-option-key-初始化增量哈希运算上下文" class="headerlink" title="hash_init($algo,[$option,$key])  初始化增量哈希运算上下文"></a>hash_init($algo,[$option,$key])  初始化增量哈希运算上下文</h4><p>要使用的哈希算法名称<br>进行哈希运算的可选设置，仅支持一个选项：HASH_HMAC,当指定此选项的时候，必须指定key参数<br>使用此参数传入进行 HMAC 哈希运算时的共享密钥</p>
<h4 id="hash-update-向活跃的哈希运算上下文中填充数据"><a href="#hash-update-向活跃的哈希运算上下文中填充数据" class="headerlink" title="hash_update()  向活跃的哈希运算上下文中填充数据"></a>hash_update()  向活跃的哈希运算上下文中填充数据</h4><p>由hash_init()函数返回的哈希运算上下文，要向哈希摘要中追加的数据</p>
<h4 id="hash-hmac-algo-data-key-raw-output-false-使用-HMAC-方法生成带有密钥的哈希值"><a href="#hash-hmac-algo-data-key-raw-output-false-使用-HMAC-方法生成带有密钥的哈希值" class="headerlink" title="hash_hmac($algo,$data,$key,[$raw_output=false])  使用 HMAC 方法生成带有密钥的哈希值"></a>hash_hmac($algo,$data,$key,[$raw_output=false])  使用 HMAC 方法生成带有密钥的哈希值</h4><p>$key:使用HMAC生成信息摘要时所使用的密钥<br>hash_hmac_file($algo,$filename,$key,[$raw_output=false])</p>
<h4 id="hash-copy-context-拷贝哈希运算上下文"><a href="#hash-copy-context-拷贝哈希运算上下文" class="headerlink" title="hash_copy($context)  拷贝哈希运算上下文"></a>hash_copy($context)  拷贝哈希运算上下文</h4><h4 id="hash-final-content-raw-output-false-结束增量哈希，并且返回摘要结果"><a href="#hash-final-content-raw-output-false-结束增量哈希，并且返回摘要结果" class="headerlink" title="hash_final($content,[$raw_output=false]) 结束增量哈希，并且返回摘要结果"></a>hash_final($content,[$raw_output=false]) 结束增量哈希，并且返回摘要结果</h4><p>$content:hash_init函数返回的哈希运算上下文资源</p>
<h4 id="hash-pbkdf2-algo-password-salt-iterations-length-0-raw-output-false-生成所提供密码的-PBKDF2-密钥导出"><a href="#hash-pbkdf2-algo-password-salt-iterations-length-0-raw-output-false-生成所提供密码的-PBKDF2-密钥导出" class="headerlink" title="hash_pbkdf2($algo,$password,$salt,$iterations,[$length=0,[$raw_output=false]]) 生成所提供密码的 PBKDF2 密钥导出"></a>hash_pbkdf2($algo,$password,$salt,$iterations,[$length=0,[$raw_output=false]]) 生成所提供密码的 PBKDF2 密钥导出</h4><p>$password:要进行导出的密码<br>$salt:进行导出时所使用的”盐”，这个值应该是随机生成的<br>$iterations:进行导出时的迭代次数<br>$length:密钥导出数据的长度。<br>如果 raw_output 为 TRUE，此参数为密钥导出数据的字节长度。<br>如果 raw_output 为 FALSE，此参数为密钥导出数据的字节长度的2倍，因为 1 个字节数据对应的 2 个 16 进制的字符<br>如果传入 0，则使用所选算法的完整输出大小。 </p>
<p><code>初始化 $cont=hash_init(&#39;md5&#39;); 散列数据 hash(&#39;md5&#39;,&#39;123456&#39;); 填充数据 hash_update($cont,&#39;123456&#39;); 复制数据 $copy_cont=hash_copy($cont); hash_final($cont); 填充复制的数据 hash_update($copy_cont,&#39;123456&#39;); hash_final($copy_cont);</code></p>
<h3 id="Password-Hashing-密码散列-php-gt-5-5"><a href="#Password-Hashing-密码散列-php-gt-5-5" class="headerlink" title="Password_Hashing  密码散列  php&gt;5.5"></a>Password_Hashing  密码散列  php&gt;5.5</h3><h4 id="string-password-hash-string-password-integer-algo-array-options-创建一个密码散列"><a href="#string-password-hash-string-password-integer-algo-array-options-创建一个密码散列" class="headerlink" title="string password_hash (string $password,integer $algo [, array $options ] )   创建一个密码散列"></a>string password_hash (string $password,integer $algo [, array $options ] )   创建一个密码散列</h4><p>PASSWORD_DEFAULT 使用bcrypt算法，随着时间变化改变  建议255长度<br>PASSWORD_BCRYPT   _CRYPT_BLOWFISH 用于创建哈希值，SALT手动提供一种盐在哈希密码时使用，默认是随机的盐  COST使用算法的成本 默认为10(根据硬件增加)   固定60字符</p>
<h4 id="password-get-info-hash-返回哈希的相关信息"><a href="#password-get-info-hash-返回哈希的相关信息" class="headerlink" title="password_get_info($hash)  返回哈希的相关信息"></a>password_get_info($hash)  返回哈希的相关信息</h4><p>password_hash(“rasmuslerdorf”, PASSWORD_DEFAULT).</p>
<p>COST<br><code>$options = [&#39;cost&#39; =&gt; 12,]; echo password_hash(&quot;rasmuslerdorf&quot;, PASSWORD_BCRYPT, $options).</code></p>
<p>COST SALT<br><code>$options = [&#39;cost&#39; =&gt; 11,&#39;salt&#39; =&gt; mcrypt_create_iv(22, MCRYPT_DEV_URANDOM),]; echo password_hash(&quot;rasmuslerdorf&quot;, PASSWORD_BCRYPT, $options).</code></p>
<p>php 5.3实现散列<br><code>$salt = mcrypt_create_iv(22, MCRYPT_DEV_URANDOM); $salt = base64_encode($salt); $salt = str_replace(&#39;+&#39;, &#39;.&#39;, $salt); $hash = crypt(&#39;rasmuslerdorf&#39;, &#39;$2y$10$&#39;.$salt.&#39;$&#39;); echo $hash;</code></p>
<p>指定时间的cost<br><code>function getOptimalBcryptCostParameter($min_ms = 250) &#123;     for ($i = 4; $i &lt; 31; $i++) &#123;         $options = [ &#39;cost&#39; =&gt; $i, &#39;salt&#39; =&gt; &#39;usesomesillystringforsalt&#39; ];         $time_start = microtime(true);         password_hash(&quot;rasmuslerdorf&quot;, PASSWORD_BCRYPT, $options);         $time_end = microtime(true);         if (($time_end - $time_start) * 1000 &gt; $min_ms) &#123;             return $i;         &#125;     &#125; &#125; echo getOptimalBcryptCostParameter();</code></p>
<h4 id="password-needs-rehash-hash-algo-options-检查是否给定哈希匹配给定的选项"><a href="#password-needs-rehash-hash-algo-options-检查是否给定哈希匹配给定的选项" class="headerlink" title="password_needs_rehash($hash,$algo,[$options])  检查是否给定哈希匹配给定的选项"></a>password_needs_rehash($hash,$algo,[$options])  检查是否给定哈希匹配给定的选项</h4><h4 id="password-verify-string-password-string-hash-验证密码匹配一个哈希表"><a href="#password-verify-string-password-string-hash-验证密码匹配一个哈希表" class="headerlink" title="password_verify(string $password,string $hash) 验证密码匹配一个哈希表"></a>password_verify(string $password,string $hash) 验证密码匹配一个哈希表</h4><p>$hash = ‘$2y$07$BCryptRequires22ChrcteVlQH0piJtjXl.0t1XkA8pw9dMXTpOq’;<br>if (password_verify(‘rasmuslerdorf’, $hash)) {<br>    echo ‘Password is valid!’;<br>} else {<br>    echo ‘Invalid password.’;<br>}</p>
<h3 id="Mcrypt"><a href="#Mcrypt" class="headerlink" title="Mcrypt"></a>Mcrypt</h3><p>本扩展是 mcrypt 库的接口，mcrypt 库提供了对多种块算法的支持， 包括：DES，TripleDES，Blowfish （默认）， 3-WAY，SAFER-SK64，SAFER-SK128，TWOFISH，TEA，RC2 以及 GOST，并且支持 CBC，OFB，CFB 和 ECB 密码模式。 甚至，它还支持诸如 RC6 和 IDEA 这两种”非免费”的算法。 默认情况下，CFB/OFB 是 8 比特的。 </p>
<h4 id="预定义常量"><a href="#预定义常量" class="headerlink" title="预定义常量"></a>预定义常量</h4><p>支持以下四种分组密码模式：CBC， OFB，CFB 和 ECB （使用libmcrypt高版本，还支持nOFB分组模式，流模式）</p>
<h5 id="MCRYPT-MODE-ECB-electronic-codebook-适用于随机数据，-比如可以用这种模式来加密其他密钥。-由于要加密的数据很短，并且是随机的，所以这种模式的缺点反而起到了积极的作用。"><a href="#MCRYPT-MODE-ECB-electronic-codebook-适用于随机数据，-比如可以用这种模式来加密其他密钥。-由于要加密的数据很短，并且是随机的，所以这种模式的缺点反而起到了积极的作用。" class="headerlink" title="MCRYPT_MODE_ECB (electronic codebook) 适用于随机数据， 比如可以用这种模式来加密其他密钥。 由于要加密的数据很短，并且是随机的，所以这种模式的缺点反而起到了积极的作用。"></a>MCRYPT_MODE_ECB (electronic codebook) 适用于随机数据， 比如可以用这种模式来加密其他密钥。 由于要加密的数据很短，并且是随机的，所以这种模式的缺点反而起到了积极的作用。</h5><h5 id="MCRYPT-MODE-CBC-cipher-block-chaining-特别适用于对文件进行加密。-相比-ECB，-它的安全性有明显提升。"><a href="#MCRYPT-MODE-CBC-cipher-block-chaining-特别适用于对文件进行加密。-相比-ECB，-它的安全性有明显提升。" class="headerlink" title="MCRYPT_MODE_CBC (cipher block chaining) 特别适用于对文件进行加密。 相比 ECB， 它的安全性有明显提升。"></a>MCRYPT_MODE_CBC (cipher block chaining) 特别适用于对文件进行加密。 相比 ECB， 它的安全性有明显提升。</h5><h5 id="MCRYPT-MODE-CFB-cipher-feedback-对于每个单独的字节都进行加密，-所以非常适用于针对字节流的加密。"><a href="#MCRYPT-MODE-CFB-cipher-feedback-对于每个单独的字节都进行加密，-所以非常适用于针对字节流的加密。" class="headerlink" title="MCRYPT_MODE_CFB (cipher feedback) 对于每个单独的字节都进行加密， 所以非常适用于针对字节流的加密。"></a>MCRYPT_MODE_CFB (cipher feedback) 对于每个单独的字节都进行加密， 所以非常适用于针对字节流的加密。</h5><h5 id="MCRYPT-MODE-OFB-output-feedback-in-8bit-和-CFB-类似。-它可以用在无法容忍加密错误传播的应用中。-因为它是按照-8-个比特位进行加密的，-所以安全系数较低，不建议使用。"><a href="#MCRYPT-MODE-OFB-output-feedback-in-8bit-和-CFB-类似。-它可以用在无法容忍加密错误传播的应用中。-因为它是按照-8-个比特位进行加密的，-所以安全系数较低，不建议使用。" class="headerlink" title="MCRYPT_MODE_OFB (output feedback, in 8bit) 和 CFB 类似。 它可以用在无法容忍加密错误传播的应用中。 因为它是按照 8 个比特位进行加密的， 所以安全系数较低，不建议使用。"></a>MCRYPT_MODE_OFB (output feedback, in 8bit) 和 CFB 类似。 它可以用在无法容忍加密错误传播的应用中。 因为它是按照 8 个比特位进行加密的， 所以安全系数较低，不建议使用。</h5><h5 id="MCRYPT-MODE-NOFB-output-feedback-in-nbit-和-OFB-类似，但是更加安全，-因为它可以按照算法指定的分组大小来对数据进行加密。"><a href="#MCRYPT-MODE-NOFB-output-feedback-in-nbit-和-OFB-类似，但是更加安全，-因为它可以按照算法指定的分组大小来对数据进行加密。" class="headerlink" title="MCRYPT_MODE_NOFB (output feedback, in nbit) 和 OFB 类似，但是更加安全， 因为它可以按照算法指定的分组大小来对数据进行加密。"></a>MCRYPT_MODE_NOFB (output feedback, in nbit) 和 OFB 类似，但是更加安全， 因为它可以按照算法指定的分组大小来对数据进行加密。</h5><h5 id="MCRYPT-MODE-STREAM-是一种扩展模式，-它包含了诸如-“WAKE”-或-“RC4”-的流加密算法。"><a href="#MCRYPT-MODE-STREAM-是一种扩展模式，-它包含了诸如-“WAKE”-或-“RC4”-的流加密算法。" class="headerlink" title="MCRYPT_MODE_STREAM 是一种扩展模式， 它包含了诸如 “WAKE” 或 “RC4” 的流加密算法。"></a>MCRYPT_MODE_STREAM 是一种扩展模式， 它包含了诸如 “WAKE” 或 “RC4” 的流加密算法。</h5><p>MCRYPT_ENCRYPT (integer)<br>MCRYPT_DECRYPT (integer)<br>MCRYPT_DEV_RANDOM (integer)<br>MCRYPT_DEV_URANDOM (integer)<br>MCRYPT_RAND (integer) </p>
<h5 id="mcrypt-create-iv-size-source-MCRYPT-DEV-URANDOM-从随机源创建初始向量"><a href="#mcrypt-create-iv-size-source-MCRYPT-DEV-URANDOM-从随机源创建初始向量" class="headerlink" title="mcrypt_create_iv($size,[$source= MCRYPT_DEV_URANDOM ])  从随机源创建初始向量"></a>mcrypt_create_iv($size,[$source= MCRYPT_DEV_URANDOM ])  从随机源创建初始向量</h5><p>初始向量只是为了给加密算法提供一个可用的种子，所以它不需要安全保护， 你甚至可以随同密文一起发布初始向量也不会对安全性带来影响<br>$size:初始向量大小<br>$source:初始向量数据来源<br>   MCRYPT_RAND （系统随机数生成器）<br>   MCRYPT_DEV_RANDOM （从 /dev/random 文件读取数据）  MCRYPT_DEV_URANDOM （从 /dev/urandom 文件读取数据） </p>
<p>   在Windows平台，PHP 5.3.0 之前的版本中，仅支持 MCRYPT_RAND<br>   在PHP 5.6.0之前的版本中，此参数的默认值为 MCRYPT_DEV_RANDOM</p>
<h5 id="mcrypt-encrypt-cipher-key-data-mode，-iv-加密数据"><a href="#mcrypt-encrypt-cipher-key-data-mode，-iv-加密数据" class="headerlink" title="mcrypt_encrypt($cipher,$key,$data,$mode，[$iv])  加密数据"></a>mcrypt_encrypt($cipher,$key,$data,$mode，[$iv])  加密数据</h5><h5 id="mcrypt-decrypt-cipher-key-data-mode，-iv-解密数据"><a href="#mcrypt-decrypt-cipher-key-data-mode，-iv-解密数据" class="headerlink" title="mcrypt_decrypt($cipher,$key,$data,$mode，[$iv]) 解密数据"></a>mcrypt_decrypt($cipher,$key,$data,$mode，[$iv]) 解密数据</h5><p>$clipher:MCRYPT_ciphername常量中的一个，或者是字符串值的算法名称<br>$key:数据加密密钥,如果密钥长度不是加解密算法能够支持的有效长度，那么会产生警告并且返回FALSE<br>$data:要使用给定的cipher和mode解密的数据,如果数据大小不是n * 分组大小，则在其后追加 ‘\0’ 来补齐<br>$mode:MCRYPT_MODE_modename常量中的一个，或以下字符串中的一个：”ecb”，”cbc”，”cfb”，”ofb”，”nofb” 和 “stream”<br>$iv:用于初始化在CBC、循环流化床、OFB模式，和一些算法在流模式中。<br>如果链接模式不支持提供的四大小或没有四提供，但链接模式需要一个，该函数将发出警告，并返回FALSE。</p>
<h5 id="mcrypt-enc-get-algorithms-name-td-返回打开的算法名称"><a href="#mcrypt-enc-get-algorithms-name-td-返回打开的算法名称" class="headerlink" title="mcrypt_enc_get_algorithms_name($td) 返回打开的算法名称"></a>mcrypt_enc_get_algorithms_name($td) 返回打开的算法名称</h5><h5 id="mcrypt-enc-get-block-size-td-返回打开的算法的分组大小"><a href="#mcrypt-enc-get-block-size-td-返回打开的算法的分组大小" class="headerlink" title="mcrypt_enc_get_block_size($td) 返回打开的算法的分组大小"></a>mcrypt_enc_get_block_size($td) 返回打开的算法的分组大小</h5><p>$td:加密描述符    返回指定算法的分组大小，以字节为单位。 </p>
<h5 id="mcrypt-enc-get-iv-size-td-返回打开的算法的初始向量大小"><a href="#mcrypt-enc-get-iv-size-td-返回打开的算法的初始向量大小" class="headerlink" title="mcrypt_enc_get_iv_size($td) 返回打开的算法的初始向量大小"></a>mcrypt_enc_get_iv_size($td) 返回打开的算法的初始向量大小</h5><p>返回使用的初始向量大小，以字节为单位<br>在cbc,cfb和ofb模式以及某些流模式算法中会用到初始向量<br>如果算法忽略初始向量，则返回0 </p>
<h5 id="mcrypt-enc-get-key-size-td-返回打开的模式所能支持的最长密钥"><a href="#mcrypt-enc-get-key-size-td-返回打开的模式所能支持的最长密钥" class="headerlink" title="mcrypt_enc_get_key_size($td) 返回打开的模式所能支持的最长密钥"></a>mcrypt_enc_get_key_size($td) 返回打开的模式所能支持的最长密钥</h5><h5 id="mcrypt-enc-get-modes-name-td-返回打开的模式的名称"><a href="#mcrypt-enc-get-modes-name-td-返回打开的模式的名称" class="headerlink" title="mcrypt_enc_get_modes_name($td) 返回打开的模式的名称"></a>mcrypt_enc_get_modes_name($td) 返回打开的模式的名称</h5><h5 id="mcrypt-enc-get-supported-key-sizes-td-以数组方式返回打开的算法所支持的密钥长度"><a href="#mcrypt-enc-get-supported-key-sizes-td-以数组方式返回打开的算法所支持的密钥长度" class="headerlink" title="mcrypt_enc_get_supported_key_sizes($td) 以数组方式返回打开的算法所支持的密钥长度"></a>mcrypt_enc_get_supported_key_sizes($td) 以数组方式返回打开的算法所支持的密钥长度</h5><p>$td = mcrypt_module_open(MCRYPT_CAST_256,’’,MCRYPT_MODE_CFB,’’);<br>$td = mcrypt_module_open(‘cast-256’,’’,MCRYPT_MODE_CFB,’’);<br>echo mcrypt_enc_get_algorithms_name($td);  算法名称<br>echo mcrypt_enc_get_modes_name($td);       模型名称</p>
<h5 id="mcrypt-enc-self-test-td-在打开的模块上进行自检"><a href="#mcrypt-enc-self-test-td-在打开的模块上进行自检" class="headerlink" title="mcrypt_enc_self_test($td) 在打开的模块上进行自检"></a>mcrypt_enc_self_test($td) 在打开的模块上进行自检</h5><h5 id="mcrypt-enc-is-block-algorithm-mode-td-检测打开的模式是否支持分组加密"><a href="#mcrypt-enc-is-block-algorithm-mode-td-检测打开的模式是否支持分组加密" class="headerlink" title="mcrypt_enc_is_block_algorithm_mode($td) 检测打开的模式是否支持分组加密"></a>mcrypt_enc_is_block_algorithm_mode($td) 检测打开的模式是否支持分组加密</h5><p>打开的模式的算法是否支持分组加密<br>（如果是流模式，则返回FALSE，cbc,cfb,ofb模式则返回TRUE)</p>
<h5 id="mcrypt-enc-is-block-algorithm-td-检测打开模式的算法是否为分组算法"><a href="#mcrypt-enc-is-block-algorithm-td-检测打开模式的算法是否为分组算法" class="headerlink" title="mcrypt_enc_is_block_algorithm($td) 检测打开模式的算法是否为分组算法"></a>mcrypt_enc_is_block_algorithm($td) 检测打开模式的算法是否为分组算法</h5><h5 id="mcrypt-enc-is-block-mode-td-检测打开的模式是否以分组方式输出"><a href="#mcrypt-enc-is-block-mode-td-检测打开的模式是否以分组方式输出" class="headerlink" title="mcrypt_enc_is_block_mode($td) 检测打开的模式是否以分组方式输出"></a>mcrypt_enc_is_block_mode($td) 检测打开的模式是否以分组方式输出</h5><p>打开的模式是否以分组方式输出<br>（对于cbc和ecb模式而言返回TRUE，对于cfb和流模式而言，返回FALSE）<br>如果模式以字节分组（字节块）方式输出，返回TRUE<br>如果是以字节方式输出，返回FALSE</p>
<h5 id="mcrypt-generic-init-td-key-iv-初始化加密所需的缓冲区"><a href="#mcrypt-generic-init-td-key-iv-初始化加密所需的缓冲区" class="headerlink" title="mcrypt_generic_init($td,$key,$iv) 初始化加密所需的缓冲区"></a>mcrypt_generic_init($td,$key,$iv) 初始化加密所需的缓冲区</h5><p>$key:调用 mcrypt_enc_get_key_size()函数获得的密钥最大长度,小于最大长度的数值都被视为非法参数<br>$iv:通常情况下，向量大小等于算法的分组大小，但是你应该通过 mcrypt_enc_get_iv_size()函数来获得这个值<br>在ECB模式下，初始向量会被忽略，<br>在 CFB，CBC，STREAM，nOFB 和 OFB 模式下，必须提供初始向量。<br>初始向量要求是随机的，并且是唯一的（不需要是安全的）。<br>加密和解密必须使用相同的初始向量。<br>如果你不想使用初始向量，请将其设置为全 0 值，但是不建议你这么做。 </p>
<h5 id="mcrypt-module-open-td-打开算法和模式对应的模块"><a href="#mcrypt-module-open-td-打开算法和模式对应的模块" class="headerlink" title="mcrypt_module_open($td)  打开算法和模式对应的模块"></a>mcrypt_module_open($td)  打开算法和模式对应的模块</h5><h5 id="mcrypt-generic-deinit-td-对加密模块进行清理工作"><a href="#mcrypt-generic-deinit-td-对加密模块进行清理工作" class="headerlink" title="mcrypt_generic_deinit($td) 对加密模块进行清理工作"></a>mcrypt_generic_deinit($td) 对加密模块进行清理工作</h5><p>清除缓存区，不关闭模块</p>
<h5 id="mcrypt-module-close-td-关闭模块"><a href="#mcrypt-module-close-td-关闭模块" class="headerlink" title="mcrypt_module_close($td)  关闭模块"></a>mcrypt_module_close($td)  关闭模块</h5>
    </div>
  </div>
  
    <div class="copy-right">
      <div class="markdown-body">
        <blockquote>
        
        
          本文作者 : JohnScott <br/>
        
        原文链接 : <a href="">https://github.com/liuxue5213/liuxue5213.github.io/2019/PHP%E6%96%87%E6%A1%A3/</a><br>
        版权声明 : 本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
        </blockquote>
      </div>
    </div>
  
  
  
    <div class="social-share"
  style="margin-top: -2rem"
  data-wechat-qrcode-title="<p>微信扫一扫</p>"
  data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>"
   data-sites="qzone, qq, weibo, wechat, douban, google, facebook, twitter" 
  
>
  <span style="color: #6b7487; font-size: 1.4rem;">分享到: </span>
</div>
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" async>
  

  
    <div id="reward">
  
    <p id="reward-meta">知识 & 情怀 | 二者兼得</p>
  
  <button id="reward-btn">
    
    <span>感谢您的关心</span>
  </button>
  <div id="reward-qrcode">
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/wechat.png" alt="微信扫一扫">
        <p class="qrcode-meta">微信扫一扫</p>
      </div>
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/alipay.png" alt="支付宝扫一扫">
        <p class="qrcode-meta">支付宝扫一扫</p>
      </div>
    
  </div>

</div>

<script>
  (() => {
    let button = document.querySelector('#reward-btn'),
      qrcode = document.querySelector('#reward-qrcode'),
      display = false;
    
    button.addEventListener('click', () => {
      qrcode.style.display = display ? 'none' : 'block'
      display = !display
    }, false)
  })()
</script>
  

  <div class="article-footer">
    <div class="article-meta pull-left">
      <span>
        
          <i class="iconfont icon-06tags"></i>标签: 
          
          <span class="span--tag">
            <a href="/tags/PHP/">
              #PHP
            </a>
          </span>
          
        
      </span>
    </div>
    <div class="article-meta pull-right">
    </div>
  </div>
</div>


  <aside id="sidebar">
    <p id="sidebar-header"></p>
    <ol id="sidebar-toc"></ol>
  </aside>
  <script async>setTimeout(generateToc, 10);</script>


  <nav class="post-navigation">
    
      <div class="nav-pre">
        <i class="iconfont icon-prev"></i>
        上一篇:
        <a href="/2019/%E8%87%B3%E5%96%84%E6%96%87%E5%8C%96%E7%AE%80%E4%BB%8B/" target="_self">至善文化简介</a>
      </div>
    
    
      <div class="nav-next">
        下一篇:
        <a href="/2019/%E9%86%92%E6%9D%A5%E4%B9%8B%E7%88%B1%E7%9A%84%E5%91%BC%E5%94%A4%E6%80%BB%E7%BB%93/" target="_self">醒来之爱的呼唤总结</a>
        <i class="iconfont icon-next"></i>
      </div>
    
  </nav>

  
    <a href="#comment" class="comment-anchor"></a>
<div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹 <i class="iconfont icon-footprint"></i></div>
<div id="vcomments"></div>

<script defer>
  if( true ) {
    let path = getRealPath()
    new Valine({
      el: "#vcomments",
      appId: "E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz",
      appKey: "6VNHrdDAu0JKJXxyMajHk6qD",
      notify: false,
      verify: false,
      avatar: "robohash",
      placeholder: "正确填写邮箱, 才能及时收到回复哦♪(^∇^*)",
      path
    });
  }
</script>
   

  
    <script defer>
const valineAPI = (() => {
  try {
    AV.init("E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz", "6VNHrdDAu0JKJXxyMajHk6qD");
  } catch(error) {}
  const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
      query.equalTo("identity", identity);
      query.find().then(results => {
        resolve(results.length > 0);
      }, error => reject(error));
    })
  }

  const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
      let querys = [];
      for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
      }
      query = AV.Query.or.apply(null ,querys);
    } else {
      identity = identity || getRealPath();
      query = new AV.Query("Timer");
      query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
      query.find()
      .then(results => resolve(results))
      .catch(error => reject(error))
    })
  }

  const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let Todo = AV.Object.extend('Timer');
      let todo = new Todo();
      todo.set("times", 1);
      todo.set("identity", identity);
      todo.save().then(res => resolve(true), error => reject(error));
    })
  }

  const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let query = new AV.Query('Timer');
      query.equalTo("identity", identity);
      query.find().then(todos => {
        todos.forEach(todo => {
          todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
      }).then(todos => resolve(true), error => reject(error));
    })
  }

  return {
    isExist,
    _get,
    update,
    create
  }
})()

const calcAndWriteTimes = () => {
  let isPost = true;

  let timerAllDOM = document.querySelectorAll(".article-timer");

  if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
      if(exist) {
        return valineAPI.update(identity);
      }
      return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
  }

  let timerDOMCache = {};

  for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
      timerDOMCache[identity].dom.push(timerDOM);
    }else{
      timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
      };
    }
  }

  let identities = Object.keys(timerDOMCache);
  valineAPI._get(identities).then(results => {
    for(let result of results) {
      let {identity, times} = result.attributes;
      timerDOMCache[identity].times = times;
      timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
      if(timerDOMCache[identity].times){
        continue;
      }
      timerDOMCache[identity].dom.map(item => item.innerText = 1);
      valineAPI.create(identity);
    }
  }).catch(error => console.log(error.message))
}

if(true){
  calcAndWriteTimes();
}
</script>
   

</div>


      <footer>
  <p class="site-info">
    博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span>
    <br>
    Theme - <a href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by <a target="_blank" rel="noopener" href="https://godbmw.com/">GodBMW</a>
    <br>
    
  </p>
</footer>



<script>
const timeToNowDOM = document.querySelector("#time-to-now");
const startTimestamp = new Date(2015, 0, 1).getTime();

const updateTimeStr = () => {
  let offset = parseInt(
      (new Date().getTime() - startTimestamp) / 1000,
      10
    ),
    day = Math.floor(offset / 86400),
    hour = Math.floor((offset % 86400) / 3600),
    minute = Math.floor(((offset % 86400) % 3600) / 60),
    second = Math.floor(((offset % 86400) % 3600) % 60);
  timeToNowDOM.innerHTML =
    day + "天" + hour + "小时" + minute + "分钟" + second + "秒";
  setTimeout(updateTimeStr, 500);
}

setTimeout(updateTimeStr, 500);
</script>


      <div class="back-to-top hidden">
  <span>
    <i class="iconfont icon-60"></i><span></span>%
  </span>
</div>

<script>
const updateIconToTop = percent => {
  let dom = document.querySelector(".back-to-top span span");
  dom.innerText = percent;
  if(percent < 1) {
    document.querySelector(".back-to-top").className = "back-to-top hidden";
  } else {
    document.querySelector(".back-to-top").className = "back-to-top";
  }
}

const handleScoll = () => {
  let isRunning = false;
  return () => {
    if (isRunning) return;
    isRunning = true;
    window.requestAnimationFrame(timestamp => {
      let scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop,
        scrollHeight =
          document.documentElement.scrollHeight ||
          document.body.scrollHeight,
        clientHeight =
          document.documentElement.clientHeight ||
          document.body.clientHeight;
      isRunning = false;
      if (scrollTop <= 1) {
        updateIconToTop(0);
        return;
      }
      if (scrollTop + clientHeight >= scrollHeight) {
        updateIconToTop(100);
      } else {
        updateIconToTop(parseInt(
          100 * scrollTop / (scrollHeight - clientHeight),
          10
        ));
      }
    });
  };
}

const backToTop = () => {
  let scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop,
    delay = 10,
    time = 200;
  if (scrollTop <= 20) {
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    return;
  }
  let step = Math.ceil(scrollTop * delay / time);
  let timer = setInterval(() => {
    scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop;
    if (scrollTop - step <= 0) {
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      clearInterval(timer);
    } else {
      document.documentElement.scrollTop = scrollTop - step;
      document.body.scrollTop = scrollTop - step;
    }
  }, delay);
}

document.addEventListener("scroll", handleScoll(), false);

document.querySelector(".back-to-top").addEventListener("click", backToTop, false);

</script>

    </div>

    
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  (() => {
    const mathjaxConfig = {
      showProcessingMessages: false, //关闭js加载过程信息
      messageStyle: "none", //不显示信息
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
        displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], //可选字体
        showMathMenu: false //关闭右击菜单显示
      }
    }

    let mathjaxInterval = setInterval(() => {
      if(!window.MathJax){
        return;
      }
      window.MathJax.Hub.Config(mathjaxConfig)
      window.MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('app')])

      clearInterval(mathjaxInterval)
    }, 10)    
  })()
</script>
    

    <script src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script>
<script async>
  let fancyTimer = setInterval(function(){
    if(!window.$){
      return;
    }
    $(document).ready(function() {
      $(".post img").each(function () {
        if($(this).parent().get(0).tagName.toLowerCase() === "a") {
          return;
        }
        // $(this).attr("data-fancybox", "gallery"); // if you add 'data-fancybox', img will display after showed
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "gallery");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      });
      
      clearInterval(fancyTimer);
    });
  }, 10);
</script>

    
  </body>

</html>
