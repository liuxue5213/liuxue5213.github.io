<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta name="author" content="johnscott" />
  
  
  
  <title>MYSQL数据库优化方法 | JohnScott2046的博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="数据库,MYSQL," />
  

  <script>
    console.log('\n%c Hexo-theme-bmw v4.0 ' + '%c 🎉 https://github.com/dongyuanxin/theme-bmw 🎉\n' + '\n%c View demo online ' + '%c 🔍 https://godbmw.com/ 🔍  \n' , 'color: #fadfa3; background: #030307; padding:3px 0;', '', 'color: #fadfa3; background: #030307; padding:3px 0;', '');
  </script>

  
    <meta name="description" content="超级帽子戏法的个人博客,主要记录复制粘贴过来的笔记,还有自己的一些心得体会">
  

  

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/icon/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  
<script src="/js/util.js"></script>
<script src="/js/valine.min.js"></script>


  

  
    <link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js" async></script>
  

  
    <link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">
  
  
  <script src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js" async></script>
  
  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script>
  

<meta name="generator" content="Hexo 5.1.1"></head>

  <body>

    

    <div id="app">

      <div class="header-wrap">
  <header>
    <div class="site-brand">
      <div class="site-title">
        <a href="/">JohnScott2046</a>
      </div>
    </div>
    <nav class="site-navigation">
      <ul class="nav-menu">
      
        <li class="nav-item" data-path="/">
          
            <a 
              href="/"
              target="_self"
            >
              主页
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/archives/">
          
            <a 
              href="/archives/"
              target="_self"
            >
              归档
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/categories/">
          
            <a 
              href="/categories/"
              target="_self"
            >
              分类
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/tags/">
          
            <a 
              href="/tags/"
              target="_self"
            >
              标签
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/friends/">
          
            <a 
              href="/friends/"
              target="_self"
            >
              友链
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/about/">
          
            <a 
              href="/about/"
              target="_self"
            >
              关于
            </a>
          
        </li>
      
        <li class="nav-item" data-path="">
          
            <a href="javascript:void(0);" v-else>联系我</a>
            <ul class="nav-menu--dropdown">
              
                <li>
                  <a 
                    href="https://github.com/liuxue5213" 
                    target="_blank"
                  >
                    Github
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.zhihu.com/people/liuxue5213" 
                    target="_blank"
                  >
                    知乎
                  </a>
                </li>
              
                <li>
                  <a 
                    href="http://weibo.com/liuxue5213" 
                    target="_blank"
                  >
                    微博
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.douban.com/people/liuxue5213" 
                    target="_blank"
                  >
                    豆瓣
                  </a>
                </li>
              
                <li>
                  <a 
                    href="/linkedin.com/in/liuxue5213" 
                    target="_blank"
                  >
                    linkedin
                  </a>
                </li>
              
            </ul>
          
        </li>
      
      </ul>
    </nav>
    <i class="iconfont icon-menu"></i>
  </header>
</div>

<script>
  let links = document.querySelectorAll('.nav-item');
  for(let link of links){
    let childrenLink = link.querySelector('ul');
    link.addEventListener('mouseenter', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown active";
      }
    })
    link.addEventListener('mouseleave', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown";
      }
    })
  }
  let rootRealPath = getRealPath(window.location.pathname, true);
  for(let link of links) {
    let linkPath = link.getAttribute("data-path");
    if(linkPath && getRealPath(linkPath, true) === rootRealPath) {
      link.className = "nav-item hover";
    }
  }

  let iconMenu = document.querySelector("i.iconfont.icon-menu"),
    iconMenuClicked = false;
  let navDOM = document.querySelector("nav.site-navigation");
  iconMenu.addEventListener("click", () => {
    iconMenuClicked 
      ? navDOM.className = "site-navigation active"
      : navDOM.className = "site-navigation";
    iconMenuClicked = !iconMenuClicked;
  })
</script>

      








<div class="container post-index">

  

<div class="post">
  <h1 class="article-title">
    <span>MYSQL数据库优化方法</span>
  </h1>
  <div class="article-top-meta">
    <span>
      发布 : 
      2014-10-17
    </span>
    
      <span>
        分类 : 
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">
            数据库
          </a>
      </span>
    
    
      <span>
        浏览 : <span class="article-timer" data-identity="MYSQL数据库优化方法"></span>
      </span>
    
  </div>

  

  <div class="article-content">
    <div class="markdown-body">
      <h3 id="myisam"><a href="#myisam" class="headerlink" title="myisam"></a>myisam</h3><p>myisam 读性能》innodb<br>myisam索引数据分开 索引有压缩<br>可以直接覆盖MYD/MYI文件恢复数据</p>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>count(<em>)  order by效率低  count(</em>)会锁表<br>innodb的insert update速度太快  会导致从库数据跟不上<br>myisam有merge类型  可以快读count(<em>)<br>没有索引时 count(</em>) order by效率低  不区分引擎<br>事务表 全表在没有where条件时 count(*) 会慢  但并不会锁表</p>
<h3 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h3><p>95%以上的场景 使用innodb<br>可以把数据、索引、有修改的数据放在内存buffer中，有自适应哈希索引、change buffer merge等 更加高效</p>
<h3 id="使用innodb好处"><a href="#使用innodb好处" class="headerlink" title="使用innodb好处"></a>使用innodb好处</h3><p>完整的事物特性  更高并发TPS<br>支持crash recovery  myisam不能自动修复 耗时更久<br>读取效率更高 innodb把数据、索引同事缓存在buffer中 myisam之缓存索引</p>
<p>innodb基于B+树结构的聚集索引组织表<br>表数据的逻辑存储顺序取决于聚集索引的顺序<br>默认选择主键作为聚集索引 无合适主键时 会用内置的row_id作为聚集索引<br>innodb的行锁是加在索引上的</p>
<p>innodb表都有一个主键  尽量不修改主键值 没有业务用途<br>主键保持顺序递增 随机主键会导致聚集索引树频繁分裂 随机I/O增多 数据离散 性能下降<br>若无特殊需要 要开启自动提交autocommit=1<br>定义列属性时 长度够用即可  varchar text 实际存储数据长度越小越好  否则发生行溢出时对性能影响很大<br>使用select * 读取全部列 可能会导致更多I/O</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>使用联合索引  k1(c1,c2,c3)<br>inner join自动选择join顺序<br>straight join   都是强制左边的表作为驱动表<br>多表join中 排序列如果不属于驱动表 则无法利用索引完成排序</p>
<p>RAID配置<br>    RAID-10<br>    CACHE &amp; BBU<br>    WB &amp; FORCE WB<br>使用PCIe-SSD等高速I/O设备 提高IOPS能力<br>换SSD PCIe-SSD<br>少做I/O 合并多次读写为一次 或者加内存CACHE 优化业务<br>加大内存 减少物理IO<br>调整文件系统为XFS(相比ext3、ext4提高IOPS能力 高IO负载下表现更好)<br>调整raid级别为raid 1+0（相比raid1 raid5等提高IOPS能力）<br>调整写cache策略为wb或者force wb<br>io scheduler(优先使用deadline SSD使用noop)</p>
<h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><p>innodb_buffer_pool_size 约物理内存的50%-70%<br>innodb_data_file_path 初始化大小至少1G<br>5.6以上版本 设置独立undo表空间<br>innodb_log_file_size 5.5以上1G 5.5以下不超512M<br>innodb_max_dirty_pages_pct 25%-50%<br>innodb_io_capacity 普通机械盘=》1000左右 SSD=》10000左右<br>PCIe_SSD=》20000以上</p>
<h3 id="MySQL参数优化"><a href="#MySQL参数优化" class="headerlink" title="MySQL参数优化"></a>MySQL参数优化</h3><p>key_buffer_size 32M以下<br>sync_binlog<br>0=&gt;最快数据最不安全 系统自己决定刷新binlog频率<br>1=》最慢最安全 每个event刷新一次<br>N=》每N个事物刷新一次<br>long_query_time 小于0.5秒<br>open_files_limit innodb_open_file  建议65535<br>max_connections 突发连接数的80% 过大容易卡死<br>thread_handing=”pool-of-thread” 启用线程池<br>query_cache_size &amp; query_cache_type 关闭</p>
<p>query cache 最好关闭 效果不大<br>是全局锁 每次更新QC的内存块锁代价高 容易出现waiting for query cache lock状态<br>query_cache_size=0 &amp; query_cache_type=0 关闭</p>
<h3 id="ibdata1文件存储内容"><a href="#ibdata1文件存储内容" class="headerlink" title="ibdata1文件存储内容"></a>ibdata1文件存储内容</h3><p>data dictionary<br>double write<br>insert buffer<br>rollback segments<br>undo space<br>foreign key constraint system tables</p>
<h3 id="ibdata1文件暴增原因"><a href="#ibdata1文件暴增原因" class="headerlink" title="ibdata1文件暴增原因"></a>ibdata1文件暴增原因</h3><p>大量事务 产生大量的undo log<br>大量旧事务长时间没有提交  产生旧undo log<br>file I/O性能差 purge进度慢<br>32bit系统下有bug</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>升级到5.6以上（64bit） 采用独立undo表空间<br>增加purge线程数 innodb_purge_threads<br>提高file I/O能力<br>事务及时提交<br>默认打开autocommit=1<br>检查开发框架 确认ac=0地方 事务的结束都有提交或回滚</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>where phone=13000000000<br>改成where phone=’13000000000’<br>或 列类型改成bigint unsigned</p>
<h3 id="连接数过高"><a href="#连接数过高" class="headerlink" title="连接数过高"></a>连接数过高</h3><p>too many connections的处理<br>消除多余的连接  加大连接数<br>限制连接数 max_user_connctions<br>定时检查 消除慢查询 避免阻塞 </p>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>从mysqldump(字符集)=》xtrabackup(混合引擎)<br>自动备份 检查 恢复</p>
<p>高可用、故障转移<br>双机+keepalived高可用<br>多机MHA高可用(节点多)<br>备份异地机房(成本高)<br>利用延迟复制特性 预防严重误操作</p>
<h3 id="表数据十万到千万"><a href="#表数据十万到千万" class="headerlink" title="表数据十万到千万"></a>表数据十万到千万</h3><p>10万 简单的索引<br>100万 需要考虑DDL风险 超过1秒的sql<br>1000万 怎样做备份 上线前预先解析sql 预防严重更新问题<br>监视超过N秒的SQL 能自动处理 报警<br>大量数据下 优先冷热数据分离或归档  适当的分库分表<br>pt-query-digest + anemometer</p>
<h3 id="大量日志存储"><a href="#大量日志存储" class="headerlink" title="大量日志存储"></a>大量日志存储</h3><p>入库优先用tokudb引擎<br>历史归档导入大数据分析平台<br>历史表可以按时间段分表(分区)<br>定期创建、删除、归档分表(分区)</p>
<h3 id="5-7重大变化"><a href="#5-7重大变化" class="headerlink" title="5.7重大变化"></a>5.7重大变化</h3><p>innodb monitor table功能<br>用innodb_status_oupput、innodb_status_oupput_locks开关<br>old-password格式  不安全<br>skip-innodb  不能禁用innodb了</p>
<h3 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h3><p>安全性提升 强化账户管理及密码策略<br>    初始化安装默认会设置随机密码(首次登陆修改)<br>    初始化随机密码保存在error log中<br>    只有root@localhost账号 没有匿名账号<br>新账号创建后密码默认有过期时间<br>    5.7.10前默认365天 后默认0 无限<br>支持ssl/tls链接方式<br>标准化提升 不兼容一些不规范用法<br>    默认启用strict_trans_tables、no_zero_in_date、error_for_division_bu_zero等几种规则 （例如:向char(20)写入30字符  报错）<br>功能性提升<br>    online ddl增强<br>        innodb引擎在线调整varchar长度<br>        增加、修改非主键列瞬间完成<br>        修改索引名(非主键)<br>    innodb buffer pool管理增强<br>        在线动态调整<br>        导入导出增强<br>性能大幅提升<br>    innodb对fusion-io non-volatile memory（nvm）原生支持<br>    innodb索引创建、重建批量加载 提高效率<br>    optimizer hints<br>    重写了大部分解析器 优化器 成本模型<br>    innodb制度事务性能提升<br>    改进innodb的可扩展性和临时表的性能<br>复制功能提升<br>    并行复制提升<br>    多源复制<br>    在线修改replication filter<br>    在线启用GTIDs 增强半同步复制<br>    支持Group Replication<br>新特性<br>    mysql router<br>    支持generated columns<br>    支持json<br>    增加sys schema<br>    支持多个tigger<br>    支持GIS</p>
<h3 id="WHERE字句的查询条件里有不等于号（WHERE-column-…），MYSQL将无法使用索引"><a href="#WHERE字句的查询条件里有不等于号（WHERE-column-…），MYSQL将无法使用索引" class="headerlink" title="WHERE字句的查询条件里有不等于号（WHERE column!=…），MYSQL将无法使用索引"></a>WHERE字句的查询条件里有不等于号（WHERE column!=…），MYSQL将无法使用索引</h3><h3 id="类似地，如果WHERE字句的查询条件里使用了函数（如：WHERE-DAY-column-…），MYSQL将无法使用索引"><a href="#类似地，如果WHERE字句的查询条件里使用了函数（如：WHERE-DAY-column-…），MYSQL将无法使用索引" class="headerlink" title="类似地，如果WHERE字句的查询条件里使用了函数（如：WHERE DAY(column)=…），MYSQL将无法使用索引"></a>类似地，如果WHERE字句的查询条件里使用了函数（如：WHERE DAY(column)=…），MYSQL将无法使用索引</h3><h3 id="在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用"><a href="#在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用" class="headerlink" title="在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用"></a>在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用</h3><h3 id="如果WHERE子句的查询条件里使用了比较操作符LIKE和REGEXP，MYSQL只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。比如说，如果查询条件是LIKE-‘abc-’-MYSQL将使用索引；如果条件是LIKE-‘-abc’，MYSQL将不使用索引。"><a href="#如果WHERE子句的查询条件里使用了比较操作符LIKE和REGEXP，MYSQL只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。比如说，如果查询条件是LIKE-‘abc-’-MYSQL将使用索引；如果条件是LIKE-‘-abc’，MYSQL将不使用索引。" class="headerlink" title="如果WHERE子句的查询条件里使用了比较操作符LIKE和REGEXP，MYSQL只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。比如说，如果查询条件是LIKE ‘abc%’,MYSQL将使用索引；如果条件是LIKE ‘%abc’，MYSQL将不使用索引。"></a>如果WHERE子句的查询条件里使用了比较操作符LIKE和REGEXP，MYSQL只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。比如说，如果查询条件是LIKE ‘abc%’,MYSQL将使用索引；如果条件是LIKE ‘%abc’，MYSQL将不使用索引。</h3><h3 id="在ORDER-BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER-BY操作方面也没什么作用。"><a href="#在ORDER-BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER-BY操作方面也没什么作用。" class="headerlink" title="在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER BY操作方面也没什么作用。"></a>在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER BY操作方面也没什么作用。</h3><h3 id="如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0-1”或“Y-N”等值，就没有必要为它创建一个索引。"><a href="#如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0-1”或“Y-N”等值，就没有必要为它创建一个索引。" class="headerlink" title="如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0/1”或“Y/N”等值，就没有必要为它创建一个索引。"></a>如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0/1”或“Y/N”等值，就没有必要为它创建一个索引。</h3><h3 id="索引有用的情况下就太多了。基本只要建立了索引，除了上面提到的索引不会使用的情况下之外，其他情况只要是使用在WHERE条件里，ORDER-BY-字段，联表字段，一般都是有效的。-建立索引要的就是有效果。-不然还用它干吗？-如果不能确定在某个字段上建立的索引是否有效果，只要实际进行测试下比较下执行时间就知道。"><a href="#索引有用的情况下就太多了。基本只要建立了索引，除了上面提到的索引不会使用的情况下之外，其他情况只要是使用在WHERE条件里，ORDER-BY-字段，联表字段，一般都是有效的。-建立索引要的就是有效果。-不然还用它干吗？-如果不能确定在某个字段上建立的索引是否有效果，只要实际进行测试下比较下执行时间就知道。" class="headerlink" title="索引有用的情况下就太多了。基本只要建立了索引，除了上面提到的索引不会使用的情况下之外，其他情况只要是使用在WHERE条件里，ORDER BY 字段，联表字段，一般都是有效的。 建立索引要的就是有效果。 不然还用它干吗？ 如果不能确定在某个字段上建立的索引是否有效果，只要实际进行测试下比较下执行时间就知道。"></a>索引有用的情况下就太多了。基本只要建立了索引，除了上面提到的索引不会使用的情况下之外，其他情况只要是使用在WHERE条件里，ORDER BY 字段，联表字段，一般都是有效的。 建立索引要的就是有效果。 不然还用它干吗？ 如果不能确定在某个字段上建立的索引是否有效果，只要实际进行测试下比较下执行时间就知道。</h3><h3 id="如果条件中有or-并且其中有or的条件是不带索引的-，即使其中有条件带索引也不会使用-这也是为什么尽量少用or的原因-。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引"><a href="#如果条件中有or-并且其中有or的条件是不带索引的-，即使其中有条件带索引也不会使用-这也是为什么尽量少用or的原因-。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引" class="headerlink" title="如果条件中有or(并且其中有or的条件是不带索引的)，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引"></a>如果条件中有or(并且其中有or的条件是不带索引的)，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</h3><h3 id="如果列类型是字符串，那一定要在条件中将数据使用引号引用起来-否则不使用索引"><a href="#如果列类型是字符串，那一定要在条件中将数据使用引号引用起来-否则不使用索引" class="headerlink" title="如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引"></a>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</h3><h3 id="如果mysql估计使用全表扫描要比使用索引快-则不使用索引"><a href="#如果mysql估计使用全表扫描要比使用索引快-则不使用索引" class="headerlink" title="如果mysql估计使用全表扫描要比使用索引快,则不使用索引"></a>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</h3><h3 id="对查询进行优化，应尽量避免全表扫描，首先应考虑在-where-及-order-by-涉及的列上建立索引。"><a href="#对查询进行优化，应尽量避免全表扫描，首先应考虑在-where-及-order-by-涉及的列上建立索引。" class="headerlink" title="对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。"></a>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</h3><h3 id="应尽量避免在-where-子句中对字段进行-null-值判断，否则将导致引擎放弃使用索引而进行全表扫描，"><a href="#应尽量避免在-where-子句中对字段进行-null-值判断，否则将导致引擎放弃使用索引而进行全表扫描，" class="headerlink" title="应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，"></a>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num is null;</span><br></pre></td></tr></table></figure>
<p>可以在 num 上设置默认值 0,确保表中 num 列没有 null 值，然后这样查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;0;</span><br></pre></td></tr></table></figure>

<h3 id="应尽量避免在-where-子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。"><a href="#应尽量避免在-where-子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。" class="headerlink" title="应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。"></a>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</h3><h3 id="应尽量避免在-where-子句中使用-or-来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，"><a href="#应尽量避免在-where-子句中使用-or-来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，" class="headerlink" title="应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，"></a>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;10 or num&#x3D;20;</span><br></pre></td></tr></table></figure>

<p>可以这样查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;10 union all select id from t where num&#x3D;20;</span><br></pre></td></tr></table></figure>

<h3 id="in-和-not-in-也要慎用，否则会导致全表扫描，如："><a href="#in-和-not-in-也要慎用，否则会导致全表扫描，如：" class="headerlink" title="in 和 not in 也要慎用，否则会导致全表扫描，如："></a>in 和 not in 也要慎用，否则会导致全表扫描，如：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num in(1,2,3);</span><br></pre></td></tr></table></figure>

<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num between 1 and 3;</span><br></pre></td></tr></table></figure>

<h3 id="下面的查询也将导致全表扫描："><a href="#下面的查询也将导致全表扫描：" class="headerlink" title="下面的查询也将导致全表扫描："></a>下面的查询也将导致全表扫描：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &#39;c%&#39;;</span><br></pre></td></tr></table></figure>
<p>若要提高效率，可以考虑全文检索。</p>
<h3 id="如果在-where-子句中使用参数，也会导致全表扫描。因为-SQL-只有在运行时才会解析局部变量，但优-化程序不能将访问计划的选择推迟到运行时-它必须在编译时进行选择。然-而，如果在编译时建立访问计-划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描："><a href="#如果在-where-子句中使用参数，也会导致全表扫描。因为-SQL-只有在运行时才会解析局部变量，但优-化程序不能将访问计划的选择推迟到运行时-它必须在编译时进行选择。然-而，如果在编译时建立访问计-划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：" class="headerlink" title="如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优 化程序不能将访问计划的选择推迟到运行时;它必须在编译时进行选择。然 而，如果在编译时建立访问计 划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描："></a>如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优 化程序不能将访问计划的选择推迟到运行时;它必须在编译时进行选择。然 而，如果在编译时建立访问计 划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;@num ;</span><br></pre></td></tr></table></figure>

<p>可以改为强制查询使用索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t with(index(索引名)) where num&#x3D;@num ;</span><br></pre></td></tr></table></figure>

<h3 id="应尽量避免在-where-子句中对字段进行表达式操作，-这将导致引擎放弃使用索引而进行全表扫描。"><a href="#应尽量避免在-where-子句中对字段进行表达式操作，-这将导致引擎放弃使用索引而进行全表扫描。" class="headerlink" title="应尽量避免在 where 子句中对字段进行表达式操作， 这将导致引擎放弃使用索引而进行全表扫描。"></a>应尽量避免在 where 子句中对字段进行表达式操作， 这将导致引擎放弃使用索引而进行全表扫描。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x2F;2&#x3D;100;</span><br></pre></td></tr></table></figure>

<p>可以这样查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num&#x3D;100*2;</span><br></pre></td></tr></table></figure>

<h3 id="应尽量避免在-where-子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如："><a href="#应尽量避免在-where-子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：" class="headerlink" title="应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如："></a>应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#name 以 abc 开头的 id</span><br><span class="line">select id from t where substring(name,1,3)&#x3D;&#39;abc&#39;;</span><br></pre></td></tr></table></figure>

<p>应改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &#39;abc%&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="不要在-where-子句中的“-”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用-索引。"><a href="#不要在-where-子句中的“-”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用-索引。" class="headerlink" title="不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用 索引。"></a>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用 索引。</h3><h3 id="在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件-时才能保证系统使用该索引，-否则该索引将不会-被使用，-并且应尽可能的让字段顺序与索引顺序相一致。"><a href="#在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件-时才能保证系统使用该索引，-否则该索引将不会-被使用，-并且应尽可能的让字段顺序与索引顺序相一致。" class="headerlink" title="在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件 时才能保证系统使用该索引， 否则该索引将不会 被使用， 并且应尽可能的让字段顺序与索引顺序相一致。"></a>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件 时才能保证系统使用该索引， 否则该索引将不会 被使用， 并且应尽可能的让字段顺序与索引顺序相一致。</h3><h3 id="不要写一些没有意义的查询，如需要生成一个空表结构："><a href="#不要写一些没有意义的查询，如需要生成一个空表结构：" class="headerlink" title="不要写一些没有意义的查询，如需要生成一个空表结构："></a>不要写一些没有意义的查询，如需要生成一个空表结构：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1,col2 into #t from t where 1&#x3D;0;</span><br></pre></td></tr></table></figure>

<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table #t(…);</span><br></pre></td></tr></table></figure>

<h3 id="很多时候用-exists-代替-in-是一个好的选择："><a href="#很多时候用-exists-代替-in-是一个好的选择：" class="headerlink" title="很多时候用 exists 代替 in 是一个好的选择："></a>很多时候用 exists 代替 in 是一个好的选择：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where num in(select num from b);</span><br></pre></td></tr></table></figure>

<p>用下面的语句替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where exists(select 1 from b where num&#x3D;a.num);</span><br></pre></td></tr></table></figure>

<h3 id="并不是所有索引对查询都有效，SQL-是根据表中数据来进行查询优化的，当索引列有大量数据重复时，-SQL-查询可能不会去利用索引，如一表中有字段-male、female-几乎各一半，那么即使在-上建-了索引也对查询效率起不了作用。"><a href="#并不是所有索引对查询都有效，SQL-是根据表中数据来进行查询优化的，当索引列有大量数据重复时，-SQL-查询可能不会去利用索引，如一表中有字段-male、female-几乎各一半，那么即使在-上建-了索引也对查询效率起不了作用。" class="headerlink" title="并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时， SQL 查询可能不会去利用索引，如一表中有字段 *,male、female 几乎各一半，那么即使在 * 上建 了索引也对查询效率起不了作用。"></a>并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时， SQL 查询可能不会去利用索引，如一表中有字段 <strong>*,male、female 几乎各一半，那么即使在 *</strong> 上建 了索引也对查询效率起不了作用。</h3><h3 id="索引并不是越多越好，索引固然可以提高相应的-select-的效率，但同时也降低了-insert-及-update-的效率，因为-insert-或-update-时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过-6-个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。"><a href="#索引并不是越多越好，索引固然可以提高相应的-select-的效率，但同时也降低了-insert-及-update-的效率，因为-insert-或-update-时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过-6-个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。" class="headerlink" title="索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。"></a>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</h3><h3 id="应尽可能的避免更新-clustered-索引数据列，-因为-clustered-索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新-clustered-索引数据列，那么需要考虑是否应将该索引建为-clustered-索引。"><a href="#应尽可能的避免更新-clustered-索引数据列，-因为-clustered-索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新-clustered-索引数据列，那么需要考虑是否应将该索引建为-clustered-索引。" class="headerlink" title="应尽可能的避免更新 clustered 索引数据列， 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。"></a>应尽可能的避免更新 clustered 索引数据列， 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</h3><h3 id="尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并-会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言-只需要比较一次就够了。"><a href="#尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并-会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言-只需要比较一次就够了。" class="headerlink" title="尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并 会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言 只需要比较一次就够了。"></a>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并 会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言 只需要比较一次就够了。</h3><h3 id="尽可能的使用-varchar-nvarchar-代替-char-nchar-因为首先变长字段存储空间小，-可以节省存储空间，-其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。"><a href="#尽可能的使用-varchar-nvarchar-代替-char-nchar-因为首先变长字段存储空间小，-可以节省存储空间，-其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。" class="headerlink" title="尽可能的使用 varchar/nvarchar 代替 char/nchar , 因为首先变长字段存储空间小， 可以节省存储空间， 其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。"></a>尽可能的使用 varchar/nvarchar 代替 char/nchar , 因为首先变长字段存储空间小， 可以节省存储空间， 其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</h3><h3 id="任何地方都不要使用select-from-t-用具体的字段列表代替-不要返回用不到的任何字段。"><a href="#任何地方都不要使用select-from-t-用具体的字段列表代替-不要返回用不到的任何字段。" class="headerlink" title="任何地方都不要使用select * from t ,用具体的字段列表代替*,不要返回用不到的任何字段。"></a>任何地方都不要使用<code>select * from t</code> ,用具体的字段列表代替<code>*</code>,不要返回用不到的任何字段。</h3><h3 id="尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限-只有主键索引-。"><a href="#尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限-只有主键索引-。" class="headerlink" title="尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限(只有主键索引)。"></a>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限(只有主键索引)。</h3><h3 id="避免频繁创建和删除临时表，以减少系统表资源的消耗。"><a href="#避免频繁创建和删除临时表，以减少系统表资源的消耗。" class="headerlink" title="避免频繁创建和删除临时表，以减少系统表资源的消耗。"></a>避免频繁创建和删除临时表，以减少系统表资源的消耗。</h3><h3 id="临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用-表中的某个数据集时。但是，对于一次性事件，-最好使用导出表。"><a href="#临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用-表中的某个数据集时。但是，对于一次性事件，-最好使用导出表。" class="headerlink" title="临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用 表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。"></a>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用 表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</h3><h3 id="在新建临时表时，如果一次性插入数据量很大，那么可以使用select-into-代替create-table避免造成大量-log-以提高速度-如果数据量不大，为了缓和系统表的资源，应先create-table然后-insert"><a href="#在新建临时表时，如果一次性插入数据量很大，那么可以使用select-into-代替create-table避免造成大量-log-以提高速度-如果数据量不大，为了缓和系统表的资源，应先create-table然后-insert" class="headerlink" title="在新建临时表时，如果一次性插入数据量很大，那么可以使用select into 代替create table避免造成大量 log ,以提高速度;如果数据量不大，为了缓和系统表的资源，应先create table然后 insert"></a>在新建临时表时，如果一次性插入数据量很大，那么可以使用<code>select into</code> 代替<code>create table</code>避免造成大量 log ,以提高速度;如果数据量不大，为了缓和系统表的资源，应先<code>create table</code>然后 insert</h3><h3 id="如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，-先truncate-table-然后drop-table-这样可以避免系统表的较长时间锁定。"><a href="#如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，-先truncate-table-然后drop-table-这样可以避免系统表的较长时间锁定。" class="headerlink" title="如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除， 先truncate table,然后drop table,这样可以避免系统表的较长时间锁定。"></a>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除， 先<code>truncate table</code>,然后<code>drop table</code>,这样可以避免系统表的较长时间锁定。</h3><h3 id="尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过-1-万行，那么就应该考虑改写。"><a href="#尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过-1-万行，那么就应该考虑改写。" class="headerlink" title="尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。"></a>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。</h3><h3 id="使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。"><a href="#使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。" class="headerlink" title="使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。"></a>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</h3><h3 id="与临时表一样，游标并不是不可使用。对小型数据集使用FAST-FORWARD游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。"><a href="#与临时表一样，游标并不是不可使用。对小型数据集使用FAST-FORWARD游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。" class="headerlink" title="与临时表一样，游标并不是不可使用。对小型数据集使用FAST_FORWARD游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。"></a>与临时表一样，游标并不是不可使用。对小型数据集使用<code>FAST_FORWARD</code>游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</h3><h3 id="在所有的存储过程和触发器的开始处设置SET-NOCOUNT-ON-在结束时设置SET-NOCOUNT-OFF无需在执行存储过程和触发器的每个语句后向客户端发送DONE-IN-PROC消息。"><a href="#在所有的存储过程和触发器的开始处设置SET-NOCOUNT-ON-在结束时设置SET-NOCOUNT-OFF无需在执行存储过程和触发器的每个语句后向客户端发送DONE-IN-PROC消息。" class="headerlink" title="在所有的存储过程和触发器的开始处设置SET NOCOUNT ON,在结束时设置SET NOCOUNT OFF无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC消息。"></a>在所有的存储过程和触发器的开始处设置<code>SET NOCOUNT ON</code>,在结束时设置<code>SET NOCOUNT OFF</code>无需在执行存储过程和触发器的每个语句后向客户端发送<code>DONE_IN_PROC</code>消息。</h3><h3 id="尽量避免大事务操作，提高系统并发能力。-sql-优化方法使用索引来更快地遍历表。-缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说："><a href="#尽量避免大事务操作，提高系统并发能力。-sql-优化方法使用索引来更快地遍历表。-缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说：" class="headerlink" title="尽量避免大事务操作，提高系统并发能力。 sql 优化方法使用索引来更快地遍历表。 缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说："></a>尽量避免大事务操作，提高系统并发能力。 sql 优化方法使用索引来更快地遍历表。 缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说：</h3><ol>
<li><p>有大量重复值、且经常有范围查询(&lt;, &lt;=, &gt;=, &gt;)和 order by、group by 发生的列，可考虑建立集群索引;</p>
</li>
<li><p>经常同时存取多列，且每列都含有重复值可考虑建立组合索引;</p>
</li>
<li><p>组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但 不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就 要做相应的更新工作。</p>
</li>
</ol>
<h3 id="定期分析表和检查表。"><a href="#定期分析表和检查表。" class="headerlink" title="定期分析表和检查表。"></a>定期分析表和检查表。</h3><h4 id="分析表的语法："><a href="#分析表的语法：" class="headerlink" title="分析表的语法："></a>分析表的语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb1_name[, tbl_name]...</span><br></pre></td></tr></table></figure>
<p>以上语句用于分析和存储表的关键字分布，分析的结果将可以使得系统得到准确的统计信息，使得SQL能够生成正确的执行计划。如果用户感觉实际执行计划并不是预期的执行计划，执行一次分析表可能会解决问题。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM，DBD和InnoDB表有作用。</p>
<p>例如分析一个数据表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table table_name</span><br></pre></td></tr></table></figure>

<h4 id="检查表的语法："><a href="#检查表的语法：" class="headerlink" title="检查表的语法："></a>检查表的语法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECK TABLE tb1_name[,tbl_name]...[option]...option &#x3D; &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br></pre></td></tr></table></figure>

<p>检查表的作用是检查一个或多个表是否有错误，<code>CHECK TABLE</code> 对MyISAM 和 InnoDB表有作用，对于MyISAM表，关键字统计数据被更新</p>
<p><code>CHECK TABLE</code> 也可以检查视图是否有错误，比如在视图定义中被引用的表不存在。</p>
<h3 id="定期优化表"><a href="#定期优化表" class="headerlink" title="定期优化表"></a>定期优化表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb1_name [,tbl_name]...</span><br></pre></td></tr></table></figure>

<p>如果删除了表的一大部分，或者如果已经对含有可变长度行的表(含有 VARCHAR、BLOB或TEXT列的表)进行更多更改，则应使用OPTIMIZE TABLE命令来进行表优化。这个命令可以将表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费，但OPTIMIZE TABLE 命令只对MyISAM、 BDB 和InnoDB表起作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimize table table_name</span><br></pre></td></tr></table></figure>
<p>注意： analyze、check、optimize执行期间将对表进行锁定，因此一定注意要在MySQL数据库不繁忙的时候执行相关的操作。</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p>1、在海量查询时尽量少用格式转换。<br>2、ORDER BY 和 GROPU BY:使用 ORDER BY 和 GROUP BY 短语，任何一种索引都有助于 SELECT 的性能提高。<br>3、任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移 至等号右边。<br>4、IN、OR 子句常会使用工作表，使索引失效。如果不产生大量重复值，可以考虑把子句拆开。拆开的子 句中应该包含索引。<br>5、只要能满足你的需求，应尽可能使用更小的数据类型：例如使用 MEDIUMINT 代替 INT<br>6、尽量把所有的列设置为 NOT NULL,如果你要保存 NULL,手动去设置它，而不是把它设为默认值。<br>7、尽量少用 VARCHAR、TEXT、BLOB 类型<br>8、如果你的数据只有你所知的少量的几个。最好使用 ENUM 类型<br>9、正如 graymice 所讲的那样，建立索引。<br>10、合理用运分表与分区表提高数据存放和提取速度。</p>

    </div>
  </div>
  
    <div class="copy-right">
      <div class="markdown-body">
        <blockquote>
        
        
          本文作者 : JohnScott <br/>
        
        原文链接 : <a href="">https://github.com/liuxue5213/liuxue5213.github.io/2014/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</a><br>
        版权声明 : 本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
        </blockquote>
      </div>
    </div>
  
  
  
    <div class="social-share"
  style="margin-top: -2rem"
  data-wechat-qrcode-title="<p>微信扫一扫</p>"
  data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>"
   data-sites="qzone, qq, weibo, wechat, douban, google, facebook, twitter" 
  
>
  <span style="color: #6b7487; font-size: 1.4rem;">分享到: </span>
</div>
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" async>
  

  
    <div id="reward">
  
    <p id="reward-meta">知识 & 情怀 | 二者兼得</p>
  
  <button id="reward-btn">
    
    <span>感谢您的关心</span>
  </button>
  <div id="reward-qrcode">
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/wechat.png" alt="微信扫一扫">
        <p class="qrcode-meta">微信扫一扫</p>
      </div>
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/alipay.png" alt="支付宝扫一扫">
        <p class="qrcode-meta">支付宝扫一扫</p>
      </div>
    
  </div>

</div>

<script>
  (() => {
    let button = document.querySelector('#reward-btn'),
      qrcode = document.querySelector('#reward-qrcode'),
      display = false;
    
    button.addEventListener('click', () => {
      qrcode.style.display = display ? 'none' : 'block'
      display = !display
    }, false)
  })()
</script>
  

  <div class="article-footer">
    <div class="article-meta pull-left">
      <span>
        
          <i class="iconfont icon-06tags"></i>标签: 
          
          <span class="span--tag">
            <a href="/tags/MYSQL/">
              #MYSQL
            </a>
          </span>
          
        
      </span>
    </div>
    <div class="article-meta pull-right">
    </div>
  </div>
</div>


  <aside id="sidebar">
    <p id="sidebar-header"></p>
    <ol id="sidebar-toc"></ol>
  </aside>
  <script async>setTimeout(generateToc, 10);</script>


  <nav class="post-navigation">
    
      <div class="nav-pre">
        <i class="iconfont icon-prev"></i>
        上一篇:
        <a href="/2014/%E4%BD%BF%E7%94%A8%E6%97%A0%E9%99%90%E7%94%9F%E5%91%BD%E6%9C%9FSESSION%E7%9A%84%E6%96%B9%E6%B3%95/" target="_self">使用无限生命期SESSION的方法</a>
      </div>
    
    
      <div class="nav-next">
        下一篇:
        <a href="/2014/%E9%98%BF%E7%94%98%E6%AD%A3%E4%BC%A0-%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/" target="_self">阿甘正传-经典语录</a>
        <i class="iconfont icon-next"></i>
      </div>
    
  </nav>

  
    <a href="#comment" class="comment-anchor"></a>
<div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹 <i class="iconfont icon-footprint"></i></div>
<div id="vcomments"></div>

<script defer>
  if( true ) {
    let path = getRealPath()
    new Valine({
      el: "#vcomments",
      appId: "E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz",
      appKey: "6VNHrdDAu0JKJXxyMajHk6qD",
      notify: false,
      verify: false,
      avatar: "robohash",
      placeholder: "正确填写邮箱, 才能及时收到回复哦♪(^∇^*)",
      path
    });
  }
</script>
   

  
    <script defer>
const valineAPI = (() => {
  try {
    AV.init("E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz", "6VNHrdDAu0JKJXxyMajHk6qD");
  } catch(error) {}
  const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
      query.equalTo("identity", identity);
      query.find().then(results => {
        resolve(results.length > 0);
      }, error => reject(error));
    })
  }

  const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
      let querys = [];
      for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
      }
      query = AV.Query.or.apply(null ,querys);
    } else {
      identity = identity || getRealPath();
      query = new AV.Query("Timer");
      query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
      query.find()
      .then(results => resolve(results))
      .catch(error => reject(error))
    })
  }

  const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let Todo = AV.Object.extend('Timer');
      let todo = new Todo();
      todo.set("times", 1);
      todo.set("identity", identity);
      todo.save().then(res => resolve(true), error => reject(error));
    })
  }

  const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let query = new AV.Query('Timer');
      query.equalTo("identity", identity);
      query.find().then(todos => {
        todos.forEach(todo => {
          todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
      }).then(todos => resolve(true), error => reject(error));
    })
  }

  return {
    isExist,
    _get,
    update,
    create
  }
})()

const calcAndWriteTimes = () => {
  let isPost = true;

  let timerAllDOM = document.querySelectorAll(".article-timer");

  if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
      if(exist) {
        return valineAPI.update(identity);
      }
      return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
  }

  let timerDOMCache = {};

  for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
      timerDOMCache[identity].dom.push(timerDOM);
    }else{
      timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
      };
    }
  }

  let identities = Object.keys(timerDOMCache);
  valineAPI._get(identities).then(results => {
    for(let result of results) {
      let {identity, times} = result.attributes;
      timerDOMCache[identity].times = times;
      timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
      if(timerDOMCache[identity].times){
        continue;
      }
      timerDOMCache[identity].dom.map(item => item.innerText = 1);
      valineAPI.create(identity);
    }
  }).catch(error => console.log(error.message))
}

if(true){
  calcAndWriteTimes();
}
</script>
   

</div>


      <footer>
  <p class="site-info">
    博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span>
    <br>
    Theme - <a href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by <a target="_blank" rel="noopener" href="https://godbmw.com/">GodBMW</a>
    <br>
    
  </p>
</footer>



<script>
const timeToNowDOM = document.querySelector("#time-to-now");
const startTimestamp = new Date(2015, 0, 1).getTime();

const updateTimeStr = () => {
  let offset = parseInt(
      (new Date().getTime() - startTimestamp) / 1000,
      10
    ),
    day = Math.floor(offset / 86400),
    hour = Math.floor((offset % 86400) / 3600),
    minute = Math.floor(((offset % 86400) % 3600) / 60),
    second = Math.floor(((offset % 86400) % 3600) % 60);
  timeToNowDOM.innerHTML =
    day + "天" + hour + "小时" + minute + "分钟" + second + "秒";
  setTimeout(updateTimeStr, 500);
}

setTimeout(updateTimeStr, 500);
</script>


      <div class="back-to-top hidden">
  <span>
    <i class="iconfont icon-60"></i><span></span>%
  </span>
</div>

<script>
const updateIconToTop = percent => {
  let dom = document.querySelector(".back-to-top span span");
  dom.innerText = percent;
  if(percent < 1) {
    document.querySelector(".back-to-top").className = "back-to-top hidden";
  } else {
    document.querySelector(".back-to-top").className = "back-to-top";
  }
}

const handleScoll = () => {
  let isRunning = false;
  return () => {
    if (isRunning) return;
    isRunning = true;
    window.requestAnimationFrame(timestamp => {
      let scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop,
        scrollHeight =
          document.documentElement.scrollHeight ||
          document.body.scrollHeight,
        clientHeight =
          document.documentElement.clientHeight ||
          document.body.clientHeight;
      isRunning = false;
      if (scrollTop <= 1) {
        updateIconToTop(0);
        return;
      }
      if (scrollTop + clientHeight >= scrollHeight) {
        updateIconToTop(100);
      } else {
        updateIconToTop(parseInt(
          100 * scrollTop / (scrollHeight - clientHeight),
          10
        ));
      }
    });
  };
}

const backToTop = () => {
  let scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop,
    delay = 10,
    time = 200;
  if (scrollTop <= 20) {
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    return;
  }
  let step = Math.ceil(scrollTop * delay / time);
  let timer = setInterval(() => {
    scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop;
    if (scrollTop - step <= 0) {
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      clearInterval(timer);
    } else {
      document.documentElement.scrollTop = scrollTop - step;
      document.body.scrollTop = scrollTop - step;
    }
  }, delay);
}

document.addEventListener("scroll", handleScoll(), false);

document.querySelector(".back-to-top").addEventListener("click", backToTop, false);

</script>

    </div>

    
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  (() => {
    const mathjaxConfig = {
      showProcessingMessages: false, //关闭js加载过程信息
      messageStyle: "none", //不显示信息
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
        displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], //可选字体
        showMathMenu: false //关闭右击菜单显示
      }
    }

    let mathjaxInterval = setInterval(() => {
      if(!window.MathJax){
        return;
      }
      window.MathJax.Hub.Config(mathjaxConfig)
      window.MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('app')])

      clearInterval(mathjaxInterval)
    }, 10)    
  })()
</script>
    

    <script src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script>
<script async>
  let fancyTimer = setInterval(function(){
    if(!window.$){
      return;
    }
    $(document).ready(function() {
      $(".post img").each(function () {
        if($(this).parent().get(0).tagName.toLowerCase() === "a") {
          return;
        }
        // $(this).attr("data-fancybox", "gallery"); // if you add 'data-fancybox', img will display after showed
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "gallery");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      });
      
      clearInterval(fancyTimer);
    });
  }, 10);
</script>

    
  </body>

</html>
