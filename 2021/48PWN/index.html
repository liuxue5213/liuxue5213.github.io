<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta name="author" content="johnscott" />
  
  
  
  <title>48PWN | JohnScott2046的博客</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="网络安全,网络安全," />
  

  <script>
    console.log('\n%c Hexo-theme-bmw v4.0 ' + '%c 🎉 https://github.com/dongyuanxin/theme-bmw 🎉\n' + '\n%c View demo online ' + '%c 🔍 https://godbmw.com/ 🔍  \n' , 'color: #fadfa3; background: #030307; padding:3px 0;', '', 'color: #fadfa3; background: #030307; padding:3px 0;', '');
  </script>

  
    <meta name="description" content="超级帽子戏法的个人博客,主要记录复制粘贴过来的笔记,还有自己的一些心得体会">
  

  

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/icon/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  
<script src="/js/util.js"></script>
<script src="/js/valine.min.js"></script>


  

  
    <link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js" async></script>
  

  
    <link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">
  
  
  <script src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js" async></script>
  
  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script>
  

<meta name="generator" content="Hexo 5.1.1"></head>

  <body>
    <meta name="baidu-site-verification" content="code-GGEum2Y5d8" />
    

    <div id="app">

      <div class="header-wrap">
  <header>
    <div class="site-brand">
      <div class="site-title">
        <a href="/">JohnScott2046</a>
      </div>
    </div>
    <nav class="site-navigation">
      <ul class="nav-menu">
      
        <li class="nav-item" data-path="/">
          
            <a 
              href="/"
              target="_self"
            >
              主页
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/archives/">
          
            <a 
              href="/archives/"
              target="_self"
            >
              归档
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/categories/">
          
            <a 
              href="/categories/"
              target="_self"
            >
              分类
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/tags/">
          
            <a 
              href="/tags/"
              target="_self"
            >
              标签
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/friends/">
          
            <a 
              href="/friends/"
              target="_self"
            >
              友链
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/about/">
          
            <a 
              href="/about/"
              target="_self"
            >
              关于
            </a>
          
        </li>
      
        <li class="nav-item" data-path="">
          
            <a href="javascript:void(0);" v-else>联系我</a>
            <ul class="nav-menu--dropdown">
              
                <li>
                  <a 
                    href="https://github.com/liuxue5213" 
                    target="_blank"
                  >
                    Github
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.zhihu.com/people/liuxue5213" 
                    target="_blank"
                  >
                    知乎
                  </a>
                </li>
              
                <li>
                  <a 
                    href="http://weibo.com/liuxue5213" 
                    target="_blank"
                  >
                    微博
                  </a>
                </li>
              
                <li>
                  <a 
                    href="https://www.douban.com/people/liuxue5213" 
                    target="_blank"
                  >
                    豆瓣
                  </a>
                </li>
              
                <li>
                  <a 
                    href="/linkedin.com/in/liuxue5213" 
                    target="_blank"
                  >
                    linkedin
                  </a>
                </li>
              
            </ul>
          
        </li>
      
      </ul>
    </nav>
    <i class="iconfont icon-menu"></i>
  </header>
</div>

<script>
  let links = document.querySelectorAll('.nav-item');
  for(let link of links){
    let childrenLink = link.querySelector('ul');
    link.addEventListener('mouseenter', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown active";
      }
    })
    link.addEventListener('mouseleave', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown";
      }
    })
  }
  let rootRealPath = getRealPath(window.location.pathname, true);
  for(let link of links) {
    let linkPath = link.getAttribute("data-path");
    if(linkPath && getRealPath(linkPath, true) === rootRealPath) {
      link.className = "nav-item hover";
    }
  }

  let iconMenu = document.querySelector("i.iconfont.icon-menu"),
    iconMenuClicked = false;
  let navDOM = document.querySelector("nav.site-navigation");
  iconMenu.addEventListener("click", () => {
    iconMenuClicked 
      ? navDOM.className = "site-navigation active"
      : navDOM.className = "site-navigation";
    iconMenuClicked = !iconMenuClicked;
  })
</script>

      








<div class="container post-index">

  

<div class="post">
  <h1 class="article-title">
    <span>48PWN</span>
  </h1>
  <div class="article-top-meta">
    <span>
      发布 : 
      2021-12-06
    </span>
    
      <span>
        分类 : 
          <a href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">
            网络安全
          </a>
      </span>
    
    
      <span>
        浏览 : <span class="article-timer" data-identity="48PWN"></span>
      </span>
    
  </div>

  

  <div class="article-content">
    <div class="markdown-body">
      <p>网络安全(一)PWN</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="什么是PWN"><a href="#什么是PWN" class="headerlink" title="什么是PWN"></a>什么是PWN</h3><p>破解、利用成功（程序的二进制漏洞）<br>攻破（设备、服务器）<br>控制（设备、服务器）</p>
<p>CTF 比赛主要表现以下几个技能上：逆向工程、密码学、Web漏洞、二进制溢出、网络和取证等。在国际 CTF 赛事中，二进制溢出也称之为PWN。</p>
<p>PWN 是一个黑客语法的俚语词，自”own”这个字引申出来的，这个词的含意在于，玩家在整个游戏对战中处在胜利的优势，或是说明竞争对手处在完全惨败的 情形下，这个词习惯上在网络游戏文化主要用于嘲笑竞争对手在整个游戏对战中已经完全被击败（例如：”You just got pwned!”）。</p>
<p>有一个非常著名的国际赛事叫做 Pwn2Own，即通过打败对手来达到拥有的目的。</p>
<p>CTF 中 PWN 题型通常会直接给定一个已经编译好的二进制程序（Windows下的EXE 或者 Linux下的ELF 文件等），然后参赛选手通过对二进制程 序进行逆向分析和调试来找到利用漏洞，并编写利用代码，通过远程代码执行来达到溢出攻击的效果，最终拿到目标机器的 shell获取flag</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>ELF文件头表（ELF header） 记录了 ELF 文件的组织结构</p>
<p>Program header table  程序头表/段表<br>告诉系统如何创建进程<br>生成进程的可执行文件必须拥有此结构<br>重定位文件不一定需要</p>
<p>.text<br>.rodata<br>.data</p>
<p>section header table 节头表<br>记录了 ELF 文件的节区信息<br>用于链接的目标文件必须拥有此结构<br>其它类型目标文件不一定需要</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>exploit 用于攻击的脚本与方案<br>payload 攻击载荷，是的目标进程被劫持控制流的数据<br>shellcode 调用攻击目标的 shell 的代码</p>
<p>bss段：<br>  bss段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。<br>  bss是英文 Block Started by Symbol 的简称。<br>  bss段属于静态内存分配。</p>
<p>data段：<br>  数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。<br>  数据段属于静态内存分配。</p>
<p>text段：<br>  代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。<br>  这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。<br>  在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p>
<p>堆（heap）：<br>  堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。<br>  当进程调用 malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；<br>  当利用 free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p>
<p>栈(stack)：<br>  栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static 意味着在数据段（.data）中存放变量）。</p>
<p>  除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</p>
<p>  由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。</p>
<p>  从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p>
<p>  一个程序本质上都是由 bss 段、data 段、text 段三个组成的。</p>
<p>  这样的概念，不知道最初来源于哪里的规定，但在当前的计算机程序设计中是很重要的一个基本概念。而且在嵌入式系统的设计中也非常重要，牵涉到嵌入式系统运行时的内存大小分配，存储单元占用空间大小的问题。</p>
<p>  在采用段式内存管理的架构中（比如 intel 的 80x86 系统），bss 段通常是指用来存放程序中未初始化的全局变量的一块内存区域，一般在初始化时 bss 段部分将会清零。bss 段属于静态内存分配，即程序一开始就将其清零了。</p>
<p>  比如，在 C 语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中。text 和 data 段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而 bss 段不在可执行文件中，由系统初始化</p>
<p>  先进后出。<br>  在内存中表现为从高地址往低地址增长。<br>  栈顶：栈的最上方（低地址区）。<br>  栈低：栈的最下方（高地址区）。</p>
<p>  地址从高到低</p>
<p>  更早的栈<br>  调用者的栈<br>      函数参数<br>      返回地址<br>  被调用者的栈<br>      旧的%ebp-&gt;基址指针%ebp<br>      本地变量<br>      栈指针 %esp</p>
<p>  esp 栈指针寄存器，其内存中存在一个指针，该指针永远指向系统栈最上面的一个栈针的栈顶<br>  ebp 基址指针寄存器，其内存中存在一个指针，该指针永远指向系统栈最上面的一个栈针的底部</p>
<p>全局的未初始化变量存在于.bss 段中，具体体现为一个占位符；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int ar[30000];</span><br><span class="line">int main()&#123;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局的已初始化变量存于.data 段中；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int ar[300000] &#x3D; &#123;1, 2, 3, 4, 5, 6 &#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.bss 是不占用.exe 文件空间的，其内容由操作系统初始化（清零）；<br>.data 却需要占用，其内容由程序初始化。因此造成了上述情况。</p>
<p>bss 段（未手动初始化的数据）并不给该段的数据分配空间，只是记录数据所需空间的大小；<br>bss 段的大小从可执行文件中得到 ，然后链接器得到这个大小的内存块，紧跟在数据段后面。<br>data 段（已手动初始化的数据）则为数据分配空间，数据保存在目标文件中；<br>data 段包含经过初始化的全局变量以及它们的值。当这个内存区进入程序的地址空间后全部清零。<br>包含 data 段和 bss 段的整个区段此时通常称为数据区</p>
<h3 id="PWN文件保护机制"><a href="#PWN文件保护机制" class="headerlink" title="PWN文件保护机制"></a>PWN文件保护机制</h3><p>Linux ELF 文件的保护主要有四种：Canary、NX、PIE、RELRO</p>
<p>checksec filename  查看文件的保护信息</p>
<h4 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h4><p>Canary是金丝雀的意思。技术上表示最先的测试的意思。这个来自以前挖煤的时候，矿工都会先把金丝雀放进矿洞，或者挖煤的时候一直带着金丝雀。金丝雀对甲烷和一氧化碳浓度比较敏感，会先报警。所以大家都用 Canary 来搞最先的测试。Stack Canary 表示栈的报警保护。</p>
<p>在函数返回值之前添加的一串随机数（不超过机器字长）（也叫做 cookie），末位为/x00（提供了覆盖最后一字节输出泄露 Canary 的可能），如果出现缓冲区溢出攻击，覆盖内容覆盖到 Canary 处，就会改变原本该处的数值，当程序执行到此处时，会检查 Canary 值是否跟开始的值一样，如果不一样，程序会崩溃，从而达到保护返回地址的目的。</p>
<p>总的来说，Canary 参数表示着对栈的保护，防止栈溢出的一种保护，即在栈靠近栈底某个位置设置初值，防止栈溢出的一种保护</p>
<p>GCC 用法：<br>gcc -o test test.c    默认情况下，不开启 Canary 保护<br>gcc -fno-stack-protector -o test test.c    禁用栈保护<br>gcc -fstack-protector -o test test.c    启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码<br>gcc -fstack-protector-all -o test test.c    启用堆栈保护，为所有函数插入保护代码<br>-fno-stack-protector /-fstack-protector / -fstack-protector-all  (关闭 / 开启 / 全开启)</p>
<h4 id="No-eXecute"><a href="#No-eXecute" class="headerlink" title="No-eXecute"></a>No-eXecute</h4><p>不可执行，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU就会抛出异常，而不是去执行恶意指令。</p>
<p>正常在栈溢出时通过跳转指令跳转至 shellcode，但是 NX 开启后 CPU 会对数据区域进行检查，当发现正常程序不执行，并跳转至其他地址后会抛出异常，接下来不会继续执行 shellcode，而是去转入异常处理，处理后会禁止 shellcode 继续执行</p>
<p>GCC 用法：<br>gcc -o test test.c // 默认情况下，开启 NX 保护<br>gcc -z execstack -o test test.c // 禁用 NX 保护<br>gcc -z noexecstack -o test test.c // 开启 NX 保护<br>-z execstack / -z noexecstack (关闭 / 开启)</p>
<h4 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h4><p>一般情况下 NX（Windows 平台上称为 DEP）和地址空间分布随机化（PIE/ASLR）（address space layout randomization）会同时工作。</p>
<p>内存地址随机化机制有三种情况：<br>0 - 表示关闭进程地址空间随机化。<br>1 - 表示将 mmap 的基地址，栈基地址和.so 地址随机化<br>2 - 表示在 1 的基础上增加 heap 的地址随机化</p>
<p>该保护能使每次运行的程序的地址都不同，防止根据固定地址来写 exp 执行攻击。可以防止 Ret2libc 方式针对 DEP 的攻击。ASLR 和 DEP 配合使用，能有效阻止攻击者在堆栈上运行恶意代码</p>
<p>liunx 下关闭 PIE 的命令如下：<br>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</p>
<p>GCC 用法：<br>gcc -o test test.c // 默认情况下，不开启 PIE<br>gcc -fpie -pie -o test test.c // 开启 PIE，此时强度为 1<br>gcc -fPIE -pie -o test test.c // 开启 PIE，此时为最高强度 2<br>gcc -fpic -o test test.c // 开启 PIC，此时强度为 1，不会开启 PIE<br>gcc -fPIC -o test test.c // 开启 PIC，此时为最高强度 2，不会开启 PIE<br>-no-pie / -pie (关闭 / 开启)</p>
<h4 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h4><p>Relocation Read-Only (RELRO) 可以使程序某些部分成为只读的。</p>
<p>它分为两种：Partial RELRO和 Full RELRO，即：部分 RELRO 和 完全 RELRO。<br>部分 RELRO 是 GCC 的默认设置，几乎所有的二进制文件都至少使用部分 RELRO。这样仅仅只能防止全局变量上的缓冲区溢出从而覆盖 GOT。<br>完全 RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p>
<p>在 Linux 系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。所以在安全防护的角度应尽量减少可写的存储区域RELRO 会设置符号重定向表格为只读或者程序启动时就解析并绑定所有动态符号，从而减少对 GOT 表的攻击。如果 RELRO 为 Partial RELRO，就说明对 GOT 表具有写权限主要用来保护重定位表段对应数据区域，默认可写</p>
<p>Partial RELRO：.got 不可写，got.plt 可写<br>Full RELRO：.got 和 got.plt 不可写<br>got.plt 可以简称为 got 表</p>
<p>GCC 用法：<br>gcc -o test test.c // 默认情况下，是 Partial RELRO<br>gcc -z norelro -o test test.c // 关闭，即 No RELRO<br>gcc -z lazy -o test test.c // 部分开启，即 Partial RELRO<br>gcc -z now -o test test.c // 全部开启<br>-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)</p>
<h4 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h4><p>fortify是轻微的检查，用于检查是否存在缓冲区溢出的错误。</p>
<p>适用于程序采用大量的字符串或者内存操作函数，如:</p>
<p>memcpy():<br>描述：<br>  void * memcpy(void * str1, const void * str2, size_t n) 从存储区 str2 复制 n 个字符到存储区 str1<br>参数：<br>  str1 – 指向用于存储复制内容的目标数组，类型强制转换为 void * 指针<br>  str2 – 指向要复制的数据源，类型强制转换为 void * 指针 n – 要被复制的字节数<br>返回值：<br>  该函数返回一个指向目标存储区 str1 的指针</p>
<p>memset():<br>  描述：void * memset(void * str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符<br>参数：<br>  str – 指向要填充的内存块<br>  c – 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式<br>  n – 要被设置为该值的字节数<br>返回值：<br>  该值返回一个指向存储区 str 的指针</p>
<p>strcpy():<br>  描述：char * strcpy(char * dest, const char * src) 把 src 所指向的字符串复制到 dest，容易出现溢出<br>参数：<br>  dest – 指向用于存储复制内容的目标数组<br>  src – 要复制的字符串<br>返回值：<br>  该函数返回一个指向最终的目标字符串 dest 的指针</p>
<p>stpcpy():<br>  描述：extern char * stpcpy(char * dest,char * src) 把 src 所指由 NULL 借宿的字符串复制到 dest 所指的数组中<br>说明：<br>  src 和 dest 所指内存区域不可以重叠且 dest 必须有足够的空间来容纳 src 的字符串<br>  返回指向 dest 结尾处字符（NULL）的指针<br>返回值：</p>
<p>strncpy():<br>描述：<br>  char * strncpy(char * dest, const char * src, size_t n)<br>  把src所指向的字符串复制到dest，最多复制n个字符。<br>  当src的长度小于n时，dest 的剩余部分将用空字节填充<br>参数：<br>  dest – 指向用于存储复制内容的目标数组<br>  src – 要复制的字符串<br>  n – 要从源中复制的字符数<br>返回值：<br>  该函数返回最终复制的字符串</p>
<p>strcat():<br>描述：char * strcat(char * dest, const char * src) 把 src 所指向的字符串追加到 dest 所指向的字符串的结尾<br>参数：<br>  dest – 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串<br>  src – 指向要追加的字符串，该字符串不会覆盖目标字符串<br>返回值：</p>
<p>strncat():<br>描述：<br>  char * strncat(char * dest, const char * src, size_t n) 把src所指向的字符串追加到dest所指向的字符串的结尾，直到 n 字符长度为止<br>参数：<br>  dest – 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串，包括额外的空字符<br>  src – 要追加的字符串<br>  n – 要追加的最大字符数<br>返回值：<br>  该函数返回一个指向最终的目标字符串 dest 的指针</p>
<p>sprintf():PHP<br>描述：<br>  sprintf(format,arg1,arg2,arg++)   arg1、arg2、++ 参数将被插入到主字符串中的百分号（%）符号处。<br>  该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推<br>参数：<br>  format – 必需。规定字符串以及如何格式化其中的变量<br>  arg1 – 必需。规定插到 format 字符串中第一个 % 符号处的参<br>  arg2 – 可选。规定插到 format 字符串中第二个 % 符号处的参数<br>  arg++ – 可选。规定插到 format 字符串中第三、四等等 % 符号处的参数<br>返回值：<br>  返回已格式化的字符串</p>
<p>snprintf():<br>描述：<br>  int snprintf ( char * str, size_t size, const char * format, … )<br>  设将可变参数(…)按照 format 格式化成字符串，并将字符串复制到 str 中，size为要写入的字符的最大数目，超过 size 会被截断<br>参数：<br>  str – 目标字符串<br>  size – 拷贝字节数(Bytes)如果格式化后的字符串长度大于 size<br>  format – 格式化成字符串<br>返回值：<br>  如果格式化后的字符串长度小于等于 size，则会把字符串全部复制到 str 中，并给其后添加一个字符串结束符 \0。 如果格式化后的字符串长度大于size，超过size的部分会被截断，只将其中的(size-1)个字符复制到str中，并给其后添加一个字符串结束符 \0，返回值为要写入的字符串长度</p>
<p>vsprintf():PHP<br>描述：<br>  vsprintf(format,argarray)  与sprintf()不同，vsprintf()中的参数位于数组中。数组元素将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的<br>参数：<br>  format – 必需。规定字符串以及如何格式化其中的变量<br>  argarray – 必需。带有参数的一个数组，这些参数会被插到 format 字符串中的%符号处<br>返回值：<br>  以格式化字符串的形式返回数组值</p>
<p>vsnprintf():<br>描述：<br>  int vsnprintf (char * s, size_t n, const char * format, va_list arg) 将格式化数据从可变参数列表写入大小缓冲区</p>
<p>  如果在printf上使用格式，则使用相同的文本组成字符串，但使用由arg标识的变量参数列表中的元素而不是附加的函数参数，并将结果内容作为 C 字符串存储在 s 指向的缓冲区中（以 n 为最大缓冲区容量来填充）。</p>
<p>  如果结果字符串的长度超过了 n-1 个字符，则剩余的字符将被丢弃并且不被存储，而是被计算为函数返回的值。在内部，函数从 arg 标识的列表中检索参数，就好像 va_arg 被使用了一样，因此 arg 的状态很可能被调用所改变。</p>
<p>  在任何情况下，arg 都应该在调用之前的某个时刻由 va_start 初始化，并且在调用之后的某个时刻，预计会由 va_end 释放</p>
<p>参数：<br>  s – 指向存储结果 C 字符串的缓冲区的指针，缓冲区应至少有 n 个字符的大小<br>  n – 在缓冲区中使用的最大字节数，生成的字符串的长度至多为 n-1，为额外的终止空字符留下空，size_t 是一个无符号整数类型<br>  format – 包含格式字符串的 C 字符串，其格式字符串与 printf 中的格式相同<br>  arg – 标识使用 va_start 初始化的变量参数列表的值<br>返回值：<br>  如果 n 足够大，则会写入的字符数，不包括终止空字符。如果发生编码错误，则返回负数。注意，只有当这个返回值是非负值且小于 n 时，字符串才被完全写入</p>
<p>gets():<br>描述：<br>  char * gets(char * str)  从标准输入stdin读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定<br>参数：<br>  str – 这是指向一个字符数组的指针，该数组存储了 C 字符串<br>返回值：<br>  如果成功，该函数返回 str。<br>  如果发生错误或者到达文件末尾时还未读取任何字符，则返回 NULL</p>
<p>GCC 用法：<br>gcc -D_FORTIFY_SOURCE=1 仅仅只在编译时进行检查（尤其是#include &lt;string.h&gt;这种文件头）<br>gcc -D_FORTIFY_SOURCE=2 程序执行时也会进行检查（如果检查到缓冲区溢出，就会终止程序）<br>在-D_FORTIFY_SOURCE=2 时，通过对数组大小来判断替换 strcpy、memcpy、memset 等函数名，从而达到防止缓冲区溢出的作用</p>
<h3 id="pwntools学习"><a href="#pwntools学习" class="headerlink" title="pwntools学习"></a>pwntools学习</h3><h4 id="1-大致框架"><a href="#1-大致框架" class="headerlink" title="1. 大致框架"></a>1. 大致框架</h4><p>from pwn import *   导入pwntools模块</p>
<p>context(arch = ‘i386’, os = ‘linux’)   设置目标机的信息</p>
<p>i = process(‘./file’) 本地连接</p>
<p>r = remote(‘example.com’, 31337)  用来建立一个远程连接，url或者ip作为地址，然后指明端口这里也可以仅仅使用本地文件,调试时方便:r = process(“./test”) test为文件名,这使得改变远程和本地十分方便 </p>
<p>asm(shellcraft.sh())   asm()函数接收一个字符串作为参数，得到汇编码的机器代码</p>
<p>shellcraft 模块是 shellcode 的模块，包含一些生成 shellcode 的函数。其中的子模块声明架构，<br>比如 shellcraft.arm 是 ARM 架构的，<br>shellcraft.amd64 是 AMD64 架构，<br>shellcraft.i386 是 Intel 80386 架构的，<br>shellcraft.common 是所有架构通用的。<br>而这里的 shellcraft.sh() 则是执行/bin/sh的shellcode了</p>
<p>r.send()  r.sendline()  将shellcode发送到远程连接<br>r.interactive()   将控制权交给用户，这样就可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">i &#x3D; process(&#39;.&#x2F;file&#39;)</span><br><span class="line">i.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">i &#x3D; process(&#39;.&#x2F;file&#39;)</span><br><span class="line">p &#x3D; b&#39;a&#39;*4 + p64(11111111)</span><br><span class="line">i.recvuntil(&#39;aaaaaaaaaaa&#39;)</span><br><span class="line">i.sendline(p)</span><br><span class="line">i.interactive()</span><br></pre></td></tr></table></figure>


<h4 id="2-Context-设置"><a href="#2-Context-设置" class="headerlink" title="2. Context 设置"></a>2. Context 设置</h4><p>context 是 pwntools 用来设置环境的功能。</p>
<p>在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行 exp，比如有一些需要进行汇编，但是32的汇<br>编和64的汇编不同，如果不设置 context 会导致一些问题。</p>
<p>一般来说我们设置 context 只需要简单的一句话:<br>context(os=’linux’, arch=’amd64’, log_level=’debug’)</p>
<p>这句话的意思是：</p>
<ol>
<li>os 设置系统为 linux 系统，在完成 ctf 题目的时候，大多数 pwn 题目的系统都是 linux</li>
<li>arch 设置架构为 amd64，可以简单的认为设置为 64 位的模式，对应的 32 位模式是’i386’</li>
<li>log_level 设置日志输出的等级为 debug，这句话在调试的时候一般会设置，这样 pwntools<br>会将完整的 io 过程都打印下来，使得调试更加方便，可以避免在完成 CTF 题目时出现一些<br>和 IO 相关的错误。</li>
</ol>
<p>3、数据打包<br>数据打包,即将整数值转换为 32 位或者 64 位地址一样的表示方式,比如 0x400010 表示为<br>\x10\x00\x40 一样,这使得我们构造 payload 变得很方便<br>用法: * p32/p64: 打包一个整数,分别打包为 32 或 64 位</p>
<ul>
<li>u32/u64: 解包一个字符串,得到整数<br>p 对应 pack,打包,u 对应 unpack,解包,简单好记<br>payload = p32(0xdeadbeef) # pack 32 bits number<br>4、数据输出<br>如果需要输出一些信息,最好使用 pwntools 自带的,因为和 pwntools 本来的格式吻合,看起来<br>也比较舒服,用法:<br>some_str = “hello, world”<br>log.info(some_str)<br>其中的 info 代表是 log 等级，也可以使用其他 log 等级。</li>
</ul>
<p>5、Cyclic Pattern<br>Cyclic pattern 是一个很强大的功能，大概意思就是，使用 pwntools 生成一个 pattern，pattern<br>就是指一个字符串，可以通过其中的一部分数据去定位到他在一个字符串中的位置。<br>在我们完成栈溢出题目的时候，使用 pattern 可以大大的减少计算溢出点的时间。<br>用法：<br>cyclic(0x100) # 生成一个 0x100 大小的 pattern，即一个特殊的字符串<br>cyclic_find(0x61616161) # 找到该数据在 pattern 中的位置（或者是 cyclic -l 0x61616161 ）<br>cyclic_find(‘aaaa’) # 查找位置也可以使用字符串去定位<br>比如，我们在栈溢出的时候，首先构造 cyclic(0x100)，或者更长长度的 pattern，进行输入，<br>输入后 pc 的值变味了 0x61616161，那么我们通过 cyclic_find(0x61616161)就可以得到从哪一<br>个字节开始会控制 PC 寄存器了，避免了很多没必要的计算。<br>6、汇编与 shellcode<br>有的时候我们需要在写 exp 的时候用到简单的 shellcode，pwntools 提供了对简单的 shellcode<br>的支持。<br>首先，常用的，也是最简单的 shellcode。<br>shellcraft : shellcode 的生成器。即调用/bin/sh 可以通过 shellcraft 得到：<br>注意，由于各个平台，特别是 32 位和 64 位的 shellcode 不一样，所以最好先设置 context，<br>如果没声明平则<br>32 位:shellcraft.i386.linux.sh()<br>64 位:shellcraft.amd64.linux.sh()<br>print(shellcraft.sh()) # 打印出 shellcode</p>
<p>不过，现在我们看到的 shellcode 还是汇编代码，不是能用的机器码，所以还需要进行一次<br>汇编<br>print(asm(shellcraft.sh())) # 打印出汇编后的 shellcode<br>asm 可以对汇编代码进行汇编，不过 pwntools 目前的 asm 实现还有一些缺陷，比如不能支<br>持相对跳转等等，只可以进行简单的汇编操作。如果需要更复杂一些的汇编功能，可以使用<br>keystone-engine 项目，这里就不再赘述了。<br>asm 也是架构相关，所以一定要先设置 context，避免一些意想不到的错误。<br>asm 也是架构相关，所以一定要先设置 context，避免一些意想不到的错误。</p>
<p>7、ELF 文件操作<br>In [1]: from pwn import*<br>In [2]: elf = ELF(‘./level0’)<br>[*] ‘/home/nuo/level0’ Arch: amd64-64-little<br>RELRO: No RELRO<br>Stack: No canary found<br>NX: NX enabled<br>PIE: No PIE (0x400000)<br>In [3]: callsys_addr = elf.symbols[‘callsystem’]<br>In [4]: print callsys_addr<br>4195734<br>In [6]: a=hex(callsys_addr)<br>In [7]: print a<br>0x400596<br>可见 ipython 时，ELF 相当于 checksec ,但其主要是获取信息，一些地址等</p>
<blockquote>
<blockquote>
<blockquote>
<p>e = ELF(‘/bin/cat’)<br>print hex(e.address) # 文件装载的基地址<br>0x400000<br>print hex(e.symbols[‘write’]) # 函数地址,symbols,got,plt 均是列表<br>0x401680<br>print hex(e.got[‘write’]) # GOT 表的地址<br>0x60b070<br>print hex(e.plt[‘write’]) # PLT 的地址<br>0x401680<br>print hex(e.search(‘/bin/sh’).next())# 字符串/bin/sh 的地址字符串加（）</p>
</blockquote>
</blockquote>
</blockquote>

    </div>
  </div>
  
    <div class="copy-right">
      <div class="markdown-body">
        <blockquote>
        
        
          本文作者 : JohnScott <br/>
        
        原文链接 : <a href="">https://github.com/liuxue5213/liuxue5213.github.io/2021/48PWN/</a><br>
        版权声明 : 本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
        </blockquote>
      </div>
    </div>
  
  
  
    <div class="social-share"
  style="margin-top: -2rem"
  data-wechat-qrcode-title="<p>微信扫一扫</p>"
  data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>"
   data-sites="qzone, qq, weibo, wechat, douban, google, facebook, twitter" 
  
>
  <span style="color: #6b7487; font-size: 1.4rem;">分享到: </span>
</div>
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" async>
  

  
    <div id="reward">
  
    <p id="reward-meta">知识 & 情怀 | 二者兼得</p>
  
  <button id="reward-btn">
    
    <span>感谢您的关心</span>
  </button>
  <div id="reward-qrcode">
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/wechat.png" alt="微信扫一扫">
        <p class="qrcode-meta">微信扫一扫</p>
      </div>
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/alipay.png" alt="支付宝扫一扫">
        <p class="qrcode-meta">支付宝扫一扫</p>
      </div>
    
  </div>

</div>

<script>
  (() => {
    let button = document.querySelector('#reward-btn'),
      qrcode = document.querySelector('#reward-qrcode'),
      display = false;
    
    button.addEventListener('click', () => {
      qrcode.style.display = display ? 'none' : 'block'
      display = !display
    }, false)
  })()
</script>
  

  <div class="article-footer">
    <div class="article-meta pull-left">
      <span>
        
          <i class="iconfont icon-06tags"></i>标签: 
          
          <span class="span--tag">
            <a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">
              #网络安全
            </a>
          </span>
          
        
      </span>
    </div>
    <div class="article-meta pull-right">
    </div>
  </div>
</div>


  <aside id="sidebar">
    <p id="sidebar-header"></p>
    <ol id="sidebar-toc"></ol>
  </aside>
  <script async>setTimeout(generateToc, 10);</script>


  <nav class="post-navigation">
    
      <div class="nav-pre">
        <i class="iconfont icon-prev"></i>
        上一篇:
        <a href="/2021/47%E5%AF%86%E7%A0%81%E5%AD%A6/" target="_self">47密码学</a>
      </div>
    
    
      <div class="nav-next">
        下一篇:
        <a href="/2021/49CobaltStrike/" target="_self">49CobaltStrike</a>
        <i class="iconfont icon-next"></i>
      </div>
    
  </nav>

  
    <a href="#comment" class="comment-anchor"></a>
<div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹 <i class="iconfont icon-footprint"></i></div>
<div id="vcomments"></div>

<script defer>
  if( true ) {
    let path = getRealPath()
    new Valine({
      el: "#vcomments",
      appId: "E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz",
      appKey: "6VNHrdDAu0JKJXxyMajHk6qD",
      notify: false,
      verify: false,
      avatar: "robohash",
      placeholder: "正确填写邮箱, 才能及时收到回复哦♪(^∇^*)",
      path
    });
  }
</script>
   

  
    <script defer>
const valineAPI = (() => {
  try {
    AV.init("E4f1KI8G9DKenPGcXCkfpCMV-gzGzoHsz", "6VNHrdDAu0JKJXxyMajHk6qD");
  } catch(error) {}
  const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
      query.equalTo("identity", identity);
      query.find().then(results => {
        resolve(results.length > 0);
      }, error => reject(error));
    })
  }

  const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
      let querys = [];
      for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
      }
      query = AV.Query.or.apply(null ,querys);
    } else {
      identity = identity || getRealPath();
      query = new AV.Query("Timer");
      query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
      query.find()
      .then(results => resolve(results))
      .catch(error => reject(error))
    })
  }

  const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let Todo = AV.Object.extend('Timer');
      let todo = new Todo();
      todo.set("times", 1);
      todo.set("identity", identity);
      todo.save().then(res => resolve(true), error => reject(error));
    })
  }

  const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let query = new AV.Query('Timer');
      query.equalTo("identity", identity);
      query.find().then(todos => {
        todos.forEach(todo => {
          todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
      }).then(todos => resolve(true), error => reject(error));
    })
  }

  return {
    isExist,
    _get,
    update,
    create
  }
})()

const calcAndWriteTimes = () => {
  let isPost = true;

  let timerAllDOM = document.querySelectorAll(".article-timer");

  if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
      if(exist) {
        return valineAPI.update(identity);
      }
      return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
  }

  let timerDOMCache = {};

  for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
      timerDOMCache[identity].dom.push(timerDOM);
    }else{
      timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
      };
    }
  }

  let identities = Object.keys(timerDOMCache);
  valineAPI._get(identities).then(results => {
    for(let result of results) {
      let {identity, times} = result.attributes;
      timerDOMCache[identity].times = times;
      timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
      if(timerDOMCache[identity].times){
        continue;
      }
      timerDOMCache[identity].dom.map(item => item.innerText = 1);
      valineAPI.create(identity);
    }
  }).catch(error => console.log(error.message))
}

if(true){
  calcAndWriteTimes();
}
</script>
   

</div>


      <footer>
  <p class="site-info">
    博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span>
    <br>
    Theme - <a href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by <a target="_blank" rel="noopener" href="https://godbmw.com/">GodBMW</a>
    <br>
    
  </p>
</footer>



<script>
const timeToNowDOM = document.querySelector("#time-to-now");
const startTimestamp = new Date(2015, 0, 1).getTime();

const updateTimeStr = () => {
  let offset = parseInt(
      (new Date().getTime() - startTimestamp) / 1000,
      10
    ),
    day = Math.floor(offset / 86400),
    hour = Math.floor((offset % 86400) / 3600),
    minute = Math.floor(((offset % 86400) % 3600) / 60),
    second = Math.floor(((offset % 86400) % 3600) % 60);
  timeToNowDOM.innerHTML =
    day + "天" + hour + "小时" + minute + "分钟" + second + "秒";
  setTimeout(updateTimeStr, 500);
}

setTimeout(updateTimeStr, 500);
</script>


      <div class="back-to-top hidden">
  <span>
    <i class="iconfont icon-60"></i><span></span>%
  </span>
</div>

<script>
const updateIconToTop = percent => {
  let dom = document.querySelector(".back-to-top span span");
  dom.innerText = percent;
  if(percent < 1) {
    document.querySelector(".back-to-top").className = "back-to-top hidden";
  } else {
    document.querySelector(".back-to-top").className = "back-to-top";
  }
}

const handleScoll = () => {
  let isRunning = false;
  return () => {
    if (isRunning) return;
    isRunning = true;
    window.requestAnimationFrame(timestamp => {
      let scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop,
        scrollHeight =
          document.documentElement.scrollHeight ||
          document.body.scrollHeight,
        clientHeight =
          document.documentElement.clientHeight ||
          document.body.clientHeight;
      isRunning = false;
      if (scrollTop <= 1) {
        updateIconToTop(0);
        return;
      }
      if (scrollTop + clientHeight >= scrollHeight) {
        updateIconToTop(100);
      } else {
        updateIconToTop(parseInt(
          100 * scrollTop / (scrollHeight - clientHeight),
          10
        ));
      }
    });
  };
}

const backToTop = () => {
  let scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop,
    delay = 10,
    time = 200;
  if (scrollTop <= 20) {
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    return;
  }
  let step = Math.ceil(scrollTop * delay / time);
  let timer = setInterval(() => {
    scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop;
    if (scrollTop - step <= 0) {
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      clearInterval(timer);
    } else {
      document.documentElement.scrollTop = scrollTop - step;
      document.body.scrollTop = scrollTop - step;
    }
  }, delay);
}

document.addEventListener("scroll", handleScoll(), false);

document.querySelector(".back-to-top").addEventListener("click", backToTop, false);

</script>

    </div>

    
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  (() => {
    const mathjaxConfig = {
      showProcessingMessages: false, //关闭js加载过程信息
      messageStyle: "none", //不显示信息
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
        displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], //可选字体
        showMathMenu: false //关闭右击菜单显示
      }
    }

    let mathjaxInterval = setInterval(() => {
      if(!window.MathJax){
        return;
      }
      window.MathJax.Hub.Config(mathjaxConfig)
      window.MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('app')])

      clearInterval(mathjaxInterval)
    }, 10)    
  })()
</script>
    

    <script src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script>
<script async>
  let fancyTimer = setInterval(function(){
    if(!window.$){
      return;
    }
    $(document).ready(function() {
      $(".post img").each(function () {
        if($(this).parent().get(0).tagName.toLowerCase() === "a") {
          return;
        }
        // $(this).attr("data-fancybox", "gallery"); // if you add 'data-fancybox', img will display after showed
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "gallery");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      });
      
      clearInterval(fancyTimer);
    });
  }, 10);
</script>

    
  </body>

</html>
